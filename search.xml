<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Sequelize入门使用]]></title>
    <url>%2F2017%2F11%2F25%2FSequelize%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Sequelize入门使用​ Sequelize是一个基于promise的关系型数据库ORM框架，这个库完全采用JavaScript开发并且能够用在Node.JS环境中，易于使用，支持多SQL方言(dialect)，。它当前支持MySQL,、MariaDB、SQLite、PostgreSQL、Sql Server 数据库。 ​ 因为是基于promise规范，在调用后的处理上不再是callback方式，而是统一的链式调用方式，调用直观，易读。本文以Sequelize操作SQLSERVER数据库为例。 安装依赖在工程文件夹下运行以下命令安装Sequelize模块，操作SQLSERVER还需要安装tedious模块 12npm install sequelize --savenpm install tedious --save 设置连接首先引入sequelize库 第一个参数’lwp’是数据库名 第二个参数’sa’是登录用户名 第三个参数’123456’是登录用户对应的密码 第四个参数： host:数据库主机地址 dialect:’mysql’|’sqlite’|’postgres’|’mssql’ pool:数据库连接池设置 12345678910111213var Sequelize = require(&apos;sequelize&apos;);var sequelize=new Sequelize(&apos;lwp&apos;,&apos;sa&apos;,&apos;123456&apos;,&#123; host:&apos;127.0.0.1&apos;, dialect:&apos;mssql&apos;, pool: &#123; max: 5, min: 0, acquire: 30000, idle: 10000 &#125;&#125;); 测试连接使用.authenticate()方法测试是否连接成功 12345678sequelize .authenticate() .then(() =&gt; &#123; console.log('Connection has been established successfully.'); &#125;) .catch(err =&gt; &#123; console.error('Unable to connect to the database:', err); &#125;); 创建表对应的模型映射：可以与已存在的表结构完全对应，也可以选择需要的属性列 sequelize.define的第三个参数是一个json对象，可以在里面设置tableName；sequelize默认会把define方法定义的单数表名变成复数的。设置freezeTableName: true则不会加上’s’；sequelize默认会加上时间戳，设置timestamps: false则没有 12345678910111213141516171819202122232425262728293031323334var Teacher=sequelize.define('Teacher',&#123; Id:&#123; type: Sequelize.DataTypes.UUID, primaryKey:true, defaultValue: Sequelize.DataTypes.UUIDV4, &#125;, Name:&#123; type:Sequelize.STRING, allowNull:false &#125;, Gender:&#123; type:Sequelize.INTEGER, allowNull:false &#125;, Age:&#123; type:Sequelize.INTEGER, allowNull:false &#125;, Salary:&#123; type:Sequelize.DOUBLE, allowNull:false &#125;, Birthday:&#123; type: Sequelize.DataTypes.DATE, allowNull: false, defaultValue: Sequelize.DataTypes.NOW &#125;&#125;,&#123; autoIncrement:false, charset:'utf8', collate: 'utf8_general_ci', freezeTableName:true, timestamps: false&#125;); 同步模型导数据库如果数据库中已经存在该模型对应的表，则不会进行同步操作，如果想要强制进行数据结构的同步，可以通过force参数指定 1Teacher.sync(&#123;force: true&#125;); 插入数据123456789101112Teacher.create(&#123; Name:'dema', Gender:1, Age:18, Salary:3000&#125;).then(function(result)&#123; console.log(result); console.log('添加成功...');&#125;).catch(function(err)&#123; console.log(err.message); console.log('添加失败...');&#125;); 查询数据调用模型对象的findAll方法进行查询操作，在参数中可以制定where条件。 where条件甚至可以支持数据库自身特有的函数。具体参考：http://sequelize.readthedocs.io/en/latest/docs/querying/&gt; 123456789101112Teacher.findAll(&#123; where:&#123; Name:&#123; $like:&apos;sa%&apos; &#125; &#125;&#125;).then(function(result)&#123; console.log(&apos;query all teachers&apos;); for(var i=0,teacher;teacher=result[i++];)&#123; console.log(&apos;Name:&apos;+teacher.Name+&apos;,Age:&apos;+teacher.Age+&apos;,Salary:&apos;+teacher.Salary); &#125;&#125;); 修改数据调用模型对象的update方法进行更新操作，在第一个参数中指定更新的字段和值，在第二个参数中指定条件。 123456789101112Teacher.update(&#123; Name:'newName', Age:28, Salary:3000&#125;,&#123; where:&#123; Name:'dema' &#125;&#125;).then(function(result)&#123; console.log('updated success...'); console.log(result); &#125;); 删除记录调用模型对象的destroy方法进行删除操作，在参数中指定删除条件。 12345678910Teacher.destroy(&#123; where:&#123; Name:&#123; $like:'sa%' &#125; &#125;&#125;).then(function(result)&#123; console.log('delete success'); console.log(result);&#125;);]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Sequelize</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript 6.0(ES6)规范总结]]></title>
    <url>%2F2017%2F11%2F20%2FECMAScript-6-0-ES6-%E8%A7%84%E8%8C%83%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[ECMAScript 6.0(ES6)规范总结(部分)相关背景介绍我们现在大多数人用的语法javascript 其实版本是ecmscript5,也是就es5。这个版本己经很多年了，且完美被各大浏览器所支持。所以很多学js的朋友可以一直分不清楚es5和javscript的关系。javascript是一门编程语言，那么它就会有版本，es5还是es6 就就是它的版本号。最新版es7己经在紧锣密布的进行中，它最新的语法会让我们写代码更新的行云流水。 babel 一个es6的解析器在我们正式讲解ES6语法之前，我们得先了解下Babel。 Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。大家可以选择自己习惯的工具来使用使用Babel,我最喜欢的构建工具就是webpack。具体过程可直接在Babel官网查看： 语法class、extends与superES6提供了更接近传统语言的写法，引入了Class（类）这个概念。新的class写法让对象原型的写法更加清晰、更像面向对象编程的语法，也更加通俗易懂。 123456789101112131415161718192021class Animal&#123; constructor()&#123; this.type='animal' &#125; says(say)&#123; console.log(this.type+' says '+say); &#125;&#125;let animal=new Animal();animal.says('hello'); // animal says helloclass Cat extends Animal&#123; constructor()&#123; super(); this.type='cat'; &#125;&#125;let cat=new Cat();cat.says('hello'); // cat says hello 上面代码首先用class定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。简单地说，constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实例对象可以共享的。 Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。上面定义了一个Cat类，该类通过extends关键字，继承了Animal类的所有属性和方法。 super关键字，它指代父类的实例（即父类的this对象）。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。 ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。 arrow function这个恐怕是ES6最最常用的一个新特性了，用它来写function比原来的写法要简洁清晰很多: 12function(i)&#123; return i+1;&#125; // ES5(i)=&gt;i+1 // ES6 如果方程比较复杂，则需要用{}把代码包起来： 123456function(x,y)&#123; x++; y--; return x+y;&#125; (x,y)=&gt;&#123;x++;y--;return x+y&#125; 除了看上去更简洁以外，arrow function还有一项超级无敌的功能！长期以来，JavaScript语言的this对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。例如： 12345678910111213class Animal&#123; constructor()&#123; this.type='animal'; &#125; says(say)&#123; setTimeout(function()&#123; console.log(this.type+' says '+say); &#125;,1000); &#125;&#125;var animal=new Animal();animal.says('hi'); // undefined says hi 运行上面的代码会报错，这是因为setTimeout中的this指向的是全局对象。所以为了让它能够正确的运行，传统的解决方法有两种： 1.第一种是将this传给self,再用self来指代this123456says(say)&#123; var self = this; setTimeout(function()&#123; console.log(self.type + ' says ' + say) &#125;, 1000) &#125; 2.第二种方法是用bind(this),即12345says(say)&#123; setTimeout(function()&#123; console.log(this.type + ' says ' + say) &#125;.bind(this), 1000) &#125; 但现在我们有了箭头函数，就不需要这么麻烦了： 12345678910111213class Animal &#123; constructor()&#123; this.type = 'animal' &#125; says(say)&#123; setTimeout(()=&gt;&#123; console.log(this.type+' says '+say); &#125;,1000); &#125;&#125; var animal = new Animal(); animal.says('hi'); // animal says hi 当我们使用箭头函数时，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，它的this是继承外面的，因此内部的this就是外层代码块的this。 template string这个东西也是非常有用，当我们要插入大段的html内容到文档中时，传统的写法非常麻烦，所以之前我们通常会引用一些模板工具库，比如mustache等等。 先看下面一段代码： 123456$("#result").append( "There are &lt;b&gt;" + basket.count + "&lt;/b&gt; " + "items in your basket, " + "&lt;em&gt;" + basket.onSale + "&lt;/em&gt; are on sale!" ); 我们要用一堆的’+’号来连接文本与变量，而使用ES6的新特性模板字符串``后，我们可以直接这么来写： 12345$("#result").append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`); destructuringES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 看下面的例子： 1234let cat = 'ken';let dog = 'lili';let zoo = &#123;cat: cat, dog: dog&#125;;console.log(zoo); // Object &#123;cat: "ken", dog: "lili"&#125; 用ES6完全可以像下面这么写： 1234let cat = 'ken'let dog = 'lili'let zoo = &#123;cat, dog&#125;console.log(zoo) // Object &#123;cat: "ken", dog: "lili"&#125; 反过来可以这么写： 123let dog = &#123;type: 'animal', many: 2&#125;let &#123; type, many&#125; = dogconsole.log(type, many) // animal 2]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>开发规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 中的let、const与var的区别]]></title>
    <url>%2F2017%2F11%2F12%2FES6-%E4%B8%AD%E7%9A%84let%E3%80%81const%E4%B8%8Evar%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[ES6 中的let、const与var的区别使用var声明的变量和不使用var声明的变量的区别 使用var声明的变量声明前调用，那么该变量的值为undefined；不使用var声明的变量声明前调用直接报错Uncaught ReferenceError：xxx is not difined； 使用var声明的变量不可delete，不使用var声明则可以delete掉释放空间。（实则浏览器的垃圾回收机制也会清理掉用var声明但是不再使用的的变量，比如某个仅执行一次的函数中被调用的某个var 声明的变量） 未使用var声明的变量实际上是window的一个对象，而使用var声明的变量只是一个本地变量而已。 在使用’use strict’的模式之下，不使用var 声明变量的语法是不被允许的，报错：Uncaugth SyntaxError; 123456789101112console.log(a); //undefined，这里还涉及&lt;span style="color:#ff0000;"&gt;变量提升&lt;/span&gt;的概念 //console.log(b); //报错 Uncaught ReferenceError: b is not defined var a = 1; b = 2; console.log(a); //1 console.log(b); //2 console.log(window.a); //undefined console.log(window.b); //2 delete a; delete b; console.log(a); //1 console.log(b); //报错 Uncaught ReferenceError: b is not defined,可见b在声明前使用和声明后delete再使用是一样的结果 let，var，const声明的变量的区别：1.const是常量的意思，就是说只能被定义一次，且不可再改变，否则就会报错：Uncaught TypeError: Assignment to constant variable.另外声明前使用也会报错：Uncaught ReferenceError: a is not defined；看一个例子： 123456const foo=&#123;&#125;;foo.prop=123;console.log(foo.prop); // 123foo.prop=456;console.log(foo.prop); // 456const foo=&#123;&#125;; // Identifier 'foo' has already been declared 2.var 和 let 就有意思了，let声明的变量声明前使用也会报错，这个与const一致；最重要的一点是let声明了一个块级作用域的变量在一个块的“}”结束的时候，该变量消失。例子： 123456789101112(function(x,y)&#123; var b=x; let c=y; if(true)&#123; var b=5; let c=6; console.log(b); // 5 console.log(c); // 6,这里的let c在下一行'&#125;'之后消失 &#125; console.log(b); // 5 console.log(c); // 3 这里仍然是第三行的let c;&#125;(2,3)); 3.再看一个例子 123456789101112131415var array1=[],array2=[];for(var i=0;i&lt;10;i++)&#123; array1[i]=function()&#123; console.log(i); &#125;;&#125;for(let j=0;j&lt;10;j++)&#123; array2[j]=function()&#123; console.log(j); &#125;&#125;array1[6](); // 10array2[6](); // 6 所以说let是一个比较保守的变量。这里变量为i的for循环中，i是一个全局变量，array1[i]是一个console.log(i)的函数，而i的最终结果为10，故而每次调用array1[i],实际上都是console.log(10);而let作为仅在其代码块有效的变量，当前的j仅在本轮的循环中有效，就是说每一次循环，j其实都是一个新产生的变量。所以let变量适合用于循环体中。 4.再看一个例子 12345var temp=1;if(true)&#123; temp=2; // temp is not defined,let声明的变量声明前使用也会报错 let temp;&#125; 这个例子中tmp=2的赋值会报错，因为if中的let对tmp变量的声明，导致该tmp绑定了这个作用域，而let不会像var那样“变量提升”，所以未声明赋值会报错。ES6中明确规定：如果区块中存在let和const命令，则这个区块对这些命令声明的变量从一开始就形成了封闭做作用域，只要在声明之前做任何使用，都会报错。这在语法上称为“暂时性死区”（temporal dead zone ，简称TDZ）。 5.var声明的变量为全局变量，而let，const声明的变量不为全局变量，使用window访问不到，如下： 1234var a=1;console.log(window.a); // 1let b=2;console.log(window.b); // undefined]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>开发规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Koa2框架开发记录]]></title>
    <url>%2F2017%2F11%2F09%2FKoa2%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Koa2框架开发记录环境准备 为node.js v7.6.0开始完全支持async/await，不需要加flag，所以node.js环境都要7.6.0以 node.js环境 版本v7.6以上 npm 版本3.x以上 安装ko212// 全局安装koa2 npm install koa -g hello world代码12345678const koa=require('koa');const app=new koa();app.use(ctx=&gt;&#123; ctx.body='hello koa2';&#125;);app.listen(3000); koa2原生路由实现简单例子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455const koa=require('koa');const fs=require('fs');const app=new koa();/** * 用Promise封装异步读取文件方法 * @param &#123;string&#125; page html文件 * @return &#123;promise&#125; */function render(page)&#123; return new Promise((resolve,reject)=&gt;&#123; let viewUrl='./view/'+page; fs.readFile(viewUrl,'utf-8',(err,data)=&gt;&#123; if(err)&#123; reject(err); &#125;else&#123; resolve(data); &#125; &#125;); &#125;);&#125;/** * 根据url获取html内容 * @param &#123;string&#125; url koa2上下文的url，ctx.url * @return &#123;string&#125; 获取html文件内容 */async function route(url)&#123; let view='404.html'; switch(url)&#123; case '/': view='index.html'; break; case '/index': view='index.html'; break; case '/todo': view='todo.html'; break; case '/404': view='404.html'; break; &#125; let html=await render(view); return html;&#125;app.use(async(ctx)=&gt;&#123; let url=ctx.request.url; let html=await route(url); ctx.body=html;&#125;);app.listen(3000);console.log('127.0.0.1:3000'); koa-router中间件​ 如果依靠ctx.request.url去手动处理路由，将会写很多处理代码，这时候就需要对应的路由的中间件对路由进行控制，这里介绍一个比较好用的路由中间件koa-router 快速使用koa-router1234567891011121314151617181920212223242526272829303132333435363738const Koa = require('koa');const fs = require('fs');const app = new Koa();const Router = require('koa-router');let home = new Router();// 子路由1home.get('/', async ( ctx )=&gt;&#123; let html = ` &lt;ul&gt; &lt;li&gt;&lt;a href="/page/helloworld"&gt;/page/helloworld&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="/page/404"&gt;/page/404&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; `; ctx.body = html;&#125;)// 子路由2let page = new Router();page.get('/404', async ( ctx )=&gt;&#123; ctx.body = '404 page!'&#125;).get('/helloworld', async ( ctx )=&gt;&#123; ctx.body = 'helloworld page!'&#125;);// 装载所有子路由let router = new Router();router.use('/', home.routes(), home.allowedMethods());router.use('/page', page.routes(), page.allowedMethods());// 加载路由中间件app.use(router.routes()).use(router.allowedMethods());app.listen(3000,()=&gt;&#123; console.log('127.0.0.1:3000');&#125;); 运行结果： GET请求数据获取使用方法在koa中，获取GET请求数据源头是koa中request对象中的query方法或querystring方法，query返回是格式化好的参数对象，querystring返回的是请求字符串，由于ctx对request的API有直接引用的方式，所以获取GET请求数据有两个途径。 1.是从上下文中直接获取 请求对象ctx.query，返回如 { a:1, b:2 } 请求字符串 ctx.querystring，返回如 a=1&amp;b=2 2.是从上下文的request对象中获取 请求对象ctx.request.query，返回如 { a:1, b:2 } 请求字符串 ctx.request.querystring，返回如 a=1&amp;b=2 用例1234567891011121314151617181920212223242526const koa=require('koa');const app=new koa();app.use(async(ctx)=&gt;&#123; let url=ctx.url; // 从上下文的request对象中获取 let request=ctx.request; let req_query=request.query; let req_querystring=request.querystring; // 从上下文中直接获取 let ctx_query=ctx.query; let ctx_querystring=ctx.querystring; ctx.body=&#123; url, req_query, req_querystring, ctx_query, ctx_querystring &#125;&#125;);app.listen(3000,()=&gt;&#123; console.log('127.0.0.1:3000');&#125;); 运行结果： POST请求参数获取原理​ 对于POST请求的处理，koa2没有封装获取参数的方法，需要通过解析上下文context中的原生node.js请求对象req，将POST表单数据解析成query string（例如：a=1&amp;b=2&amp;c=3），再将query string 解析成JSON格式（例如：{&quot;a&quot;:&quot;1&quot;, &quot;b&quot;:&quot;2&quot;, &quot;c&quot;:&quot;3&quot;}） 注意：ctx.request是context经过封装的请求对象，ctx.req是context提供的node.js原生HTTP请求对象，同理ctx.response是context经过封装的响应对象，ctx.res是context提供的node.js原生HTTP请求对象。 解析出POST请求上下文中的表单数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162const koa=require('koa');const app=new koa();app.use(async(ctx)=&gt;&#123; if(ctx.url==='/'&amp;&amp;ctx.method==='GET')&#123; // 当GET请求时候返回表单页面 let html=` &lt;h1&gt;koa2 request post demo&lt;/h1&gt; &lt;form method="POST" action="/"&gt; &lt;p&gt;userName&lt;/p&gt; &lt;input name="userName" /&gt;&lt;br/&gt; &lt;p&gt;nickName&lt;/p&gt; &lt;input name="nickName" /&gt;&lt;br/&gt; &lt;p&gt;email&lt;/p&gt; &lt;input name="email" /&gt;&lt;br/&gt; &lt;button type="submit"&gt;submit&lt;/button&gt; &lt;/form&gt; `; ctx.body=html; &#125;else if(ctx.url==='/'&amp;&amp;ctx.method==='POST')&#123; // 当POST请求的时候，解析POST表单里的数据，并显示出来 let postData=await parsePostData(ctx); ctx.body=postData; &#125;else&#123; // 其他请求显示404 ctx.body='&lt;h1&gt;404!!!&lt;/h1&gt;'; &#125;&#125;);// 解析上下文里的node原生请求的POST参数function parsePostData(ctx)&#123; return new Promise((resolve,reject)=&gt;&#123; try &#123; let postData=''; ctx.req.addListener('data',(data)=&gt;&#123; postData+=data; &#125;); ctx.req.addListener('end',function()&#123; let parseData=parseQueryStr(postData); resolve(parseData); &#125;); &#125; catch (error) &#123; reject(error); &#125; &#125;);&#125;// 将POST请求参数字符串解析成jsonfunction parseQueryStr(queryStr)&#123; let queryData=&#123;&#125;; let queryStrList=queryStr.split('&amp;'); console.log(queryStrList); for(let [index,queryStr] of queryStrList.entries())&#123; let itemList=queryStr.split('='); queryData[itemList[0]]=decodeURIComponent(itemList[1]); &#125; return queryData;&#125;app.listen(3000,()=&gt;&#123; console.log('127.0.0.1:3000');&#125;); 运行结果： koa-bodyparser中间件原理​ 对于POST请求的处理，koa-bodyparser中间件可以把koa2上下文的formData数据解析到ctx.request.body中 安装koa2版本的koa-bodyparser@3中间件1cnpm install koa-bodyparser -g 用例123456789101112131415161718192021222324252627282930313233343536const koa=require('koa');const app=new koa();const bodyParser=require('koa-bodyparser');// 使用ctx.body解析中间件app.use(bodyParser());app.use(async(ctx)=&gt;&#123; if(ctx.url==='/'&amp;&amp;ctx.method==='GET')&#123; // 当GET请求返回表单页面 let html = ` &lt;h1&gt;koa2 request post demo&lt;/h1&gt; &lt;form method="POST" action="/"&gt; &lt;p&gt;userName&lt;/p&gt; &lt;input name="userName" /&gt;&lt;br/&gt; &lt;p&gt;nickName&lt;/p&gt; &lt;input name="nickName" /&gt;&lt;br/&gt; &lt;p&gt;email&lt;/p&gt; &lt;input name="email" /&gt;&lt;br/&gt; &lt;button type="submit"&gt;submit&lt;/button&gt; &lt;/form&gt; ` ctx.body = html &#125;else if(ctx.url==='/'&amp;&amp;ctx.method==='POST')&#123; // 当POST请求的时候，中间件koa-bodyparser解析POST表单里的数据，并显示出来 let postData=ctx.request.body; ctx.body=postData; &#125;else&#123; // 其他请求显示404 ctx.body = '&lt;h1&gt;404！！！ o(╯□╰)o&lt;/h1&gt;' &#125;&#125;);app.listen(3000,()=&gt;&#123; console.log('127.0.0.1:3000');&#125;); 运行结果：]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Koa2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Express框架+中间件]]></title>
    <url>%2F2017%2F11%2F06%2FExpress%E6%A1%86%E6%9E%B6-%E4%B8%AD%E9%97%B4%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Express框架路由能力 12345678910111213141516171819var express = require("express");var app = express();app.get("/",function(req,res)&#123; res.send("你好");&#125;); app.get("/haha",function(req,res)&#123; res.send("这是haha页面，哈哈哈哈哈哈");&#125;);app.get(/^\/student\/([\d]&#123;10&#125;)$/,function(req,res)&#123; res.send("学生信息，学号" + req.params[0]);&#125;);app.get("/teacher/:gonghao",function(req,res)&#123; res.send("老师信息，工号" + req.params.gonghao);&#125;);app.listen(3000); 静态文件伺服能力 12// 静态文件伺服能力 默认调用public文件夹下的index.html文件app.use(express.static('./public')); 模板引擎 1234567891011121314var express=require('express');var app=express();// 使用ejs引擎只需要下载了ejs模块即可app.set("view engine","ejs");app.get("/",function(req,res)&#123; // haha 模板文件 res.render("haha",&#123; "news" : ["我是小新闻啊","我也是啊","哈哈哈哈"] &#125;);&#125;);app.listen(3000); 路由1234567891011121314151617181920// 当用get请求访问一个网址的时候，做什么事情：app.get("网址",function(req,res)&#123; &#125;);// 用post访问一个网址的时候，做什么事情：app.post("网址",function(req,res)&#123; &#125;);// 如果想处理这个网址的任何method的请求，那么写all：app.all("/",function()&#123; &#125;);// 这里的网址，不分大小写，也就是说，你路由是：app.get("/AAb",function()&#123; res.send("你好);&#125;);// 实际上小写的访问也行。 正则表达式可以被使用。正则表达式中，未知部分用圆括号分组，然后可以用req.params[0]、[1]得到。 1234// req.params类数组对象。app.get(/^\/student\/([\d]&#123;10&#125;)$/,function(req,res)&#123; res.send("学生信息，学号" + req.params[0]);&#125;); 冒号是更推荐的写法。 123456789app.get('student/:id',function(req,res)&#123; var id=req.params['id']; var req=/^[\d]&#123;6&#125;$/; if(req.test(id))&#123; res.send(id); &#125;else&#123; res.send('请检查格式'); &#125;&#125;); 表单可以自己提交到自己上。 12345678app.get("/",function(req,res)&#123; res.render("form");&#125;);app.post("/",function(req,res)&#123; //将数据添加进入数据库 res.send("成功");&#125;); 中间件如果我的的get、post回调函数中，没有next参数，那么就匹配上第一个路由，就不会往下匹配了。如果想往下匹配的话，那么需要写next(); 12345678app.get('/',function(req,res,next)&#123; console.log('1'); next();&#125;);app.get('/',function(req,res)&#123; console.log('2');&#125;); 解决路由冲突 12345678910111213141516171819202122232425262728293031323334353637383940// 下面两个路由，感觉没有关系：app.get("/:username/:id",function(req,res)&#123; console.log("1"); res.send("用户信息" + req.params.username);&#125;);app.get("/admin/login",function(req,res)&#123; console.log("2"); res.send("管理员登录");&#125;);// 但是实际上冲突了，因为admin可以当做用户名 login可以当做id。// 解决方法1：交换位置。 也就是说，express中所有的路由（中间件）的顺序至关重要。匹配上第一个，就不会往下匹配了。 具体的往上写，抽象的往下写。app.get('/admin/login',function(req,res)&#123; console.log('2'); res.send('管理员登录');&#125;);app.get("/:username/:id",function(req,res)&#123; console.log("1"); res.send("用户信息" + req.params.username);&#125;);// 解决方法2：app.get("/:username/:id",function(req,res,next)&#123; var username = req.params.username; // 检索数据库，如果username不存在，那么next() if(检索数据库)&#123; console.log("1"); res.send("用户信息"); &#125;else&#123; next(); &#125;&#125;);app.get("/admin/login",function(req,res)&#123; console.log("2"); res.send("管理员登录");&#125;); ​ 路由get、post这些东西，就是中间件，中间件讲究顺序，匹配上第一个之后，就不会往后匹配了。next函数才能够继续往后匹配。 ​ app.use()也是一个中间件。与get、post不同的是，他的网址不是精确匹配的。而是能够有小文件夹拓展的。 比如网址： http://127.0.0.1:3000/admin/aa/bb/cc/dd 123456app.use("/admin",function(req,res)&#123; res.write(req.originalUrl + "\n"); // /admin/aa/bb/cc/dd res.write(req.baseUrl + "\n"); // /admin res.write(req.path + "\n"); // /aa/bb/cc/dd res.end("你好");&#125;); 如果写一个/ 12345// 当你不写路径的时候，实际上就相当于"/"，就是所有网址app.use(function(req,res,next)&#123; console.log(new Date()); next();&#125;); app.use()就给了我们增加一些特定功能的便利场所。 实际上app.use()的东西，基本上都从第三方能得到。 大多数情况下，渲染内容用res.render()，将会根据views中的模板文件进行渲染。如果不想使用views文件夹，想自己设置文件夹名字，那么app.set(“views”,”aaaa”); 如果想写一个快速测试页，当然可以使用res.send()。这个函数将根据内容，自动帮我们设置了Content-Type头部和200状态码。send()只能用一次，和end一样。和end不一样在哪里？能够自动设置MIME类型。 如果想使用不同的状态码，可以：res.status(404).send(‘Sorry, we cannot find that!’); 如果想使用不同的Content-Type，可以：res.set(‘Content-Type’, ‘text/html’);]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js之Promise模块]]></title>
    <url>%2F2017%2F11%2F01%2FNode-js%E4%B9%8BPromise%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[Node.js之Promise模块所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise对象有以下两个特点。（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。 JavaScript中是通过回调函数来处理异步逻辑的比如读取文件的代码，如下所示 12345getAsync("fileA.txt", function(error, result)&#123; if(error)&#123; // 取得失败时的处理 throw error; &#125;&#125; Nodejs中规定在Javascript的回掉函数的第一个参数是Error对象。像上面这样基于回调函数的异步处理如果统一参数使用规则的话，写法也会很明了。但是，这也仅是编码规约而已，即使采用不同的写法也不会出错。Promise则是把类似的异步处理对象和处理规则进行规范化，并按照采用统一的接口来编写，而采取规定方法之外的写法都会出错。 下面通过Promise写法改写上面的函数123456var promise = getAsyncPromise("fileA.txt"); //返回promise对象promise.then(function(result)&#123; // 获取文件内容成功时的处理&#125;).catch(function(error)&#123; // 获取文件内容失败时的处理&#125;); 除promise对象规定的方法(这里的 then 或 catch )以外的方法都是不可以使用的，而不会像回调函数方式那样可以自己自由的定义回调函数的参数，而必须严格遵守固定、统一的编程方式来编写代码。这样，基于Promise的统一接口的做法， 就可以形成基于接口的各种各样的异步处理模 式。所以，promise的功能是可以将复杂的异步处理轻松地进行模式化，这也可以说得上是 使用promise的理由之一。 Promise 简介构造器要想创建一个Promise对象，可以使用new调用Promise的构造器来进行实例化。 123var promise = new Promise(function(resolve, reject) &#123; // 异步处理// 处理结束后、调用resolve 或 reject&#125;); 实例方法Promise.prototype.then对通过new生成的promise对象为了设置其值在 resolve (成功)/ reject（失败）时调用的回调函数 可以使用 promise.then()实例方法(也就是说作用是为 Promise 实例添加状态改变时的回调函数。)。 1promise.then(onFulfilled, onRejected) then方法的第一个参数是 Resolved 状态的回调函数， 第二个参数（ 可选） 是 Rejected 状态的回调函数。 resolve(成功)时 onFulfilled 会被调用 reject(失败)时 onRejected 会被调用 then方法返回的是一个新的 Promise 实例（ 注意，不是原来那个 Promise 实例）。 因此可以采用链式写法， 即then方法后面再调用另一个`then方法。 123456789getJSON("/post/1.json") // 返回一个Promise对象，详见下文.then(function(post) &#123; return getJSON(post.commentURL); // 返回一个Promise对象&#125;).then(function funcA(comments) &#123; console.log("Resolved: ", comments); &#125;, function funcB(err) &#123; console.log("Rejected: ", err); &#125;); 上面的代码使用then方法，依次指定了两个回调函数。 第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。采用链式的then，可以指定一组按照次序调用的回调函数。 Promise.prototype.catch()promise.then成功和失败时都可以使用。另外在只想对异常进行处理时可以采用Promise.then(undefined, onRejected)这种方式，只指定reject时的回调函数即可。Promise.prototype.catch方法是.then(null, rejection) 的别名， 用于指定发生错误时的回调函数,等同于抛出错误。上文的代码可以改造成如下: 12345678910getJSON("/post/1.json") // 返回一个Promise对象，详见下文.then(function(post) &#123; return getJSON(post.commentURL); // 返回一个Promise对象&#125;).then(function (comments) &#123; console.log("Resolved: ", comments); &#125;).catch(err) &#123; console.log("Rejected: ", err); &#125;); 需要注意的是，如果 Promise 状态已经变成Resolved， 再抛出错误是无效的。 123456789101112var promise = new Promise(function(resolve, reject) &#123; resolve('ok'); throw new Error('test'); &#125;); promise .then(function(value) &#123; console.log(value) &#125;) .catch(function(error) &#123; console.log(error) &#125;); // ok 上面代码中， Promise 在resolve语句后面，再抛出错误，不会被捕获， 等于没有抛出。 Promise 对象的错误具有“ 冒泡” 性质， 会一直向后传递， 直到被捕获为止。 也就是说， 错误总是会被下一个catch语句捕获。 1234567891011121314151617181920212223var catchTest = new Promise(function(resolve, reject) &#123; setTimeout(function()&#123; resolve('aa') &#125;, 1000) &#125;) catchTest.then(function(value)&#123; console.log('a')&#125;).then(function(value)&#123; throw new Error('test'); console.log('b')&#125;).then(function(value)&#123; console.log('c')&#125;).catch(function(error)&#123; console.log(error)&#125;)//a//[Error: test] 上面代码中，一共有四个Promise 对象：一个由’catchTest’产生， 三个由then产生。它们之中的第二个then方法出了错误，中断了下面的then方法，直接被最后一个catch捕获。 建议总是使用catch方法， 而不使用then方法的第二个处理错误的参数。 跟传统的try / catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码， 即不会有任何反应。 123456789var someAsyncThing = function() &#123; return new Promise(function(resolve, reject) &#123; // 下面一行会报错，因为 x 没有声明 resolve(x + 2); &#125;); &#125;; someAsyncThing().then(function() &#123; console.log('everything is great'); &#125;); 上面代码中，someAsyncThing函数产生的 Promise 对象会报错， 但是由于没有指定catch方法，这个错误不会被捕获，也不会传递到外层代码， 导致运行后没有任何输出。 注意， Chrome 浏览器不遵守这条规定， 它会抛出错误“ ReferenceError: x is not defined”。 1234567891011var promise = new Promise(function(resolve, reject) &#123; resolve("ok"); setTimeout(function() &#123; throw new Error('test') &#125;, 0) &#125;); promise.then(function(value) &#123; console.log(value) &#125;); // ok // Uncaught Error: test ​ 上面代码中，Promise指定在下一轮“ 事件循环” 再抛出错误， 结果由于没有指定使用try…catch语句，就冒泡到最外层，成了未捕获的错误。 因为此时，Promise 的函数体已经运行结束了， 所以这个错误是在Promise函数体外抛出的。 Node.js 有一个unhandledRejection事件，专门监听未捕获的reject错误。unhandledRejection事件的监听函数有两个参数， 第一个是错误对象， 第二个是报错的 Promise 实例， 它可以用来了解发生错误的环境信息。 123process.on('unhandledRejection', function(err, p) &#123; console.error(err.stack) &#125;); 需要注意的是，catch方法返回的还是一个Promise对象，因此后面还可以接着调用then方法。 123456789101112131415var someAsyncThing = function() &#123; return new Promise(function(resolve, reject) &#123; // 下面一行会报错，因为 x 没有声明 resolve(x + 2); &#125;); &#125;; someAsyncThing() .catch(function(error) &#123; console.log('oh no', error); &#125;) .then(function() &#123; console.log('carry on'); &#125;); // oh no [ReferenceError: x is not defined] // carry on 上面代码运行完catch方法指定的回调函数，会接着运行后面那个then方法指定的回调函数。 如果没有报错， 则会跳过catch方法。 静态方法像 Promise 这样的全局对象还拥有一些静态方法。 包括 Promise.all() 还有 Promise.resolve() 等在内，主要都是一些对Promise进行操作的 辅助方法。 Promise 状态我们已经大概了解了Promise的处理流程，接下来让我们来稍微整理一下Promise的状态。 用 new Promise 实例化的promise对象有以下三个状态。 “has-resolution” 即Fulfilled resolve(成功)时。此时会调用 onFulfilled “has-rejection” 即Rejected reject(失败)时。此时会调用 onRejected “unresolved” 即Pending 既不是resolve也不是reject的状态。也就是promise对象刚被创建后的初始化状态等 promise对象的状态，从Pending转换为Fulfilled或Rejected之后， 这个promise对象的状态就不会再发生任何变化。也就是说，只有异步操作的结果可以决定当前是哪一种状态，其他任何操作都无法改变这种状态；一旦状态改变，就不会再改变。 Promise与Event等不同，在 .then 后执行的函数可以肯定地说只会被调用一次。 还有需要注意，Promise创建后回立刻执行,看下面代码 1234567891011var promise = new Promise(function(resolve, reject) &#123; console.log('Promise'); resolve(); &#125;); promise.then(function() &#123; console.log('Resolved.'); &#125;); console.log('Hi!'); // Promise // Hi! // Resolved 上面代码中， Promise 新建后立即执行， 所以首先输出的是“ Promise”。 然后， then方法指定的回调函数， 将在当前脚本所有同步任务执行完才会执行， 所以“ Resolved” 最后输出。 Promise也是有缺点的 无法取消Promise，一旦新建它就会立即执行，无法中途取消。 如果不设置回调函数， Promise内部抛出的错误，不会反应到外部。 当处于Pending状态时， 无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js之path模块]]></title>
    <url>%2F2017%2F10%2F30%2Fnode-js%E4%B9%8Bpath%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[Node.js之path模块12// 引用该模块var path=require('path'); path.parse(pathString),将路径字符串转换成对象12345678910// 将路径字符串转换成对象var obj1=path.parse('D:\\开发专用文件夹');console.log(obj1);&#123; root: 'D:\\', dir: 'D:\\', base: '开发专用文件夹', ext: '', name: '开发专用文件夹' &#125; path.format(pathObject),将object对象序列化成字符串1234567891011121314151617181920212223242526272829303132// 将object对象序列化成字符串var url1=path.format(&#123; dir:'/home/user/dir', base:'file.txt'&#125;);//console.log(url1); // /home/user/dir\file.txtvar url2=path.format(&#123; root:'F:\\', base:'file.txt'&#125;);//console.log(url2); // F:\file.txtvar url3=path.format(&#123; root:'F:', dir:'F:\\dir1\\dir2', name:'file', ext:'.txt'&#125;);//console.log(url3); // F:\dir1\dir2\file.txtvar url4=path.format(&#123; base:'file.txt'&#125;);//console.log(url4); // file.txtvar url5=path.format(&#123; root:'F:', dir:'F:\\dir1\\dir2', base:'file.txt'&#125;);//console.log(url5); // F:\dir1\dir2\file.txt path.normalize(p) ,标准化路径字符串，处理冗余的“ .. ”、“ . ”、“ / ”字符12345678// 如果在win下，返回 dir1\dir2格式 // 如果在unix下，返回 dir1/dir2格式 var url1 = path.normalize('a/b/c/../user/vajoy/bin'); var url2 = path.normalize('a/b/c///../user/vajoy/bin/'); var url3 = path.normalize('./a/.././user/vajoy/bin/./'); console.info(url1); // a\b\user\vajoy\binconsole.info(url2); // a\b\user\vajoy\bin\console.info(url3); // user\vajoy\bin\ path.join([path1], [path2], […]),将多个路径结合在一起，并转换为标准化的路径1234567var url1 = path.join('////./a', 'b////c', 'user/', 'vajoy', '..'); var url2 = path.join('a', '../../', 'user/', 'vajoy', '..'); var url4=path.join('c:\\one','\\abc\\','/dir/file.txt'); console.log('url1:',url1); // \a\b\c\user console.log('url2:',url2); // ..\user console.log('url4:',url4); // c:\one\abc\dir\file.txt path.sep,返回对应平台下的文件夹分隔符，win下为’\’，*nix下为’/‘12345678// 返回对应平台下的文件夹分隔符，win下为'\'，*nix下为'/' var url1 = path.sep; var url2 = 'foo\\bar\\baz'.split(path.sep); var url3 = 'foo/bar/baz'.split(path.sep); console.log('url1:',url1); // win下为\，*nix下为/ console.log('url2:',url2); // [ 'foo', 'bar', 'baz' ] console.log('url3:',url3); // win下返回[ 'foo/bar/baz' ]，但在*nix系统下会返回[ 'foo', 'bar', 'baz' ] path.isAbsolute(path),判断是否是绝对路径，比如 ‘E:/abc’，或者是以“/”开头的路径，二者都会返回true123456789101112131415//判断是否是绝对路径 //比如 'E:/abc'，或者是以“/”开头的路径，二者都会返回true var url1 = path.isAbsolute('../testFiles/secLayer'); var url2 = path.isAbsolute('./join.js'); var url3 = path.isAbsolute('temp'); var url4 = path.isAbsolute('/temp/../..'); var url5 = path.isAbsolute('E:/github/nodeAPI/abc/efg'); var url6 = path.isAbsolute('///temp123'); console.log('url1:',url1); // false console.log('url2:',url2); // false console.log('url3:',url3); // false console.log('url4:',url4); // true console.log('url5:',url5); // true console.log('url6:',url6); // true path.relative(from,to),获取从 from 到 to 的相对路径1234567var url1 = path.relative('C:\\vajoy\\test\\aaa', 'C:\\vajoy\\impl\\bbb'); var url2 = path.relative('C:/vajoy/test/aaa', 'C:/vajoy/bbb'); var url3 = path.relative('C:/vajoy/test/aaa', 'D:/vajoy/bbb'); console.log('url1:',url1); // ..\..\impl\bbb console.log('url2:',url2); // ..\..\bbb console.log('url3:',url3); // D:\vajoy\bbb path.dirname(p),返回指定uri字符串中文件夹的路径，如果当前为目录，则返回上一级目录12345678910//返回指定uri字符串中文件夹的路径 //如果当前为目录，则返回上一级目录 //对于Url格式的指定解析无效 var url1 = path.dirname('/foo/bar/baz/asdf/a.txt'); var url2 = path.dirname('/foo/bar/baz/asdf/'); var url3 = path.dirname('C:/vajoy/test/aaa'); console.log(url1); // /foo/bar/baz/asdfconsole.log(url2); // /foo/bar/bazconsole.log(url3); // C:/vajoy/test path.basename(p,[ext]),返回路径中的最后一部分，类似于Unix 的 basename 命令。 ext 为需要截掉的尾缀内容123456789var url1=path.basename('/foo/bar/baz/a.txt');var url2=path.basename('/foo/bar/baz/a.txt','.txt');var url3=path.basename('/foo/bar/baz/');var url4=path.basename('C:/vajoy/test/aaa');console.log('url1:',url1); // a.txtconsole.log('url2:',url2); // aconsole.log('url3:',url3); // bazconsole.log('url4:',url4); // aaa path.extname(p),返回路径文件的扩展名（若存在）123456789101112//返回路径文件的扩展名（若存在） var url1 = path.extname('/foo/bar/baz/asdf/a.txt'); var url2 = path.extname('/foo/bar/baz/asdf/a.txt.html'); var url3 = path.extname('/foo/bar/baz/asdf/a.'); var url4 = path.extname('C:/vajoy/test/.'); var url5 = path.extname('C:/vajoy/test/a'); console.log('url1:',url1); // .txt console.log('url2:',url2); // .html console.log('url3:',url3); // . console.log('url4:',url4); // console.log('url5:',url5); //]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Node.js常用模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js之fs模块]]></title>
    <url>%2F2017%2F10%2F30%2FNode-js%E4%B9%8Bfs%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[Node.js之fs模块1var fs=require('fs'); 检测文件是否存在1234// 检测文件是否存在fs.exists('./image/my.png',function(exists)&#123; console.log(exists); // true or false&#125;) 异步操作1234567891011121314151617181920212223// 新建目录 目录权限，默认0777fs.mkdir('./MyTets',0777,function(err)&#123; if(err)&#123; throw err; &#125; console.log('创建文件夹成功');&#125;);// 创建文件并写入内容fs.writeFile('./MyTest/1.txt','随便写入一句话',function(err)&#123; if(err)&#123; throw err; &#125; console.log('写入文件成功');&#125;);// 读取文件fs.readFile('./MyTest/1.txt','utf8',function(err,data)&#123; if(err)&#123; throw err; &#125; console.log(data);&#125;); 同步操作1234567891011// 新增目录fs.mkdirSync('./MyTest',0777);console.log('新建MyTest文件夹成功');// 写入文件fs.writeFileSync('./MyTest/my.txt','再见了，LOL','utf8');console.log('新建文件成功');// 读取文件var data=fs.readFileSync('./MyTest/my.txt','utf8');console.log('读取文件：'+data); 读取目录12345678fs.readdir('H:\\Geoverver+扩展包',function(err,files)&#123; if(err)&#123; throw err; &#125; var length=files.length; console.log('一共有'+length+'个文件'); console.log(files);&#125;); 判断是文件还是目录12345678910fs.stat('D:\\开发专用文件夹\\weapp-demo-master.zip',function(err,stat)&#123; if(err)&#123; throw err; &#125; if(stat.isFile())&#123; console.log('这是个文件'); &#125;else if(stat.isDirectory())&#123; console.log('这是个目录'); &#125;&#125;); 读写数据流12345678910111213141516// 读取数据流var file=fs.createReadStream('./MyTest/my.txt');var str='';file.on('data',function(data)&#123; str+=data;&#125;);file.on('end',function()&#123; console.log(str);&#125;);// 写入数据流var file=fs.createWriteStream('./MyTest/myTest.txt',&#123;encoding:'utf8'&#125;);file.write('写入一句\n');file.write('再写入一句\n');file.write('啦啦啦');file.end(); 以追加方式写文件1234// 以追加方式写文件fs.appendFile('./MyTest/myTest.txt','这是额外追加的内容',function()&#123; console.log('追加内容完成');&#125;); 管道pipe实现流读写1234567891011// 管道pipe实现流读写var rs=fs.createReadStream('./MyTest/myTest.txt');var ws=fs.createWriteStream('./MyTest/pipe.txt');rs.pipe(ws);rs.on('data',function(data)&#123; console.log('数据可读');&#125;);rs.on('end',function()&#123; console.log('文件读取完成');&#125;);]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Node.js常用模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js之http模块]]></title>
    <url>%2F2017%2F10%2F29%2Fnode-js%E4%B9%8Bhttp%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[1.http.get(options[, callback]),发送简单Get请求，并响应1234567891011var http=require('http');// get 请求外网http.get('http://itcabin.com/',function(req,res)&#123; var html=''; req.on('data',function(data)&#123; html+=data; &#125;); req.on('end',function()&#123; console.log(html); &#125;);&#125;) 2.http.request(options[, callback]),使用详细配置，发送Get或Post请求发送Post实例：注http请求头使用headers指定123456789101112131415161718192021222324252627282930313233343536var http=require('http');var queryString=require('querystring');// 发送 http Post请求var postData=queryString.stringify(&#123; msg:'自由之翼'&#125;);var options=&#123; hostname:'www.gongjuji.net', port:80, path:'/', method:'POST', headers:&#123; 'Content-Type':'application/x-www-form-urlencoded; charset=UTF-8', 'Content-Length':Buffer.byteLength(postData) &#125;&#125;var req=http.request(options,function(res)&#123; var html=''; console.log('Status:',res.statusCode); console.log('headers:',JSON.stringify(res.headers)); res.setEncoding('utf-8'); res.on('data',function(chun)&#123; console.log('body分割线-------------------------------'); html+=chun; &#125;); res.on('end',function()&#123; console.log(html); &#125;);&#125;);req.on('error',function(err)&#123; console.error(err);&#125;);req.write(postData);req.end(); 发送Get请求实例：123456789101112131415161718192021222324252627282930313233343536// 发送GET请求var http=require('http');var querystring=require('querystring');var data=&#123; age:13, time:new Date().getTime()&#125;;var content=querystring.stringify(data);var options=&#123; hostname:'www.gongjuji.net', port:80, path:'/', method:'GET'&#125;// 创建请求var req=http.request(options,function(res)&#123; var html=''; console.log('STATUS:',res.statusCode); console.log('HEADERS:',JSON.stringify(res.headers)); res.setEncoding('utf-8'); res.on('data',function(chunk)&#123; console.log('body数据隔离--------------------------------'); html+=chunk; &#125;); res.on('end',function()&#123; console.log(html); &#125;);&#125;);req.on('error',function(err)&#123; console.log(err);&#125;);req.end(); 3.创建服务器http.createServer123456789var http=require('http');http.createServer(function(request,response)&#123; response.writeHead(200,&#123;'Content-Type':'text/plain'&#125;); response.write('Hello World'); response.end();&#125;).listen(8077,'127.0.0.1');console.log('Server Running on port 8077'); 4.http.ClientRequesthttp.ClientRequest 是http.request或者http.get返回产生的对象，表示一个已经产生而且正在进行的http请求，提供一个response事件，也就是我们使用http.get和http.request方法中的回调函数所绑定的对象，我们可以显示的绑定这个事件的监听函数。 123456789101112131415161718192021var http = require('http');var options = &#123; hostname: 'www.baidu.com', port:'8070'&#125;// 这里的req就是http.ClientRequest的一个实例，注意与http.IncomingMessage的区别var req = http.request(options);req.on('response', function(res)&#123; res.setEncoding('utf-8'); res.on('data', function(chunk)&#123; console.log(chunk.toString()) &#125;); console.log(res.statusCode);&#125;)req.on('error', function(err)&#123; console.log(err.message);&#125;);req.end();]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Node.js常用模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo常用命令笔记]]></title>
    <url>%2F2017%2F08%2F06%2Fhexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[hexo123npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 简写12345hexo n "我的博客" == hexo new "我的博客" #新建文章hexo p == hexo publishhexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署 服务器12345678hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页hexo d #开始部署 推送到服务器上123hexo n #写文章hexo g #生成hexo d #部署 #可与hexo g合并为 hexo d -g 监视文件变动12hexo generate #使用 Hexo 生成静态文件快速而且简单hexo generate --watch #监视文件变动 报错1.找不到git部署1ERROR Deployer not found: git 解决方法 1npm install hexo-deployer-git --save]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用pm2部署nodejs项目]]></title>
    <url>%2F2017%2F08%2F06%2F%E4%BD%BF%E7%94%A8pm2%E9%83%A8%E7%BD%B2nodejs%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[安装pm2使用命令 cd F:\nodejs定位到nodejs安装目录，执行以下命令安装pm2 1npm install -g pm2 使用pm2运行程序在程序根目录打开命令行窗口 shift+右键 1pm2 start index.js 查看运行状态1pm2 list 重启程序述restarted那栏变成1，可以显示程序运行了多长时间、占用内存大小 1pm2 restart index.js 查看启动程序的详细信息1pm2 describe id 终止程序1pm2 stop index.js 查看得到进程(以及集群)的CPU的使用率和内存占用1pm2 monit 强大API你想要监控所有被PM2管理的进程,而且同时还想监控运行这些进程的机器的状态， 1pm2 web 启动程序的时候顺便在浏览器访问：http://localhost:**9615** 把部署的服务器的信息和程序的信息都显示出来了： 所有命令总结：1234567891011安装：npm install -g pm2启动程序：pm2 start &lt;app_name|id|all&gt; 可以指定应用名称 pm2 start app,js --name=test列举进程：pm2 list退出程序：pm2 stop &lt;app_name|id|all&gt;重起应用：pm2 restart程序信息：pm2 describe id|all监控：pm2 monit实时集中log处理: pm2 logsAPI:pm2 web (端口：9615 )]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>pm2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js基础学习17--操作MongoDB]]></title>
    <url>%2F2017%2F06%2F15%2FNode-js%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A017-%E6%93%8D%E4%BD%9CMongoDB%2F</url>
    <content type="text"><![CDATA[安装驱动在 nodejs安装目录下执行以下命令： 1$ npm install mongodb 接下来我们来实现增删改查功能。 数据库操作( CURD )与 MySQL 不同的是 MongoDB 会自动创建数据库和集合，所以使用前我们不需要手动去创建。 插入数据以下实例我们连接数据库 runoob 的 myDatabase表，并插入两条数据： 12345678910111213141516171819202122232425262728var mongoClient=require('mongodb').MongoClient;var connStr='mongodb://localhost:8099/myDatabase';var insertData=function(db,callback)&#123; // 连接到表 myDatabase var collection=db.collection('myDatabase'); // 插入数据 var data=[&#123; 'name':'kakaxi', 'url':'www.baidu.com', 'title':[&#123;'name1':'sasuke','name2':'naruto'&#125;] &#125;,&#123;'sex':'man'&#125;]; collection.insert(data,function(err,result)&#123; if(err)&#123; console.log('Error:'+err); return; &#125; callback(result); &#125;);&#125;mongoClient.connect(connStr,function(err,db)&#123; console.log('连接成功!'); insertData(db,function(result)&#123; console.log(result); db.close(); &#125;)&#125;); 执行以上命令输出结果： 从输出结果来看，数据已插入成功。 查询数据以下实例检索 title为 “dmxy” 的实例： 123456789101112131415161718192021222324var mongoClient=require('mongodb').MongoClient;var connStr='mongodb://localhost:8099/myDatabase';var selectData=function(db,callback)&#123; // 连接到表 var collection=db.collection('myDatabase'); // 查询数据 var whereStr=&#123;'title' : 'dmxy'&#125;; collection.find(whereStr).toArray(function(err,result)&#123; if(err)&#123; console.log('Error:'+err); return; &#125; callback(result); &#125;);&#125;mongoClient.connect(connStr,function(err,db)&#123; console.log('连接成功!'); selectData(db,function(result)&#123; console.log(result); db.close(); &#125;);&#125;); 执行以上命令输出结果： 更新数据以下实例更新name为 “itach” 的数据age为 18实例： 12345678910111213141516171819202122232425var mongoClient=require('mongodb').MongoClient;var connStr='mongodb://localhost:8099/myDatabase';var updateData=function(db,callback)&#123; // 连接到表 var collection=db.collection('myDatabase'); // 更新数据 var whereStr=&#123;'name' : 'itach'&#125;; var updateStr=&#123;$set:&#123;'age':18&#125;&#125;; collection.update(whereStr,updateStr,function(err,result)&#123; if(err)&#123; console.log('Error:'+err); return; &#125; callback(result); &#125;);&#125;mongoClient.connect(connStr,function(err,db)&#123; console.log('连接成功!'); updateData(db,function(result)&#123; console.log(result); db.close(); &#125;);&#125;); 执行成功后，进入 mongo 管理工具查看数据已修改： 删除数据以下实例将 url为 “www.baidu.com” 的数据删除 : 123456789101112131415161718192021222324var mongoClient=require('mongodb').MongoClient;var connStr='mongodb://localhost:8099/myDatabase';var delData=function(db,callback)&#123; // 连接到表 var collection=db.collection('myDatabase'); // 删除数据 var whereStr=&#123;'url' : 'www.baidu.com'&#125;; collection.remove(whereStr,function(err,result)&#123; if(err)&#123; console.log('Error:'+err); return; &#125; callback(result); &#125;);&#125;mongoClient.connect(connStr,function(err,db)&#123; console.log('连接成功!'); delData(db,function(result)&#123; console.log(result); db.close(); &#125;);&#125;); 执行成功后，进入 mongo 管理工具查看数据已删除：]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB学习笔记01--安装及配置]]></title>
    <url>%2F2017%2F06%2F13%2FMongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[MongoDB 安装及配置1.双击安装 mongodb-win32-x86_64-2008plus-ssl-3.4.4-signed.msi 文件，安装目录 E:\MongoDB 2.配置 MONGODB_HOME 环境变量 ​ MONGODB_HOME=E:\MongoDB\Server\3.4 修改 path 变量值：在最后加上 %MONGODB_HOME%\bin 3.以管理员身份运行 cmd 工具 创建 E:\MongoDB\data 文件夹用于存放数据文件 创建 E:\MongoDB\logs\mongo.log 文件用于记录日志 输入以下命令： 1mongod --port 8099 --dbpath E:\MongoDB\data --logpath E:\MongoDB\logs\mongo.log --serviceName MongoDBService --serviceDisplayName MongoDBService --logappend --nojournal --storageEngine wiredTiger --wiredTigerCacheSizeGB 4 --install 输入 net start MongoDBService 命令启动mongodb服务 4.安装 MongoChef 在 E:\MongoChef 设置连接名称、IP及端口]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
        <tag>安装及配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB学习笔记02--CRUD操作及常用命令]]></title>
    <url>%2F2017%2F06%2F12%2FMongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002-CRUD%E6%93%8D%E4%BD%9C%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[CRUDMongoDB 存储数据称为：documents，使用类似JSON的键值对方式。mongodb documents称为BSON.documents以collections集合方式存储。集合是一类关联的documents的分组，有共享的索引。 操作示例一些命令查看帮助12345helpdb.help();db.collectionname.help();db.collectionname.find().help();rs.help(); 数据库操作切换数据库12use dbname;对于不存在的db会自动创建 查询所有数据库1show dbs; 删除当前使用数据库1db.dropDatabase(); 从指定主机克隆数据库1db.cloneDatabase('host ip'); 从指定的机器上复制数据库到某个数据库1db.copyDatabase('mydb','temp','host ip'); 修复当前数据库1db.repairDatabase(); 查看当前使用的数据库12db.getName();db; 显示当前db状态1db.stats(); 当前db版本1db.version(); 查看当前db的链接机器地址1db.getMongo(); Collection集合操作创建一个集合1db.createCollection('user',&#123;size:20,capped:5,max:100&#125;); 获取集合1db.getCollection('user'); 查询现在所有集合1db.getCollectionNames(); 显示当前db所有聚集索引的状态1db.printCollectionStats(); 集合数据空间大小1db.user.dataSize(); 集合数据条数1db.user.count(); 集合所在db1db.user.getDB(); 集合状态1db.user.stats(); 集合总大小1db.user.totalSize(); 聚焦集合存储空间大小1db.user.storageSize(); Shard版本信息1db.user.getShardVersion(); 聚集集合重命名1db.user.renameCollection('users'); 删除当前聚集集合1db.user.drop(); 删除集合里所有记录1db.user.remove(&#123;&#125;); collection记录操作插入12db.user.insert(&#123;id:1,userName:'username'&#125;);db.user.save(&#123;name:'kakaxi',age:22,sex:true&#125;); 修改1db.user.update(&#123;age:22&#125;,&#123;$set:&#123;name:'chen'&#125;&#125;,false,true) 删除1db.user.remove(&#123;age:20&#125;); 查询修改12345678910111213db.users.findAndModify(&#123; query: &#123;age: &#123;$gte: 25&#125;&#125;, sort: &#123;age: -1&#125;, update: &#123;$set: &#123;name: 'a2'&#125;, $inc: &#123;age: 2&#125;&#125;, remove: true&#125;);db.runCommand(&#123; findandmodify : "users", query: &#123;age: &#123;$gte: 25&#125;&#125;, sort: &#123;age: -1&#125;, update: &#123;$set: &#123;name: 'a2'&#125;, $inc: &#123;age: 2&#125;&#125;, remove: true&#125;); 查询123456789101112131415161718192021222324252627282930db.user.find();// 查询结果排除重复db.user.distinct("name");// 条件查询db.user.find(&#123;"name","a"&#125;);// 大于查询db.user.find(&#123;age:&#123;$gt:22&#125;&#125;); $lt小于 $ate大于等于 $lte小于等于// 包含查询db.user.find(&#123;name:/mongo/&#125;);// 开头查询db.user.find(&#123;name:/^mongo/&#125;);// 查询指定列db.user.find(&#123;&#125;,&#123;name:1,age:1&#125;); //如果是age:false，就是除了age列// 排序db.user.find().sort(&#123;age:1&#125;); //-1为降序// 查询前5条db.user.find().limit(5);// 查询10条后db.user.find().skip(10);// 查询某区间条数db.user.find().limit(10).skip(5);// 用于分页，limit是pageSize,skip是第几页*pageSize或与查询db.user.find(&#123;$or:[&#123;name:'张三'&#125;,&#123;name:'李四'&#125;]&#125;);// 查询第一条db.user.findOne();// 查询某个结果集的记录条数db.user.find(&#123;age:&#123;$gte:25&#125;&#125;).count();// 某列排序db.user.find(&#123;sex:&#123;$exists:true&#125;&#125;).count(); 用户操作添加一个用户语法12345678&#123; user: "&lt;name&gt;", pwd: "&lt;cleartext password&gt;", customData: &#123; &lt;any information&gt; &#125;, roles: [ &#123; role: "&lt;role&gt;", db: "&lt;database&gt;" &#125; | "&lt;role&gt;", ... ]&#125; 示例12345678use myDatabasedb.createUser(&#123; user:'pingguowei', pwd:'123456', roles:[ 'readWrite' ]&#125;); 数据库认证、安全模式1db.auth('pingguowei','123456') 显示所有用户1show users; 删除用户1db.dropUser('kakaxi'); 修改密码1db.changeUserPassword(&apos;kakaxi&apos;,&apos;654321&apos;); 语块操作1、print1print(&apos;Hello World!&apos;); 2、将一个对象转换成json12tojson(new Object());tojson(new Object(&apos;a&apos;)); 3、循环添加数据123456for (var i = 0; i &lt; 30; i++) &#123; … db.users.save(&#123;name: “u_” + i, age: 22 + i, sex: i % 2&#125;); … &#125;; 这样就循环添加了30条数据，同样也可以省略括号的写法 for (var i = 0; i &lt; 30; i++) db.users.save(&#123;name: “u_” + i, age: 22 + i, sex: i % 2&#125;); 也是可以的，当你用db.users.find()查询的时候，显示多条数据而无法一页显示的情况下，可以用it查看下一页的信息； 4、find 游标查询12345678var cursor = db.users.find();while (cursor.hasNext()) &#123; printjson(cursor.next()); &#125;这样就查询所有的users信息，同样可以这样写var cursor = db.users.find();while (cursor.hasNext()) &#123; printjson(cursor.next); &#125;同样可以省略&#123;&#125;号 5、forEach迭代循环12db.users.find().forEach(printjson); forEach中必须传递一个函数来处理每条迭代的数据信息 6、将find游标当数组处理123456var cursor = db.users.find(); cursor[4]; 取得下标索引为4的那条数据 既然可以当做数组处理，那么就可以获得它的长度：cursor.length();或者cursor.count(); 那样我们也可以用循环显示数据 for (var i = 0, len = c.length(); i &lt; len; i++) printjson(c[i]); 7、将find游标转换成数组123var arr = db.users.find().toArray(); printjson(arr[2]); 用toArray方法将其转换为数组 8、定制我们自己的查询结果只显示age &lt;= 28的并且只显示age这列数据 1234db.users.find(&#123;age: &#123;$lte: 28&#125;&#125;, &#123;age: 1&#125;).forEach(printjson);db.users.find(&#123;age: &#123;$lte: 28&#125;&#125;, &#123;age: true&#125;).forEach(printjson);// 排除age的列db.users.find(&#123;age: &#123;$lte: 28&#125;&#125;, &#123;age: false&#125;).forEach(printjson); 9、forEach传递函数显示信息12db.things.find(&#123;x:4&#125;).forEach(function(x) &#123;print(tojson(x));&#125;); 上面介绍过forEach需要传递一个函数，函数会接受一个参数，就是当前循环的对象，然后在函数体重处理传入的参数信息。]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
        <tag>常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js基础学习16--多进程]]></title>
    <url>%2F2017%2F06%2F11%2FNode-js%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A016-%E5%A4%9A%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>多进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js基础学习15--RESTful API]]></title>
    <url>%2F2017%2F06%2F11%2FNode-js%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A015-RESTful-API%2F</url>
    <content type="text"><![CDATA[RESTful API什么是 REST？REST即表述性状态传递（英文：Representational State Transfer，简称REST）是Roy Fielding博士在2000年他的博士论文中提出来的一种软件架构风格。 表述性状态转移是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是RESTful。需要注意的是，REST是设计风格而不是标准。REST通常基于使用HTTP，URI，和XML（标准通用标记语言下的一个子集）以及HTML（标准通用标记语言下的一个应用）这些现有的广泛流行的协议和标准。REST 通常使用 JSON 数据格式。 HTTP 方法以下为 REST 基本架构的四个方法： GET - 用于获取数据。 PUT - 用于更新或添加数据。 DELETE - 用于删除数据。 POST - 用于添加数据。 RESTful Web ServicesWeb service是一个平台独立的，低耦合的，自包含的、基于可编程的web的应用程序，可使用开放的XML（标准通用标记语言下的一个子集）标准来描述、发布、发现、协调和配置这些应用程序，用于开发分布式的互操作的应用程序。 基于 REST 架构的 Web Services 即是 RESTful。 创建 RESTful首先，创建一个 json 数据资源文件 users.json，内容如下： 1234567891011121314151617181920&#123; "user1": &#123; "name": "mahesh", "password": "password1", "profession": "teacher", "id": 1 &#125;, "user2": &#123; "name": "suresh", "password": "password2", "profession": "librarian", "id": 2 &#125;, "user3": &#123; "name": "ramesh", "password": "password3", "profession": "clerk", "id": 3 &#125;&#125; 基于以上数据，我们创建以下 RESTful API： 序号 URI HTTP 方法 发送内容 结果 1 listUsers GET 空 显示所有用户列表 2 addUser POST JSON 字符串 添加新用户 3 deleteUser DELETE JSON 字符串 删除用户 4 :id GET 空 显示用户详细信息 获取用户列表：以下代码，我们创建了 RESTful API listUsers，用于读取用户的信息列表， server.js 文件代码如下所示： 12345678910111213141516171819var express = require('express');var app = express();var fs = require("fs");app.get('/listUsers', function (req, res) &#123; fs.readFile( "./" + "users.json", 'utf8', function (err, data) &#123; console.log( data ); res.end( data ); &#125;);&#125;)var server = app.listen(8082, function () &#123;var host = server.address().addressvar port = server.address().portconsole.log("应用实例，访问地址为 http://%s:%s", host, port)&#125;) 在浏览器中访问 http://127.0.0.1:8082/listUsers，结果如下所示： 添加用户以下代码，我们创建了 RESTful API addUser， 用于添加新的用户数据，server.js 文件代码如下所示： 123456789101112131415161718192021222324252627282930var express = require('express');var app = express();var fs = require("fs");//添加的新用户数据var user = &#123; "user4" : &#123; "name" : "mohit", "password" : "password4", "profession" : "teacher", "id": 4 &#125;&#125;app.get('/addUser', function (req, res) &#123; // 读取已存在的数据 fs.readFile('./' + 'users.json', 'utf8', function (err, data) &#123; data = JSON.parse( data ); data["user4"] = user["user4"]; console.log( data ); res.end( JSON.stringify(data)); &#125;);&#125;)var server = app.listen(8082, function () &#123; var host = server.address().address var port = server.address().port console.log("应用实例，访问地址为 http://%s:%s", host, port)&#125;) 在浏览器中访问 http://127.0.0.1:8082/addUsers，结果如下所示： 显示用户详情以下代码，我们创建了 RESTful API :id（用户id）， 用于读取指定用户的详细信息，server.js 文件代码如下所示： 123456789101112131415161718192021var express = require('express');var app = express();var fs = require("fs");app.get('/:id', function (req, res) &#123; // 首先我们读取已存在的用户 fs.readFile( "./" + "users.json", 'utf8', function (err, data) &#123; data = JSON.parse( data ); var user = data["user" + req.params.id] console.log( user ); res.end( JSON.stringify(user)); &#125;);&#125;)var server = app.listen(8082, function () &#123; var host = server.address().address var port = server.address().port console.log("应用实例，访问地址为 http://%s:%s", host, port)&#125;) 在浏览器中访问http://127.0.0.1:8082/3，结果如下所示： 删除用户以下代码，我们创建了 RESTful API deleteUser， 用于删除指定用户的详细信息，以下实例中，用户 id 为 2，server.js 文件代码如下所示： 12345678910111213141516171819202122232425var express = require('express');var app = express();var fs = require("fs");var id = 2;app.get('/deleteUser', function (req, res) &#123; // 首次读取存在的用户. fs.readFile( "./" + "users.json", 'utf8', function (err, data) &#123; data = JSON.parse( data ); delete data["user" + 2]; console.log( data ); res.end( JSON.stringify(data)); &#125;);&#125;)var server = app.listen(8082, function () &#123; var host = server.address().address var port = server.address().port console.log("应用实例，访问地址为 http://%s:%s", host, port)&#125;) 在浏览器中访问http://127.0.0.1:8082/deleteUser，结果如下所示：]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>RESTful API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js基础学习14--Express 框架]]></title>
    <url>%2F2017%2F06%2F07%2FNode-js%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A014-Express-%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Express 简介Express 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。 使用 Express 可以快速地搭建一个完整功能的网站。 Express 框架核心特性： 可以设置中间件来响应 HTTP 请求。 定义了路由表用于执行不同的 HTTP 请求动作。 可以通过向模板传递参数来动态渲染 HTML 页面。 安装 Express1$ npm install express --save 以上命令会将 Express 框架安装在当前目录的 node_modules 目录中， node_modules 目录下会自动创建 express 目录。以下几个重要的模块是需要与 express 框架一起安装的： body-parser - node.js 中间件，用于处理 JSON, Raw, Text 和 URL 编码的数据。 cookie-parser - 这就是一个解析Cookie的工具。通过req.cookies可以取到传过来的cookie，并把它们转成对象。 multer - node.js 中间件，用于处理 enctype=”multipart/form-data”（设置表单的MIME编码）的表单数据。 (注意：配置NODE_PATH:F:\nodejs\node_modules环境变量) 第一个 Express 框架实例1234567891011121314//express_demo.js 文件var express = require('express');var app = express(); app.get('/', function (req, res) &#123; res.send('Hello World');&#125;) var server = app.listen(8081, function () &#123; var host = server.address().address var port = server.address().port console.log("应用实例，访问地址为 http://%s:%s", host, port)&#125;) 执行以上代码： 请求和响应Express 应用使用回调函数的参数： request 和 response 对象来处理请求和响应的数据。 123app.get('/',function(req,res)&#123; // --&#125;) request 和 response 对象的具体介绍： Request 对象 - request 对象表示 HTTP 请求，包含了请求查询字符串，参数，内容，HTTP 头部等属性。常见属性有： req.app：当callback为外部文件时，用req.app访问express的实例 req.baseUrl：获取路由当前安装的URL路径 req.body / req.cookies：获得「请求主体」/ Cookies req.fresh / req.stale：判断请求是否还「新鲜」 req.hostname / req.ip：获取主机名和IP地址 req.originalUrl：获取原始请求URL req.params：获取路由的parameters req.path：获取请求路径 req.protocol：获取协议类型 req.query：获取URL的查询参数串 req.route：获取当前匹配的路由 req.subdomains：获取子域名 req.accepts()：检查可接受的请求的文档类型 req.acceptsCharsets / req.acceptsEncodings / req.acceptsLanguages：返回指定字符集的第一个可接受字符编码 req.get()：获取指定的HTTP请求头 req.is()：判断请求头Content-Type的MIME类型 Response 对象 - response 对象表示 HTTP 响应，即在接收到请求时向客户端发送的 HTTP 响应数据。常见属性有： res.app：同req.app一样 res.append()：追加指定HTTP头 res.set()在res.append()后将重置之前设置的头 res.cookie(name，value [，option])：设置Cookie opition: domain / expires / httpOnly / maxAge / path / secure / signed res.clearCookie()：清除Cookie res.download()：传送指定路径的文件 res.get()：返回指定的HTTP头 res.json()：传送JSON响应 res.jsonp()：传送JSONP响应 res.location()：只设置响应的Location HTTP头，不设置状态码或者close response res.redirect()：设置响应的Location HTTP头，并且设置状态码302 res.send()：传送HTTP响应 res.sendFile(path [，options][，fn])：传送指定路径的文件 -会自动根据文件extension设定Content-Type res.set()：设置HTTP头，传入object可以一次设置多个头 res.status()：设置HTTP状态码 res.type()：设置Content-Type的MIME类型 路由在HTTP请求中，我们可以通过路由提取出请求的URL以及GET/POST参数。 接下来我们扩展 Hello World，添加一些功能来处理更多类型的 HTTP 请求 123456789101112131415161718192021222324252627282930313233343536373839var express=require('express');var app=express();// 主页输出 "Hello World"app.get('/',function(req,res)&#123; console.log('主页 GET 请求'); res.send('Hello GET');&#125;)// POST 请求app.post('/',function(req,res)&#123; console.log('主页 POST 请求'); res.send('Hello POST');&#125;)// /del_user 页面响应app.get('/del_user',function(req,res)&#123; console.log('/del_user 响应 DELETE 请求'); res.send('删除页面');&#125;)// /list_user 页面响应app.get('/list_user',function(req,res)&#123; console.log('/list_user Get 请求'); res.send('用户列表页面');&#125;)// 对页面 abcd, abxcd, ab123cd, 等响应 GET 请求app.get('/ab*cd',function(req,res)&#123; console.log('/ab*cd GET 请求'); res.send('正则匹配');&#125;)var server=app.listen(8081,function()&#123; var host=server.address().address; var port=server.address().port; console.log('应用实例，访问地址为 http://%s:%s',host,port);&#125;) 静态文件Express 提供了内置的中间件express.static 来设置静态文件如：图片， CSS, JavaScript 等。 你可以使用express.static 中间件来设置静态文件路径。例如，如果你将图片， CSS, JavaScript 文件放在 public 目录下，你可以这么写： 1app.use(express.static('public')); 我们可以到 public/images 目录下放些图片,1.jpg、2.jpg 创建 express_demo3.js 文件，代码如下所示： 123456789101112131415var express=require('express');var app=express();app.use(express.static('public'));app.get('/',function(req,res)&#123; res.send('Hello World');&#125;)var server=app.listen(8081,function()&#123; var host=server.address().address; var port=server.address().port; console.log('应用程序，访问地址为 http://%s:%s',host,port);&#125;) 执行以上代码： 在浏览器中访问 http://127.0.0.1:8081/images/1.jpg，结果如下图所示： GET 方法以下实例演示了在表单中通过 GET 方法提交两个参数，我们可以使用 server.js 文件内的 process_get 路由器来处理输入： 1234567891011 index.htm 文件代码：&lt;html&gt;&lt;body&gt;&lt;form action="http://127.0.0.1:8081/process_get" method="GET"&gt;First Name: &lt;input type="text" name="first_name"&gt; &lt;br&gt; Last Name: &lt;input type="text" name="last_name"&gt;&lt;input type="submit" value="Submit"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; server.js文件代码： 12345678910111213141516171819202122232425262728var express = require('express');var app = express(); app.use(express.static('public')); app.get('/index.html', function (req, res) &#123; res.sendFile( __dirname + "/" + "index.html" );&#125;) app.get('/process_get', function (req, res) &#123; // 输出 JSON 格式 var response = &#123; "first_name":req.query.first_name, "last_name":req.query.last_name &#125;; console.log(response); res.end(JSON.stringify(response));&#125;) var server = app.listen(8081, function () &#123; var host = server.address().address var port = server.address().port console.log("应用实例，访问地址为 http://%s:%s", host, port) &#125;) 执行以上代码,浏览器访问 http://127.0.0.1:8081/index.htm，如图所示： POST 方法以下实例演示了在表单中通过 POST 方法提交两个参数，我们可以使用 server.js 文件内的 process_post 路由器来处理输入： 1234567891011index.htm 文件代码：&lt;html&gt;&lt;body&gt;&lt;form action="http://127.0.0.1:8081/process_post" method="POST"&gt;First Name: &lt;input type="text" name="first_name"&gt; &lt;br&gt; Last Name: &lt;input type="text" name="last_name"&gt;&lt;input type="submit" value="Submit"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233// server.js 文件代码：var express = require('express');var app = express();var bodyParser = require('body-parser'); // 创建 application/x-www-form-urlencoded 编码解析var urlencodedParser = bodyParser.urlencoded(&#123; extended: false &#125;) app.use(express.static('public')); app.get('/index.html', function (req, res) &#123; res.sendFile( "./" + "index.html" );&#125;) app.post('/process_post', urlencodedParser, function (req, res) &#123; // 输出 JSON 格式 var response = &#123; "first_name":req.body.first_name, "last_name":req.body.last_name &#125;; console.log(response); res.end(JSON.stringify(response));&#125;) var server = app.listen(8082, function () &#123; var host = server.address().address var port = server.address().port console.log("应用实例，访问地址为 http://%s:%s", host, port) &#125;) 浏览器访问 http://127.0.0.1:8082/index.html 文件上传以下我们创建一个用于上传文件的表单，使用 POST 方法，表单 enctype 属性设置为 multipart/form-data。 Cookie 管理我们可以使用中间件向 Node.js 服务器发送 cookie 信息，以下代码输出了客户端发送的 cookie 信息： 123456789101112// express_cookie.js 文件var express = require('express');var cookieParser = require('cookie-parser'); var app = express();app.use(cookieParser()); app.get('/', function(req, res) &#123; console.log("Cookies: ", req.cookies)&#125;); app.listen(8082); 执行以上代码： 123456789101112// express_cookie.js 文件var express = require('express');var cookieParser = require('cookie-parser'); var app = express();app.use(cookieParser()); app.get('/', function(req, res) &#123; console.log("Cookies: ", req.cookies)&#125;); app.listen(8082);]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Express 框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript整理之正则表达式]]></title>
    <url>%2F2017%2F06%2F07%2Fjavascript%E6%95%B4%E7%90%86%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[JS常用正则表达式检查输入的Email信箱格式是否正确123456789101112131415/* 用途：检查输入的Email信箱格式是否正确 输入：strEmail：字符串 返回：如果通过验证返回true,否则返回false */function checkEmail(strEmail) &#123; var emailReg = /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/; if ( emailReg.test(strEmail) ) &#123; return true; &#125; else &#123; alert("您输入的Email地址格式不正确！"); return false; &#125;&#125;; 校验ip地址的格式12345678910111213141516171819202122/*用途：校验ip地址的格式 输入：strIP：ip地址 返回：如果通过验证返回true,否则返回false； */function isIP(strIP) &#123; if (isNull(strIP)) &#123; return false; &#125; var re = /^(\d+)\.(\d+)\.(\d+)\.(\d+)$/g; // 匹配IP地址的正则表达式 if (re.test(strIP)) &#123; if ( RegExp.$1 &lt; 256 &amp;&amp; RegExp.$2 &lt; 256 &amp;&amp; RegExp.$3 &lt; 256 &amp;&amp; RegExp.$4 &lt; 256)&#123; return true; &#125; &#125; return false;&#125;;// 为空判断函数function isNull(arg1)&#123; return !arg1 &amp;&amp; arg1!==0 &amp;&amp; typeof arg1!=="boolean"?true:false;&#125; 检查输入手机号码是否正确123456789101112131415/* 用途：检查输入手机号码是否正确 输入：strMobile：字符串 返回：如果通过验证返回true,否则返回false */function checkMobile(strMobile)&#123; var regu = /^[1][3][0-9]&#123;9&#125;$/; var re = new RegExp(regu); if (re.test(strMobile)) &#123; return true; &#125; else &#123; return false; &#125;&#125;; 检查输入的电话号码格式是否正确12345678910111213141516171819202122232425262728/* 用途：检查输入的电话号码格式是否正确 输入：strPhone：字符串 返回：如果通过验证返回true,否则返回false */function checkPhone( strPhone ) &#123; var phoneRegWithArea = /^[0][1-9]&#123;2,3&#125;-[0-9]&#123;5,10&#125;$/; var phoneRegNoArea = /^[1-9]&#123;1&#125;[0-9]&#123;5,8&#125;$/; var prompt = "您输入的电话号码不正确!"; if ( strPhone.length &gt; 9 ) &#123; if ( phoneRegWithArea.test(strPhone) ) &#123; return true; &#125; else &#123; alert( prompt ); return false; &#125; &#125; else &#123; if ( phoneRegNoArea.test( strPhone ) ) &#123; return true; &#125; else &#123; alert( prompt ); return false; &#125; &#125;&#125;; 检查输入字符串是否为空或者全部都是空格12345678910111213/* 用途：检查输入字符串是否为空或者全部都是空格 输入：str 返回：如果全是空返回true,否则返回false */function isNull( str )&#123; if ( str == "" ) &#123; return true; &#125; var regu = "^[ ]+$"; var re = new RegExp(regu); return re.test(str);&#125;; 检查输入对象的值是否符合整数格式 、是否符合正整数格式 、是否是带小数的数字格式,可以是负数12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* 用途：检查输入对象的值是否符合整数格式 输入：str 输入的字符串 返回：如果通过验证返回true,否则返回false */function isInteger( str )&#123; var regu = /^[-]&#123;0,1&#125;[0-9]&#123;1,&#125;$/; return regu.test(str);&#125;;/* 用途：检查输入字符串是否符合正整数格式 输入：s：字符串 返回：如果通过验证返回true,否则返回false */function isNumber( s )&#123; var regu = "^[0-9]+$"; var re = new RegExp(regu); if (s.search(re) != - 1) &#123; return true; &#125; else &#123; return false; &#125;&#125;;/* 用途：检查输入字符串是否是带小数的数字格式,可以是负数 输入：str：字符串 返回：如果通过验证返回true,否则返回false */function isDecimal( str )&#123; if (isInteger(str)) &#123; return true; &#125; var re = /^[-]&#123;0,1&#125;(\d+)[\.]+(\d+)$/; if (re.test(str)) &#123; if (RegExp.$1 == 0 &amp;&amp; RegExp.$2 == 0) &#123; return false; &#125; return true; &#125; else &#123; return false; &#125;&#125;; 检查输入对象的值是否符合端口号格式12345678910111213/* 用途：检查输入对象的值是否符合端口号格式 输入：str 输入的字符串 返回：如果通过验证返回true,否则返回false */function isPort( str )&#123; return (isNumber(str) &amp;&amp; str &lt; 65536);&#125;;// 判断一个对象是否为数字function isNumber(obj) &#123; return typeof obj === 'number' &amp;&amp; !isNaN(obj) &#125; 检查输入字符串是否符合金额格式,格式定义为带小数的正数，小数点后最多三位123456789101112131415/* 用途：检查输入字符串是否符合金额格式,格式定义为带小数的正数，小数点后最多三位 输入：s：字符串 返回：如果通过验证返回true,否则返回false */function isMoney( s )&#123; var regu = "^[0-9]+[\.][0-9]&#123;0,3&#125;$"; var re = new RegExp(regu); if (re.test(s)) &#123; return true; &#125; else &#123; return false; &#125;&#125;; 检查输入字符串是否只由英文字母和数字和下划线组成12345678910111213141516/* 用途：检查输入字符串是否只由英文字母和数字和下划线组成 输入：s：字符串 返回：如果通过验证返回true,否则返回false */function isNumberOr_Letter( s )&#123; //判断是否是数字或字母 var regu = "^[0-9a-zA-Z\_]+$"; var re = new RegExp(regu); if (re.test(s)) &#123; return true; &#125; else &#123; return false; &#125;&#125;; 检查输入字符串是否只由英文字母和数字和下划线组成12345678910111213141516/* 用途：检查输入字符串是否只由英文字母和数字和下划线组成 输入：s：字符串 返回：如果通过验证返回true,否则返回false */function isNumberOr_Letter( s )&#123; //判断是否是数字或字母 var regu = "^[0-9a-zA-Z\_]+$"; var re = new RegExp(regu); if (re.test(s)) &#123; return true; &#125; else &#123; return false; &#125;&#125;; 检查输入字符串是否只由汉字、字母、数字组成12345678910111213141516/* 用途：检查输入字符串是否只由汉字、字母、数字组成 输入：s：字符串 返回：如果通过验证返回true,否则返回false */function isChinaOrNumbOrLett( s )&#123; //判断是否是汉字、字母、数字组成 var regu = "^[0-9a-zA-Z\u4e00-\u9fa5]+$"; var re = new RegExp(regu); if (re.test(s)) &#123; return true; &#125; else &#123; return false; &#125;&#125;; 字符1是否以字符串2结束 、字符1是否以字符串2开始 、字符1是包含字符串21234567891011121314151617181920212223242526272829303132333435363738/* 用途：字符1是否以字符串2结束 输入：str1：字符串；str2：被包含的字符串 返回：如果通过验证返回true,否则返回false */function isLastMatch(str1, str2) &#123; var index = str1.lastIndexOf(str2); if (str1.length == index + str2.length) &#123; return true; &#125; return false;&#125;;/* 用途：字符1是否以字符串2开始 输入：str1：字符串；str2：被包含的字符串 返回：如果通过验证返回true,否则返回false */function isFirstMatch(str1, str2) &#123; var index = str1.indexOf(str2); if (index == 0) &#123; return true; &#125; return false;&#125;;/* 用途：字符1是包含字符串2 输入：str1：字符串；str2：被包含的字符串 返回：如果通过验证返回true,否则返回false */function isMatch(str1, str2) &#123; var index = str1.indexOf(str2); if (index ==- 1) &#123; return false; &#125; return true;&#125;;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript整理之Linq to js使用小结]]></title>
    <url>%2F2017%2F06%2F07%2Fjavascript%E6%95%B4%E7%90%86%E4%B9%8BLinq-to-js%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[什么是Linq to jsC# 3.0推出了.Net独有的新特性：Linq。自从有了Linq，程序员再也不用担心对集合的操作了。同理，Linq to js 当然也就是对前端集合变量进行操作的一种技术框架。 怎么使用因为是前端框架，所以你懂得，只需要引用一个js文件即可。这里还是附上官网地址：http://jslinq.codeplex.com/.这上面有文件和Demo，可以上去看看。使用方式主要有两种：使用方法一、直接引用js文件；使用方法二、使用Nuget Package 安装Linq to js。在PM安装控制台中输入Install-Package jslinq。注意：这里使用目前最新的v2.2.0.2版本进行开发整理。 本篇以Linq to js的lamada表达式写法的方式来以此介绍常用方法。 条件查询：Where123456789var myList = [ &#123; Name: "Jim", Age: 20 &#125;, &#123; Name: "Kate", Age: 21 &#125;, &#123; Name: "Lilei", Age: 18 &#125;, &#123; Name: "John", Age: 14 &#125;, &#123; Name: "LinTao", Age: 25 &#125;];var arrRes = Enumerable.From(myList).Where("x=&gt;x.Name=='Jim'").ToArray();// arrRes的结果为 [&#123;"Name":"Jim","Age":20&#125;] 条件选择：Select123456789var myList = [ &#123; Name: "Jim", Age: 20 &#125;, &#123; Name: "Kate", Age: 21 &#125;, &#123; Name: "Lilei", Age: 18 &#125;, &#123; Name: "John", Age: 14 &#125;, &#123; Name: "LinTao", Age: 25 &#125;];var arrRes = Enumerable.From(myList).Select('x=&gt;x.Age*10').ToArray();// arrRes得到结果 [200,210,180,140,250] 排序：OrderBy、123456789var myList = [ &#123; Name: "Jim", Age: 20 &#125;, &#123; Name: "Kate", Age: 21 &#125;, &#123; Name: "Lilei", Age: 18 &#125;, &#123; Name: "John", Age: 14 &#125;, &#123; Name: "LinTao", Age: 25 &#125;];var arrRes = Enumerable.From(myList).OrderBy('x=&gt;x.Age').ToArray(); // 降序OrderByDescending()// arrRes得到的结果是myList按照Age排序升序。 去重：Distinct123456789var myList = [ &#123; Name: "Jim", Age: 20 &#125;, &#123; Name: "Kate", Age: 20 &#125;, &#123; Name: "Lilei", Age: 20 &#125;, &#123; Name: "John", Age: 14 &#125;, &#123; Name: "LinTao", Age: 25 &#125;];var arrRes = Enumerable.From(myList).Distinct('x=&gt;x.Age').ToArray();// 得到的结果集合的数量为3个：[ &#123; Name: "Jim", Age: 20 &#125;, &#123; Name: "John", Age: 14 &#125;, &#123; Name: "LinTao", Age: 25 &#125;]。 遍历：ForEach1234567891011var myList = [ &#123; Name: "Jim", Age: 20 &#125;, &#123; Name: "Kate", Age: 20 &#125;, &#123; Name: "Lilei", Age: 20 &#125;, &#123; Name: "John", Age: 14 &#125;, &#123; Name: "LinTao", Age: 25 &#125;];var arrRes = Enumerable.From(myList).ForEach(function(value,index)&#123; console.log('值='+value+',索引='+index);&#125;);// 很显然两个参数：一个是值，另一个是当前索引 取唯一对象：First、FirstOrDefault、Last、LastOrDefault、Single、SingleOrDefault123456789var myList = [ &#123; Name: "Jim", Age: 20 &#125;, &#123; Name: "Kate", Age: 20 &#125;, &#123; Name: "Lilei", Age: 20 &#125;, &#123; Name: "John", Age: 14 &#125;, &#123; Name: "LinTao", Age: 25 &#125;];var arrRes = Enumerable.From(myList).FirstOrDefault('x=&gt;x.Age&gt;18');// 其他几个用法和这个类似。这个没什么好说的。 Skip、Take12var arrRes = Enumerable.Range(1,10).Skip(5).ToArray(); // 结果[6,7,8,9,10]var arrRes = Enumerable.Range(1,10).Take(5).ToArray(); // 结果[1, 2, 3, 4, 5] 取差集、取交集、合并：Except、Intersect、Union12345var array1=[1,23,4,56,76,8];var array2=[23,54,22,76,97];// array1 与 array2的差集var arrRes= Enumerable.From(array1).Except(array2).ToArray();// [1, 4, 56, 8] 12345var array1=[1,23,4,56,76,8];var array2=[23,54,22,76,97];// array1 与 array2的交集var arrRes= Enumerable.From(array1).Intersect(array2).ToArray();// [23, 76] 12345var array1=[1,23,4,56,76,8];var array2=[23,54,22,76,97];// array1 与 array2的合并var arrRes= Enumerable.From(array1).Union(array2).ToArray();// [1, 23, 4, 56, 76, 8, 54, 22, 97]]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>linq to js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js基础学习13--Web 模块]]></title>
    <url>%2F2017%2F06%2F04%2FNode-js%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A013-Web-%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[使用 Node 创建 Web 服务器Node.js 提供了 http 模块，http 模块主要用于搭建 HTTP 服务端和客户端，使用 HTTP 服务器或客户端功能必须调用 http 模块，代码如下： 1var http=require('http'); 以下是演示一个最基本的 HTTP 服务器架构(使用8081端口)，创建 server.js 文件，代码如下所示： 12345678910111213141516171819202122232425262728293031323334var http=require('http');var fs=require('fs');var url=require('url');// 创建服务器http.createServer(function(request,response)&#123; // 解析请求，包括文件名 var pathname=url.parse(request.url).pathname; // 输出请求的文件名 console.log('Request for '+pathname+' received. '); // 从文件系统中读取请求的文件内容 fs.readFile(pathname.substr(1),function(err,data)&#123; if(err)&#123; console.log(err); // HTTP 状态码：404：NOT FOUND // Content Type:text/plain response.writeHead(404,&#123;'Content-Type':'text/html'&#125;); &#125;else&#123; // HTTP 状态码：200：OK // Content Type:text/plain response.writeHead(200,&#123;'Content-Type':'text/html'&#125;); // 响应文件内容 response.write(data.toString()); &#125; // 发送响应数据 response.end(); &#125;);&#125;).listen(8081);// 控制台会输出以下信息console.log('Server running at http://127.0.0.1:8081/'); 接下来我们在该目录下创建一个 index.htm 文件，代码如下： 12345678&lt;html&gt;&lt;head&gt;&lt;title&gt;Sample Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello World!&lt;/body&gt;&lt;/html&gt; 执行 server.js 文件： 接着我们在浏览器中打开地址：http://127.0.0.1:8081/index.html，显示如下图所示:： 使用 Node 创建 Web 客户端Node 创建 Web 客户端需要引入 http 模块，创建 client.js 文件，代码如下所示： 1234567891011121314151617181920212223242526var http=require('http');// 用于请求的选项var options=&#123; host:'localhost', port:'8081', path:'/index.html'&#125;;// 处理响应的回调函数var callback=function(response)&#123; // 不断更新数据 var body=''; response.on('data',function(data)&#123; body+=data; &#125;); response.on('end',function()&#123; // 数据接收完毕 console.log(body); &#125;);&#125;// 向服务端发送请求var req=http.request(options,callback);req.end(); 新开一个终端，执行 client.js 文件，输出结果如下： 执行 server.js 的控制台输出信息如下：]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Web 模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js基础学习12--GET/POST请求]]></title>
    <url>%2F2017%2F06%2F04%2FNode-js%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A012-GET-POST%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[Node.js GET/POST请求在很多场景中，我们的服务器都需要跟用户的浏览器打交道，如表单提交。 表单提交到服务器一般都使用 GET/POST 请求。 获取GET请求内容由于GET请求直接被嵌入在路径中，URL是完整的请求路径，包括了?后面的部分，因此你可以手动解析后面的内容作为GET请求的参数。 node.js 中 url 模块中的 parse 函数提供了这个功能。 实例 12345678var http=require('http');var url=require('url');var util=require('util');http.createServer(function(req,res)&#123; res.writeHead(200,&#123;'Content-Type':'text/plain;charset=utf-8'&#125;); res.end(util.inspect(url.parse(req.url,true)));&#125;).listen(3000); 在浏览器中访问http://127.0.0.1:3000/user?name=%27kakaxi%27&amp;pwd=%27dw1314520%27 获取 URL 的参数我们可以使用 url.parse 方法来解析 URL 中的参数，代码如下： 1234567891011121314var http=require('http');var url=require('url');var util=require('util');http.createServer(function(req,res)&#123; res.writeHead(200,&#123;'Content-Type':'text/plain;charset=utf-8'&#125;); // 解析 url 参数 var params=url.parse(req.url,true).query; res.write('名称：'+params.name); res.write('\n'); res.write('密码:'+params.pwd); res.end();&#125;).listen(3000); 在浏览器中访问http://127.0.0.1:3000/user?name=%27kakaxi%27&amp;pwd=%27dw520%27 获取 POST 请求内容POST 请求的内容全部的都在请求体中，http.ServerRequest 并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作。 比如上传文件，而很多时候我们可能并不需要理会请求体的内容，恶意的POST请求会大大消耗服务器的资源，所有node.js 默认是不会解析请求体的，当你需要的时候，需要手动来做。 基本语法结构说明 123456789101112131415161718var http=require('http');var querystring=require('querystring');http.createServer(function(req,res)&#123; // 定义了一个post变量，用于暂存请求体的信息 var post=''; // 通过req的data事件监听函数，每当接收到请求体的数据，就累加到post变量中 req.on('data',function(chunk)&#123; post+=chunk; &#125;); // 在end事件触发后，通过 querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。 req.on('end',function()&#123; post=querystring.parse(post); res.end(util.inspect(post)); &#125;);&#125;).listen(3000); 以下实例表单通过 POST 提交并输出数据： 12345678910111213141516171819202122232425262728293031323334var http = require('http');var querystring = require('querystring'); var postHTML = '&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;菜鸟教程 Node.js 实例&lt;/title&gt;&lt;/head&gt;' + '&lt;body&gt;' + '&lt;form method="post"&gt;' + '网站名： &lt;input name="name"&gt;&lt;br&gt;' + '网站 URL： &lt;input name="url"&gt;&lt;br&gt;' + '&lt;input type="submit"&gt;' + '&lt;/form&gt;' + '&lt;/body&gt;&lt;/html&gt;'; http.createServer(function (req, res) &#123; var body = ""; req.on('data', function (chunk) &#123; body += chunk; &#125;); req.on('end', function () &#123; // 解析参数 body = querystring.parse(body); // 设置响应头部信息及编码 res.writeHead(200, &#123;'Content-Type': 'text/html; charset=utf8'&#125;); if(body.name &amp;&amp; body.url) &#123; // 输出提交的数据 res.write("网站名：" + body.name); res.write("&lt;br&gt;"); res.write("网站 URL：" + body.url); &#125; else &#123; // 输出表单 res.write(postHTML); &#125; res.end(); &#125;);&#125;).listen(3000); 运行结果：]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>GET/POST请求</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js基础学习11--文件系统]]></title>
    <url>%2F2017%2F06%2F04%2FNode-js%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A011-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[Node.js 文件系统Node.js 提供一组类似 UNIX（POSIX）标准的文件操作API。 Node 导入文件系统模块(fs)语法如下所示： 1var fs=require('fs') 异步和同步Node.js 文件系统（fs 模块）模块中的方法均有异步和同步版本，例如读取文件内容的函数有异步的 fs.readFile() 和同步的 fs.readFileSync()。 异步的方法函数最后一个参数为回调函数，回调函数的第一个参数包含了错误信息(error)。 建议大家是用异步方法，比起同步，异步方法性能更高，速度更快，而且没有阻塞。 实例创建 file.js 文件, 代码如下： 1234567891011121314var fs=require('fs');// 异步读取fs.readFile('input.txt',function(err,data)&#123; if(err)&#123; return console.error(err); &#125; console.log('异步读取：'+data.toString());&#125;);// 同步函数var data=fs.readFileSync('input.txt');console.log('同步读取：'+data.toString());console.log('程序执行完毕。'); 运行结果如下： 接下来，让我们来具体了解下 Node.js 文件系统的方法。 打开文件语法以下为在异步模式下打开文件的语法格式： 1fs.open(path,flags[,mode],callback); 参数参数使用说明如下： path - 文件的路径。 flags - 文件打开的行为。具体值详见下文。 mode - 设置文件模式(权限)，文件创建默认权限为 0666(可读，可写)。 callback - 回调函数，带有两个参数如：callback(err, fd)。 flags 参数可以是以下值： Flag 描述 r 以读取模式打开文件。如果文件不存在抛出异常。 r+ 以读写模式打开文件。如果文件不存在抛出异常。 rs 以同步的方式读取文件。 rs+ 以同步的方式读取和写入文件。 w 以写入模式打开文件，如果文件不存在则创建。 wx 类似 ‘w’，但是如果文件路径存在，则文件写入失败。 w+ 以读写模式打开文件，如果文件不存在则创建。 wx+ 类似 ‘w+’， 但是如果文件路径存在，则文件读写失败。 a 以追加模式打开文件，如果文件不存在则创建。 ax 类似 ‘a’， 但是如果文件路径存在，则文件追加失败。 a+ 以读取追加模式打开文件，如果文件不存在则创建。 ax+ 类似 ‘a+’， 但是如果文件路径存在，则文件读取追加失败。 实例12345678910var fs=require('fs');// 异步打开文件console.log('准备打开文件！');fs.open('input.txt','r+',function(err,fd)&#123; if(err)&#123; return console.err(err); &#125; console.log('文件打开成功');&#125;); 运行结果： 获取文件信息语法以下为通过异步模式获取文件信息的语法格式： 1fs.stat(path,callback) 参数参数使用说明如下： path - 文件路径。 callback - 回调函数，带有两个参数如：(err, stats), stats 是 fs.Stats 对象。 fs.stat(path)执行后，会将stats类的实例返回给其回调函数。可以通过stats类中的提供方法判断文件的相关属性。例如判断是否为文件： 12345var fs=require('fs');fs.stat('input.txt',function(err,stats)&#123; console.log(stats.isFile()); // true&#125;); stats类中的方法有： 方法 描述 stats.isFile() 如果是文件返回 true，否则返回 false。 stats.isDirectory() 如果是目录返回 true，否则返回 false。 stats.isBlockDevice() 如果是块设备返回 true，否则返回 false。 stats.isCharacterDevice() 如果是字符设备返回 true，否则返回 false。 stats.isSymbolicLink() 如果是软链接返回 true，否则返回 false。 stats.isFIFO() 如果是FIFO，返回true，否则返回 false。FIFO是UNIX中的一种特殊类型的命令管道。 stats.isSocket() 如果是 Socket 返回 true，否则返回 false。 写入文件语法以下为异步模式下写入文件的语法格式： 1fs.writeFile(file,data[,options],callback) 参数参数使用说明如下： file - 文件名或文件描述符。 data - 要写入文件的数据，可以是 String(字符串) 或 Buffer(流) 对象。 options - 该参数是一个对象，包含 {encoding, mode, flag}。默认编码为 utf8, 模式为 0666 ， flag 为 ‘w’ callback - 回调函数，回调函数只包含错误信息参数(err)，在写入失败时返回。 实例创建 file.js 文件，代码如下所示： 1234567891011121314151617var fs=require('fs');console.log('准备写入文件');fs.writeFile('myTxt.txt','我是通过写入的文件内容！',function(err)&#123; if(err)&#123; return console.log(err); &#125; console.log('数据写入成功！'); console.log('------------分割线-------------'); console.log('读取写入的数据！'); fs.readFile('myTxt.txt',function(err,data)&#123; if(err)&#123; return console.error(err); &#125; console.log('异步读取文件数据：'+data.toString()); &#125;);&#125;); 运行结果如下： 读取文件语法以下为异步模式下读取文件的语法格式： 1fs.read(fd,buffer,offset,length,position,callback) 该方法使用了文件描述符来读取文件。 参数参数使用说明如下： fd - 通过 fs.open() 方法返回的文件描述符。 buffer - 数据写入的缓冲区。 offset - 缓冲区写入的写入偏移量。 length - 要从文件中读取的字节数。 position - 文件读取的起始位置，如果 position 的值为 null，则会从当前文件指针的位置读取。 callback - 回调函数，有三个参数err, bytesRead, buffer，err 为错误信息， bytesRead 表示读取的字节数，buffer 为缓冲区对象。 实例12345678910111213141516171819202122var fs=require('fs');var buf=new Buffer(1024);console.log('准备打开已存在的文件！');fs.open('input.txt','r+',function(err,fd)&#123; if(err)&#123; return console.error(err); &#125; console.log('文件打开开成功！'); console.log('准备读取文件！'); fs.read(fd,buf,0,buf.length,0,function(err,bytes)&#123; if(err)&#123; console.log(err); &#125; console.log(bytes+' 字节被读取'); // 仅输出读取的字节 if(bytes&gt;0)&#123; console.log(buf.slice(0,bytes).toString()); &#125; &#125;);&#125;); 运行结果： 关闭文件语法以下为异步模式下关闭文件的语法格式： 1fs.close(fd,callback) 该方法使用了文件描述符来读取文件。 参数参数使用说明如下： fd - 通过 fs.open() 方法返回的文件描述符。 callback - 回调函数，没有参数。 实例123456789101112131415161718192021222324252627282930var fs=require('fs');var buf=new Buffer(1024);console.log('准备打开文件！');fs.open('input.txt','r+',function(err,fd)&#123; if(err)&#123; return console.error(err); &#125; console.log('文件打开开成功！'); console.log('准备读取文件！'); fs.read(fd,buf,0,buf.length,0,function(err,bytes)&#123; if(err)&#123; console.log(err); &#125; console.log(bytes+' 字节被读取'); // 仅输出读取的字节 if(bytes&gt;0)&#123; console.log(buf.slice(0,bytes).toString()); &#125; // 关闭文件 fs.close(fd,function(err)&#123; if(err)&#123; console.log(err); &#125; console.log('文件关闭成功'); &#125;); &#125;);&#125;); 运行结果如下： 截取文件语法以下为异步模式下截取文件的语法格式： 1fs.ftruncate(fd,len,callback) 该方法使用了文件描述符来读取文件。 参数参数使用说明如下： fd - 通过 fs.open() 方法返回的文件描述符。 len - 文件内容截取的长度。 callback - 回调函数，没有参数。 实例1234567891011121314151617181920212223242526272829303132333435363738var fs=require('fs');var buf=new Buffer(1024);console.log('准备打开文件！');fs.open('input.txt','r+',function(err,fd)&#123; if(err)&#123; return console.error(err); &#125; console.log('文件打开成功！'); console.log('截取20字节后的文件内容。'); // 截取文件 fs.ftruncate(fd,20,function(err)&#123; if(err)&#123; console.log(err); &#125; console.log('文件截取成功。'); console.log('读取相同的文件'); fs.read(fd,buf,0,buf.length,0,function(err,bytes)&#123; if(err)&#123; console.log(err); &#125; // 仅输出读取的字节 if(bytes&gt;0)&#123; console.log(buf.slice(0,bytes).toString()); &#125; // 关闭文件 fs.close(fd,function(err)&#123; if(err)&#123; console.log(err); &#125; console.log('文件关闭成功!'); &#125;); &#125;); &#125;);&#125;); 运行结果如下： 删除文件语法以下为删除文件的语法格式： 1fs.unlink(path,callback) 参数参数使用说明如下： path - 文件路径。 callback - 回调函数，没有参数。 实例123456789var fs=require('fs');console.log('准备删除文件！');fs.unlink('input.txt',function(err)&#123; if(err)&#123; return console.error(err); &#125; console.log('文件删除成功！');&#125;); 再去查看 input.txt 文件，发现已经不存在了。 创建目录语法以下为创建目录的语法格式： 1fs.mkdir(path[,mode],callback) 参数参数使用说明如下： path - 文件路径。 mode - 设置目录权限，默认为 0777。 callback - 回调函数，没有参数。 实例123456789var fs=require('fs');console.log('创建目录/test');fs.mkdir('./test',function(err)&#123; if(err)&#123; return console.log(err); &#125; console.log('创建目录成功。');&#125;); 运行结果：成功在当前文件目录下创建test文件夹。 读取目录语法以下为读取目录的语法格式： 1fs.readdir(path,callback) 参数参数使用说明如下： path - 文件路径。 callback - 回调函数，回调函数带有两个参数err, files，err 为错误信息，files 为 目录下的文件数组列表。 实例1234567891011var fs=require('fs');console.log('查看/test 目录');fs.readdir('./test/',function(err,files)&#123; if(err)&#123; return console.err(err); &#125; files.forEach(function(file)&#123; console.log(file); &#125;);&#125;); 运行结果： 删除目录语法以下为删除目录的语法格式： 1fs.rmdir(path,callback) 参数参数使用说明如下： path - 文件路径。 callback - 回调函数，没有参数。 实例123456789101112131415161718var fs=require('fs');// 执行前创建一个空的 /kakaxi 目录console.log('准备删除目录/kakaxi/');fs.rmdir('./kakaxi',function(err)&#123; if(err)&#123; return console.error(err); &#125; console.log('读取./目录'); fs.readdir('./',function(err,files)&#123; if(err)&#123; return console.error(err); &#125; files.forEach(function(file)&#123; console.log(file); &#125;); &#125;);&#125;); 运行结果： 文件模块方法参考手册以下为 Node.js 文件模块相同的方法列表： 序号 方法 &amp; 描述 1 fs.rename(oldPath, newPath, callback)异步 rename().回调函数没有参数，但可能抛出异常。 2 fs.ftruncate(fd, len, callback)异步 ftruncate().回调函数没有参数，但可能抛出异常。 3 fs.ftruncateSync(fd, len)同步 ftruncate() 4 fs.truncate(path, len, callback)异步 truncate().回调函数没有参数，但可能抛出异常。 5 fs.truncateSync(path, len)同步 truncate() 6 fs.chown(path, uid, gid, callback)异步 chown().回调函数没有参数，但可能抛出异常。 7 fs.chownSync(path, uid, gid)同步 chown() 8 fs.fchown(fd, uid, gid, callback)异步 fchown().回调函数没有参数，但可能抛出异常。 9 fs.fchownSync(fd, uid, gid)同步 fchown() 10 fs.lchown(path, uid, gid, callback)异步 lchown().回调函数没有参数，但可能抛出异常。 11 fs.lchownSync(path, uid, gid)同步 lchown() 12 fs.chmod(path, mode, callback)异步 chmod().回调函数没有参数，但可能抛出异常。 13 fs.chmodSync(path, mode)同步 chmod(). 14 fs.fchmod(fd, mode, callback)异步 fchmod().回调函数没有参数，但可能抛出异常。 15 fs.fchmodSync(fd, mode)同步 fchmod(). 16 fs.lchmod(path, mode, callback)异步 lchmod().回调函数没有参数，但可能抛出异常。Only available on Mac OS X. 17 fs.lchmodSync(path, mode)同步 lchmod(). 18 fs.stat(path, callback)异步 stat(). 回调函数有两个参数 err, stats，stats 是 fs.Stats 对象。 19 fs.lstat(path, callback)异步 lstat(). 回调函数有两个参数 err, stats，stats 是 fs.Stats 对象。 20 fs.fstat(fd, callback)异步 fstat(). 回调函数有两个参数 err, stats，stats 是 fs.Stats 对象。 21 fs.statSync(path)同步 stat(). 返回 fs.Stats 的实例。 22 fs.lstatSync(path)同步 lstat(). 返回 fs.Stats 的实例。 23 fs.fstatSync(fd)同步 fstat(). 返回 fs.Stats 的实例。 24 fs.link(srcpath, dstpath, callback)异步 link().回调函数没有参数，但可能抛出异常。 25 fs.linkSync(srcpath, dstpath)同步 link(). 26 fs.symlink(srcpath, dstpath[, type], callback)异步 symlink().回调函数没有参数，但可能抛出异常。 type 参数可以设置为 ‘dir’, ‘file’, 或 ‘junction’ (默认为 ‘file’) 。 27 fs.symlinkSync(srcpath, dstpath[, type])同步 symlink(). 28 fs.readlink(path, callback)异步 readlink(). 回调函数有两个参数 err, linkString。 29 fs.realpath(path[, cache], callback)异步 realpath(). 回调函数有两个参数 err, resolvedPath。 30 fs.realpathSync(path[, cache])同步 realpath()。返回绝对路径。 31 fs.unlink(path, callback)异步 unlink().回调函数没有参数，但可能抛出异常。 32 fs.unlinkSync(path)同步 unlink(). 33 fs.rmdir(path, callback)异步 rmdir().回调函数没有参数，但可能抛出异常。 34 fs.rmdirSync(path)同步 rmdir(). 35 fs.mkdir(path[, mode], callback)S异步 mkdir(2).回调函数没有参数，但可能抛出异常。 mode defaults to 0777. 36 fs.mkdirSync(path[, mode])同步 mkdir(). 37 fs.readdir(path, callback)异步 readdir(3). 读取目录的内容。 38 fs.readdirSync(path)同步 readdir().返回文件数组列表。 39 fs.close(fd, callback)异步 close().回调函数没有参数，但可能抛出异常。 40 fs.closeSync(fd)同步 close(). 41 fs.open(path, flags[, mode], callback)异步打开文件。 42 fs.openSync(path, flags[, mode])同步 version of fs.open(). 43 fs.utimes(path, atime, mtime, callback) 44 fs.utimesSync(path, atime, mtime)修改文件时间戳，文件通过指定的文件路径。 45 fs.futimes(fd, atime, mtime, callback) 46 fs.futimesSync(fd, atime, mtime)修改文件时间戳，通过文件描述符指定。 47 fs.fsync(fd, callback)异步 fsync.回调函数没有参数，但可能抛出异常。 48 fs.fsyncSync(fd)同步 fsync. 49 fs.write(fd, buffer, offset, length[, position], callback)将缓冲区内容写入到通过文件描述符指定的文件。 50 fs.write(fd, data[, position[, encoding]], callback)通过文件描述符 fd 写入文件内容。 51 fs.writeSync(fd, buffer, offset, length[, position])同步版的 fs.write()。 52 fs.writeSync(fd, data[, position[, encoding]])同步版的 fs.write(). 53 fs.read(fd, buffer, offset, length, position, callback)通过文件描述符 fd 读取文件内容。 54 fs.readSync(fd, buffer, offset, length, position)同步版的 fs.read. 55 fs.readFile(filename[, options], callback)异步读取文件内容。 56 fs.readFileSync(filename[, options]) 57 fs.writeFile(filename, data[, options], callback)异步写入文件内容。 58 fs.writeFileSync(filename, data[, options])同步版的 fs.writeFile。 59 fs.appendFile(filename, data[, options], callback)异步追加文件内容。 60 fs.appendFileSync(filename, data[, options])The 同步 version of fs.appendFile. 61 fs.watchFile(filename[, options], listener)查看文件的修改。 62 fs.unwatchFile(filename[, listener])停止查看 filename 的修改。 63 fs.watch(filename[, options][, listener])查看 filename 的修改，filename 可以是文件或目录。返回 fs.FSWatcher 对象。 64 fs.exists(path, callback)检测给定的路径是否存在。 65 fs.existsSync(path)同步版的 fs.exists. 66 fs.access(path[, mode], callback)测试指定路径用户权限。 67 fs.accessSync(path[, mode])同步版的 fs.access。 68 fs.createReadStream(path[, options])返回ReadStream 对象。 69 fs.createWriteStream(path[, options])返回 WriteStream 对象。 70 fs.symlink(srcpath, dstpath[, type], callback)异步 symlink().回调函数没有参数，但可能抛出异常。]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js基础学习10--常用工具]]></title>
    <url>%2F2017%2F06%2F03%2FNode-js%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A010-%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Node.js 常用工具util 是一个Node.js 核心模块，提供常用函数的集合，用于弥补核心JavaScript 的功能 过于精简的不足。 util.inheritsutil.inherits(constructor, superConstructor)是一个实现对象间原型继承 的函数。 JavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有 提供对象继承的语言级别特性，而是通过原型复制来实现的。 在这里我们只介绍util.inherits 的用法，示例如下： 1234567891011121314151617181920212223var util = require('util'); function Base() &#123; this.name = 'base'; this.base = 1991; this.sayHello = function() &#123; console.log('Hello ' + this.name); &#125;; &#125; Base.prototype.showName = function() &#123; console.log(this.name);&#125;; function Sub() &#123; this.name = 'sub'; &#125; util.inherits(Sub, Base); var objBase = new Base(); objBase.showName(); objBase.sayHello(); console.log(objBase); var objSub = new Sub(); objSub.showName(); //objSub.sayHello(); console.log(objSub); 我们定义了一个基础对象Base 和一个继承自Base 的Sub，Base 有三个在构造函数 内定义的属性和一个原型中定义的函数，通过util.inherits 实现继承。运行结果如下： 12345base Hello base &#123; name: 'base', base: 1991, sayHello: [Function] &#125; sub &#123; name: 'sub' &#125; 注意：Sub 仅仅继承了Base 在原型中定义的函数，而构造函数内部创造的 base 属 性和 sayHello 函数都没有被 Sub 继承。 同时，在原型中定义的属性不会被console.log 作 为对象的属性输出。如果我们去掉 objSub.sayHello(); 这行的注释，将会看到： 1234567891011node.js:201 throw e; // process.nextTick error, or 'error' event on first tick ^ TypeError: Object #&amp;lt;Sub&amp;gt; has no method 'sayHello' at Object.&amp;lt;anonymous&amp;gt; (/home/byvoid/utilinherits.js:29:8) at Module._compile (module.js:441:26) at Object..js (module.js:459:10) at Module.load (module.js:348:31) at Function._load (module.js:308:12) at Array.0 (module.js:479:10) at EventEmitter._tickCallback (node.js:192:40) util.inspectutil.inspect(object,[showHidden],[depth],[colors])是一个将任意对象转换 为字符串的方法，通常用于调试和错误输出。它至少接受一个参数 object，即要转换的对象。 showHidden 是一个可选参数，如果值为 true，将会输出更多隐藏信息。 depth 表示最大递归的层数，如果对象很复杂，你可以指定层数以控制输出信息的多 少。如果不指定depth，默认会递归2层，指定为 null 表示将不限递归层数完整遍历对象。 如果color 值为 true，输出格式将会以ANSI 颜色编码，通常用于在终端显示更漂亮 的效果。 特别要指出的是，util.inspect 并不会简单地直接把对象转换为字符串，即使该对 象定义了toString 方法也不会调用。 12345678910var util = require('util'); function Person() &#123; this.name = 'byvoid'; this.toString = function() &#123; return this.name; &#125;; &#125; var obj = new Person(); console.log(util.inspect(obj)); console.log(util.inspect(obj, true)); 运行结果是： 12345678910Person &#123; name: 'byvoid', toString: [Function] &#125;Person &#123; name: 'byvoid', toString: &#123; [Function] [length]: 0, [name]: '', [arguments]: null, [caller]: null, [prototype]: &#123; [constructor]: [Circular] &#125; &#125; &#125; util.isArray(object)如果给定的参数 “object” 是一个数组返回true，否则返回false。 12345678var util = require('util');util.isArray([]) // trueutil.isArray(new Array) // trueutil.isArray(&#123;&#125;) // false util.isRegExp(object)如果给定的参数 “object” 是一个正则表达式返回true，否则返回false。 12345678var util = require('util');util.isRegExp(/some regexp/) // trueutil.isRegExp(new RegExp('another regexp')) // trueutil.isRegExp(&#123;&#125;) // false util.isDate(object)如果给定的参数 “object” 是一个日期返回true，否则返回false。 12345678var util = require('util');util.isDate(new Date()) // trueutil.isDate(Date()) // false (without 'new' returns a String)util.isDate(&#123;&#125;) // false util.isError(object)如果给定的参数 “object” 是一个错误对象返回true，否则返回false。 12345678var util = require('util');util.isError(new Error()) // trueutil.isError(new TypeError()) // trueutil.isError(&#123; name: 'Error', message: 'an error occurred' &#125;) // false]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js基础学习</tag>
        <tag>常用工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js基础学习09--全局对象]]></title>
    <url>%2F2017%2F06%2F03%2FNode-js%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A009-%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Node.js 全局对象概念：所有属性都可以在程序的任何地方访问，即全局变量。在JavaScript中，通常window是全局对象，而Node.js的全局对象是global，所有全局变量都是global对象的属性，如：console、process等。 全局对象与全局变量global最根本的作用是作为全局变量的宿主。满足以下条件成为全局变量： 在最外层定义的变量 全局对象的属性 隐式定义的变量(未定义直接赋值的变量) 在Node.js中不可能在最外层定义变量，因为所有用户代码都是属于当前模块的，而模块本身不是最外层上下文。 __filename__filename 表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。 如果在模块中，返回的值是模块文件的路径。 __dirname__dirname 表示当前执行脚本所在的目录。 1234// 输出全局变量 __filename 的值console.log('模块文件的路径:'+ __filename );// 输出全局变量 __dirname 的值console.log('脚本所在的目录:'+ __dirname ); 执行以上代码输出结果 setTimeout(cb, ms)setTimeout(cb, ms) 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。：setTimeout() 只执行一次指定函数。 返回一个代表定时器的句柄值。 12345function printHello()&#123; console.log( "Hello, World!");&#125;// 两秒后执行以上函数setTimeout(printHello, 2000); clearTimeout(t)clearTimeout( t ) 全局函数用于停止一个之前通过 setTimeout() 创建的定时器。 参数 t 是通过 setTimeout() 函数创建的定时器。 12345678function printHello()&#123; console.log( "Hello, World!");&#125;// 两秒后执行以上函数var t = setTimeout(printHello, 2000);// 清除定时器clearTimeout(t); 执行 main.js 文件，代码如下所示: 1$ node main.js setInterval(cb, ms)setInterval(cb, ms) 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。 返回一个代表定时器的句柄值。可以使用 clearInterval(t) 函数来清除定时器。 setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。 12345function printHello()&#123; console.log( "Hello, World!");&#125;// 两秒后执行以上函数setInterval(printHello, 2000); Hello, World! Hello, World! Hello, World! Hello, World! Hello, World! ……以上程序每隔两秒就会输出一次”Hello, World!”，且会永久执行下去，直到你按下 ctrl + c 按钮。 consoleconsole 用于提供控制台标准输出，它是由 Internet Explorer 的 JScript 引擎提供的调试工具，后来逐渐成为浏览器的事实标准。 Node.js 沿用了这个标准，提供与习惯行为一致的 console 对象，用于向标准输出流（stdout）或标准错误流（stderr）输出字符。 console 方法console.log([data][, …]) 向标准输出流打印字符并以换行符结束。该方法接收若干 个参数，如果只有一个参数，则输出这个参数的字符串形式。如果有多个参数，则 以类似于C 语言 printf() 命令的格式输出。 console.time(label) 输出时间，表示计时开始。 console.timeEnd(label)结束时间，表示计时结束。 123console.log('Hello world'); console.log('byvoid%diovyb'); console.log('byvoid%diovyb', 1991); 运行结果为： 123Hello world byvoid%diovyb byvoid1991iovyb 实例 123456789101112console.info("程序开始执行：");var counter = 10;console.log("计数: %d", counter);console.time("获取数据");//// 执行一些代码// console.timeEnd('获取数据');console.info("程序执行完毕。") 运行结果为： 12345$ node main.js程序开始执行：计数: 10获取数据: 0ms程序执行完毕 processprocess 是一个全局变量，即 global 对象的属性。 它用于描述当前Node.js 进程状态的对象，提供了一个与操作系统的简单接口。 下面将会介绍 process 对象的一些最常用的成员方法。 exit当进程准备退出时触发。 beforeExit当 node 清空事件循环，并且没有其他安排时触发这个事件。通常来说，当没有进程安排时 node 退出，但是 ‘beforeExit’ 的监听器可以异步调用，这样 node 就会继续执行。 Signal 事件当进程接收到信号时就触发。信号列表详见标准的 POSIX 信号名，如 SIGINT、SIGUSR1 等。 实例 创建文件 main.js ，代码如下所示： 12345678910process.on('exit', function(code) &#123; // 以下代码永远不会执行 setTimeout(function() &#123; console.log("该代码不会执行"); &#125;, 0); console.log('退出码为:', code);&#125;);console.log("程序执行结束"); 运行结果为： 123$ node main.js程序执行结束退出码为: 0 Process 属性Process 提供了很多有用的属性，便于我们更好的控制系统的交互： stdout标准输出流。 stderr标准错误流。 stdin标准输入流。 execPath返回执行当前脚本的 Node 二进制文件的绝对路径。 env返回一个对象，成员为当前 shell 的环境变量 arch当前 CPU 的架构：’arm’、’ia32’ 或者 ‘x64’。 实例 创建文件 main.js ，代码如下所示： 12345678910111213// 输出到终端process.stdout.write("Hello World!" + "\n");// 通过参数读取process.argv.forEach(function(val, index, array) &#123; console.log(index + ': ' + val);&#125;);// 获取执行路径console.log(process.execPath);// 平台信息console.log(process.platform); 运行结果为： 方法参考手册 Process 提供了很多有用的方法，便于我们更好的控制系统的交互： abort()这将导致 node 触发 abort 事件。会让 node 退出并生成一个核心文件。 cwd()返回当前进程的工作目录 uptime()返回 Node 已经运行的秒数。 实例 创建文件 main.js ，代码如下所示： 12345678// 输出当前目录console.log('当前目录: ' + process.cwd());// 输出当前版本console.log('当前版本: ' + process.version);// 输出内存使用情况console.log(process.memoryUsage()); 运行结果为：]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js基础学习</tag>
        <tag>全局对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js基础学习08--路由]]></title>
    <url>%2F2017%2F06%2F01%2FNode-js%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A008-%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[Node.js 路由我们要为路由提供请求的URL和其他需要的GET及POST参数，随后路由需要根据这些数据来执行相应的代码。 因此，我们需要查看HTTP请求，从中提取出请求的URL以及GET/POST参数。 我们需要的所有数据都会包含在request对象中，该对象作为onRequest()回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的Node.JS模块，它们分别是url和querystring模块。 12345678910111213 url.parse(string).query | url.parse(string).pathname | | | | | ------ -------------------http://localhost:8888/start?foo=bar&amp;hello=world --- ----- | | | | querystring.parse(queryString)["foo"] | | querystring.parse(queryString)["hello"] 当然我们也可以用querystring模块来解析POST请求体中的参数，稍后会有演示。 现在我们来给onRequest()函数加上一些逻辑，用来找出浏览器请求的URL路径： 1234567891011121314151617var http = require("http");var url = require("url");function start() &#123; function onRequest(request, response) &#123; var pathname = url.parse(request.url).pathname; console.log("Request for " + pathname + " received."); response.writeHead(200, &#123;"Content-Type": "text/plain"&#125;); response.write("Hello World"); response.end(); &#125; http.createServer(onRequest).listen(8888); console.log("Server has started.");&#125;exports.start = start; 好了，我们的应用现在可以通过请求的URL路径来区别不同请求了–这使我们得以使用路由（还未完成）来将请求以URL路径为基准映射到处理程序上。 在我们所要构建的应用中，这意味着来自/start和/upload的请求可以使用不同的代码来处理。稍后我们将看到这些内容是如何整合到一起的。 现在我们可以来编写路由了，建立一个名为 router.js 的文件，添加以下内容： 12345function route(pathname) &#123; console.log("About to route a request for " + pathname);&#125;exports.route = route; 如你所见，这段代码什么也没干，不过对于现在来说这是应该的。在添加更多的逻辑以前，我们先来看看如何把路由和服务器整合起来。 我们的服务器应当知道路由的存在并加以有效利用。我们当然可以通过硬编码的方式将这一依赖项绑定到服务器上，但是其它语言的编程经验告诉我们这会是一件非常痛苦的事，因此我们将使用依赖注入的方式较松散地添加路由模块。 首先，我们来扩展一下服务器的start()函数，以便将路由函数作为参数传递过去，server.js 文件代码如下 1234567891011121314151617181920var http = require("http");var url = require("url");function start(route) &#123; function onRequest(request, response) &#123; var pathname = url.parse(request.url).pathname; console.log("Request for " + pathname + " received."); route(pathname); response.writeHead(200, &#123;"Content-Type": "text/plain"&#125;); response.write("Hello World"); response.end(); &#125; http.createServer(onRequest).listen(8888); console.log("Server has started.");&#125;exports.start = start; 同时，我们会相应扩展index.js，使得路由函数可以被注入到服务器中： 1234var server = require("./server");var router = require("./router");server.start(router.route); 在这里，我们传递的函数依旧什么也没做。 如果现在启动应用（node index.js，始终记得这个命令行），随后请求一个URL，你将会看到应用输出相应的信息，这表明我们的HTTP服务器已经在使用路由模块了，并会将请求的路径传递给路由： 12$ node index.jsServer has started. 以上输出已经去掉了比较烦人的/favicon.ico请求相关的部分。 浏览器访问 http://127.0.0.1:8888/，输出结果如下： 1Hello World]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js基础学习</tag>
        <tag>路由</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js基础学习07--函数]]></title>
    <url>%2F2017%2F05%2F31%2FNode-js%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A007-%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Node.js 函数在JavaScript中，一个函数可以作为另一个函数的参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。 Node.js中函数的使用与Javascript类似，举例来说，你可以这样做： 123456789function say(word) &#123; console.log(word);&#125;function execute(someFunction, value) &#123; someFunction(value);&#125;execute(say, "Hello"); 以上代码中，我们把 say 函数作为execute函数的第一个变量进行了传递。这里返回的不是 say 的返回值，而是 say 本身！ 这样一来， say 就变成了execute 中的本地变量 someFunction ，execute可以通过调用 someFunction() （带括号的形式）来使用 say 函数。 当然，因为 say 有一个变量， execute 在调用 someFunction 时可以传递这样一个变量。 匿名函数我们可以把一个函数作为变量传递。但是我们不一定要绕这个”先定义，再传递”的圈子，我们可以直接在另一个函数的括号中定义和传递这个函数： 12345function execute(someFunction, value) &#123; someFunction(value);&#125;execute(function(word)&#123; console.log(word) &#125;, "Hello"); 我们在 execute 接受第一个参数的地方直接定义了我们准备传递给 execute 的函数。 用这种方式，我们甚至不用给这个函数起名字，这也是为什么它被叫做匿名函数 。 函数传递是如何让HTTP服务器工作的带着这些知识，我们再来看看我们简约而不简单的HTTP服务器： 1234567var http = require("http");http.createServer(function(request, response) &#123; response.writeHead(200, &#123;"Content-Type": "text/plain"&#125;); response.write("Hello World"); response.end();&#125;).listen(8888); 现在它看上去应该清晰了很多：我们向 createServer 函数传递了一个匿名函数。 用这样的代码也可以达到同样的目的： 123456789var http = require("http");function onRequest(request, response) &#123; response.writeHead(200, &#123;"Content-Type": "text/plain"&#125;); response.write("Hello World"); response.end();&#125;http.createServer(onRequest).listen(8888);]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js基础学习</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js基础学习06--模块系统]]></title>
    <url>%2F2017%2F05%2F31%2FNode-js%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A006-%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[Node.js模块系统为了让Node.js的文件可以相互调用，Node.js提供了一个简单的模块系统。 模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C/C++ 扩展。 创建模块在 Node.js 中，创建一个模块非常简单，如下我们创建一个 ‘main.js’ 文件，代码如下: 12var hello = require('./hello');hello.world(); 以上实例中，代码 require(‘./hello’) 引入了当前目录下的hello.js文件（./ 为当前目录，node.js默认后缀为js）。 Node.js 提供了exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。 接下来我们就来创建hello.js文件，代码如下： 123exports.world = function() &#123; console.log('Hello World');&#125; 在以上示例中，hello.js 通过 exports 对象把 world 作为模块的访问接口，在 main.js 中通过 require(‘./hello’) 加载这个模块，然后就可以直接访 问 hello.js 中 exports 对象的成员函数了。 有时候我们只是想把一个对象封装到模块中，格式如下： 123module.exports = function() &#123; // ...&#125; 例如: 1234567891011// hello.jsfunction Hello()&#123; var name; this.setName=function(thyName)&#123; name=thyName; &#125;; this.sayHello=function()&#123; console.log('Hello '+name); &#125;;&#125;module.exports=Hello; 这样就可以直接获得这个对象了： 12345// main.jsvar Hello=require('./hello');hello=new Hello();hello.setName('kakaxi');hello.sayHello(); 模块接口的唯一变化是使用 module.exports = Hello 代替了exports.world = function(){}。 在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports。 服务端的模块放在哪里也许你已经注意到，我们已经在代码中使用了模块了。像这样： 12345var http = require("http");...http.createServer(...); Node.js中自带了一个叫做”http”的模块，我们在我们的代码中请求它并把返回值赋给一个本地变量。 这把我们的本地变量变成了一个拥有所有 http 模块所提供的公共方法的对象。 Node.js 的 require方法中的文件查找策略如下： 由于Node.js中存在4类模块（原生模块和3种文件模块），尽管require方法极其简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同。如下图所示： 从文件模块缓存中加载尽管原生模块与文件模块的优先级不同，但是都不会优先于从文件模块的缓存中加载已经存在的模块。 从原生模块加载原生模块的优先级仅次于文件模块缓存的优先级。require方法在解析文件名之后，优先检查模块是否在原生模块列表中。以http模块为例，尽管在目录下存在一个http/http.js/http.node/http.json文件，require(“http”)都不会从这些文件中加载，而是从原生模块中加载。 原生模块也有一个缓存区，同样也是优先从缓存区加载。如果缓存区没有被加载过，则调用原生模块的加载方式进行加载和执行。 从文件加载当文件模块缓存中不存在，而且不是原生模块的时候，Node.js会解析require方法传入的参数，并从文件系统中加载实际的文件，加载过程中的包装和编译细节在前一节中已经介绍过，这里我们将详细描述查找文件模块的过程，其中，也有一些细节值得知晓。 require方法接受以下几种参数的传递： http、fs、path等，原生模块。 ./mod或../mod，相对路径的文件模块。 /pathtomodule/mod，绝对路径的文件模块。 mod，非原生模块的文件模块。 在路径 Y 下执行 require(X) 语句执行顺序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445461. 如果 X 是内置模块 a. 返回内置模块 b. 停止执行2. 如果 X 以 '/' 开头 a. 设置 Y 为文件根路径3. 如果 X 以 './' 或 '/' or '../' 开头 a. LOAD_AS_FILE(Y + X) b. LOAD_AS_DIRECTORY(Y + X)4. LOAD_NODE_MODULES(X, dirname(Y))5. 抛出异常 "not found"LOAD_AS_FILE(X)1. 如果 X 是一个文件, 将 X 作为 JavaScript 文本载入并停止执行。2. 如果 X.js 是一个文件, 将 X.js 作为 JavaScript 文本载入并停止执行。3. 如果 X.json 是一个文件, 解析 X.json 为 JavaScript 对象并停止执行。4. 如果 X.node 是一个文件, 将 X.node 作为二进制插件载入并停止执行。LOAD_INDEX(X)1. 如果 X/index.js 是一个文件, 将 X/index.js 作为 JavaScript 文本载入并停止执行。2. 如果 X/index.json 是一个文件, 解析 X/index.json 为 JavaScript 对象并停止执行。3. 如果 X/index.node 是一个文件, 将 X/index.node 作为二进制插件载入并停止执行。LOAD_AS_DIRECTORY(X)1. 如果 X/package.json 是一个文件, a. 解析 X/package.json, 并查找 "main" 字段。 b. let M = X + (json main 字段) c. LOAD_AS_FILE(M) d. LOAD_INDEX(M)2. LOAD_INDEX(X)LOAD_NODE_MODULES(X, START)1. let DIRS=NODE_MODULES_PATHS(START)2. for each DIR in DIRS: a. LOAD_AS_FILE(DIR/X) b. LOAD_AS_DIRECTORY(DIR/X)NODE_MODULES_PATHS(START)1. let PARTS = path split(START)2. let I = count of PARTS - 13. let DIRS = []4. while I &gt;= 0, a. if PARTS[I] = "node_modules" CONTINUE b. DIR = path join(PARTS[0 .. I] + "node_modules") c. DIRS = DIRS + DIR d. let I = I - 15. return DIRS]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js基础学习</tag>
        <tag>模块系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js基础学习05--Stream(流)]]></title>
    <url>%2F2017%2F05%2F31%2FNode-js%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A005-Stream-%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Node.js Stream(流)Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。 Node.js，Stream 有四种流类型： Readable - 可读操作。 Writable - 可写操作。 Duplex - 可读可写操作. Transform - 操作被写入数据，然后读出结果。 所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有： data - 当有数据可读时触发。 end - 没有更多的数据可读时触发。 error - 在接收和写入过程中发生错误时触发。 finish - 所有数据已被写入到底层系统时触发。 从流中读取数据创建 main.js 文件, 代码如下： 1234567891011121314151617181920212223var fs=require('fs');var data='';// 创建可读流var readerStream=fs.createReadStream('input.txt');// 设置编码为 utf8readerStream.setEncoding('UTF8');// 处理流事件 --&gt; data,end,and errorreaderStream.on('data',function(chunk)&#123; data+=chunk;&#125;);readerStream.on('end',function()&#123; console.log(data);&#125;);readerStream.on('error',function(err)&#123; console.log(err.stack);&#125;);console.log('程序执行完毕'); 以上代码执行结果如下： 写入流创建 main.js 文件, 代码如下： 12345678910111213141516171819202122var fs=require('fs');var data='苹果味博客：itcabin.com';// 创建一个可以写入的流，写入到文件output.txt中var writerStream=fs.createWriteStream('output.txt');// 使用 utf8 编码写入数据writerStream.write(data,'UTF8');// 标记文件末尾writerStream.end();// 处理流事件 --&gt; data,end,and errorwriterStream.on('finish',function()&#123; console.log('写入完成');&#125;);writerStream.on('error',function(err)&#123; console.log(err.stack);&#125;);console.log('程序执行完毕'); 以上程序会将 data 变量的数据写入到 output.txt 文件中。代码执行结果如下： 查看 output.txt 文件的内容： 管道流管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。 如上面的图片所示，我们把文件比作装水的桶，而水就是文件里的内容，我们用一根管子(pipe)连接两个桶使得水从一个桶流入另一个桶，这样就慢慢的实现了大文件的复制过程。 以下实例我们通过读取一个文件内容并将内容写入到另外一个文件中。 设置 input.txt 文件内容如下： 12苹果味博客：itcabin.com管道流操作实例 创建 main.js 文件, 代码如下： 123456789101112var fs=require('fs');// 创建一个可读流var readerStream=fs.createReadStream('input.txt');// 创建一个可写流var writerStream=fs.createWriteStream('output.txt');// 管道读写操作// 读取 input.txt 文件内容，并将内容写入到 output.txt文件中readerStream.pipe(writerStream);console.log('程序执行完毕'); 查看 output.txt 文件的内容： 链式流链式是通过连接输出流到另外一个流并创建多个对个流操作链的机制。链式流一般用于管道操作。 接下来我们就是用管道和链式来压缩和解压文件。 创建 compress.js 文件, 代码如下： 123456789var fs=require('fs');var zlib=require('zlib');// 压缩 input.txt 文件为 input.txt.gzfs.createReadStream('input.txt') .pipe(zlib.createGzip()) .pipe(fs.createWriteStream('input.txt.gz')); console.log('文件压缩完成。'); 代码执行结果如下： 12$ node compress.js 文件压缩完成。 执行完以上操作后，我们可以看到当前目录下生成了 input.txt 的压缩文件 input.txt.gz。 接下来，让我们来解压该文件，创建 decompress.js 文件，代码如下： 123456789var fs=require('fs');var zlib=require('zlib');// 解压 input.txt.gz文件为 input.txtfs.createReadStream('input.txt.gz') .pipe(zlib.createGunzip()) .pipe(fs.createWriteStream('input.txt')); console.log('文件解压完成。'); 生成input.txt文件,代码执行结果如下： 12$ node decompress.js 文件解压完成。]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js基础学习</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js基础学习04--Buffer(缓冲区)]]></title>
    <url>%2F2017%2F05%2F26%2FNode-js%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A004-Buffer-%E7%BC%93%E5%86%B2%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[Node.js Buffer(缓冲区)JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。 但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。 在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。 创建 Buffer 类Node Buffer 类可以通过多种方式来创建。 方法 1创建长度为 10 字节的 Buffer 实例： 1var buf=new Buffer(10); 方法 2通过给定的数组创建 Buffer 实例： 1var buf=new Buffer([10,20,30,40,50]); 方法 3通过一个字符串来创建 Buffer 实例： 12var buf=new Buffer('www.itcabin.com','utf-8');// utf-8 是默认的编码方式，此外它同样支持以下编码："ascii", "utf8", "utf16le", "ucs2", "base64" 和 "hex"。 写入缓冲区语法写入 Node 缓冲区的语法如下所示： 1buf.write(string,offset,length,encoding); 参数参数描述如下： string - 写入缓冲区的字符串。 offset - 缓冲区开始写入的索引值，默认为 0 。 length - 写入的字节数，默认为 buffer.length encoding - 使用的编码。默认为 ‘utf8’ 。 返回值返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。 实例1234buf = new Buffer(256);len = buf.write("itcabin.com");console.log("写入字节数 : "+ len); 执行以上代码，输出结果为： 12$node main.js写入字节数 : 11 从缓冲区读取数据语法读取 Node 缓冲区数据的语法如下所示： 1buf.toString([encoding, start, end) 参数描述如下： encoding - 使用的编码。默认为 ‘utf8’ 。 start - 指定开始读取的索引位置，默认为 0。 end - 结束位置，默认为缓冲区的末尾。 返回值解码缓冲区数据并使用指定的编码返回字符串。 实例123456789buf = new Buffer(26);for (var i = 0 ; i &lt; 26 ; i++) &#123; buf[i] = i + 97;&#125;console.log( buf.toString('ascii')); // 输出: abcdefghijklmnopqrstuvwxyzconsole.log( buf.toString('ascii',0,5)); // 输出: abcdeconsole.log( buf.toString('utf8',0,5)); // 输出: abcdeconsole.log( buf.toString(undefined,0,5)); // 使用 'utf8' 编码, 并输出: abcde 执行以上代码，输出结果为： 12345$ node main.jsabcdefghijklmnopqrstuvwxyzabcdeabcdeabcde 将 Buffer 转换为 JSON 对象语法将 Node Buffer 转换为 JSON 对象的函数语法格式如下： 1buf.toJSON() 返回值返回 JSON 对象。 实例1234var buf = new Buffer('itcabin.com');var json = buf.toJSON(buf);console.log(json); 执行以上代码，输出结果为： 12&#123; type: 'Buffer', data: [ 105, 116, 99, 97, 98, 105, 110, 46, 99, 111, 109 ] &#125; 缓冲区合并语法Node 缓冲区合并的语法如下所示： 1Buffer.concat(list, totalLength) 参数描述如下： list - 用于合并的 Buffer 对象数组列表。 totalLength - 指定合并后Buffer对象的总长度。 返回值返回一个多个成员合并的新 Buffer 对象。 实例1234var buffer1 = new Buffer('苹果味 ');var buffer2 = new Buffer('itcabin.com');var buffer3 = Buffer.concat([buffer1,buffer2]);console.log("buffer3 内容: " + buffer3.toString()); 执行以上代码，输出结果为： 1buffer3 内容: 苹果味 itcabin.com 缓冲区比较语法Node Buffer 比较的函数语法如下所示, 该方法在 Node.js v0.12.2 版本引入： 1buf.compare(otherBuffer); 参数描述如下： otherBuffer - 与 buf 对象比较的另外一个 Buffer 对象。 返回值返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同。 实例1234567891011var buffer1 = new Buffer('ABC');var buffer2 = new Buffer('ABCD');var result = buffer1.compare(buffer2);if(result &lt; 0) &#123; console.log(buffer1 + " 在 " + buffer2 + "之前");&#125;else if(result == 0)&#123; console.log(buffer1 + " 与 " + buffer2 + "相同");&#125;else &#123; console.log(buffer1 + " 在 " + buffer2 + "之后");&#125; 执行以上代码，输出结果为： 1ABC在ABCD之前 拷贝缓冲区语法Node 缓冲区拷贝语法如下所示： 1buf.copy(targetBuffer, targetStart, sourceStart, sourceEnd) 参数描述如下： targetBuffer - 要拷贝的 Buffer 对象。 targetStart - 数字, 可选, 默认: 0 sourceStart - 数字, 可选, 默认: 0 sourceEnd - 数字, 可选, 默认: buffer.length 返回值没有返回值。 实例12345var buffer1 = new Buffer('ABC');// 拷贝一个缓冲区var buffer2 = new Buffer(2);buffer1.copy(buffer2);console.log("buffer2 content: " + buffer2.toString()); 执行以上代码，输出结果为： 1buffer2 content: AB 缓冲区裁剪Node 缓冲区裁剪语法如下所示： 1buf.slice([start, end) 参数描述如下： start - 数字, 可选, 默认: 0 end - 数字, 可选, 默认: buffer.length 返回值返回一个新的缓冲区，它和旧缓冲区指向同一块内存，但是从索引 start 到 end 的位置剪切。 实例1234var buffer1 = new Buffer('itcabin');// 剪切缓冲区var buffer2 = buffer1.slice(0,2);console.log("buffer2 content: " + buffer2.toString()); 执行以上代码，输出结果为： 1buffer2 content: it 缓冲区长度语法Node 缓冲区长度计算语法如下所示： 1buf.length; 返回值返回 Buffer 对象所占据的内存长度。 实例123var buffer = new Buffer('www.runoob.com');// 缓冲区长度console.log("buffer length: " + buffer.length); 执行以上代码，输出结果为： 1buffer length: 11 方法参考手册以下列出了 Node.js Buffer 模块常用的方法（注意有些方法在旧版本是没有的）： 1.new Buffer(size)分配一个新的 size 大小单位为8位字节的 buffer。 注意, size 必须小于 kMaxLength，否则，将会抛出异常 RangeError。 2.new Buffer(buffer)拷贝参数 buffer 的数据到 Buffer 实例。 3.new Buffer(str[, encoding])分配一个新的 buffer ，其中包含着传入的 str 字符串。 encoding 编码方式默认为 ‘utf8’。 4.buf.length返回这个 buffer 的 bytes 数。注意这未必是 buffer 里面内容的大小。length 是 buffer 对象所分配的内存数，它不会随着这个 buffer 对象内容的改变而改变。 5.buf.write(string[, offset[, length]][, encoding])根据参数 offset 偏移量和指定的 encoding 编码方式，将参数 string 数据写入buffer。 offset 偏移量默认值是 0, encoding 编码方式默认是 utf8。 length 长度是将要写入的字符串的 bytes 大小。 返回 number 类型，表示写入了多少 8 位字节流。如果 buffer 没有足够的空间来放整个 string，它将只会只写入部分字符串。 length 默认是 buffer.length - offset。 这个方法不会出现写入部分字符。 6.buf.toString([encoding, start, end)根据 encoding 参数（默认是 ‘utf8’）返回一个解码过的 string 类型。还会根据传入的参数 start (默认是 0) 和 end (默认是 buffer.length)作为取值范围。 7.buf.toJSON()将 Buffer 实例转换为 JSON 对象。 8.buf[index]获取或设置指定的字节。返回值代表一个字节，所以返回值的合法范围是十六进制0x00到0xFF 或者十进制0至 255。 9.buf.compare(otherBuffer)比较两个 Buffer 对象，返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同。 10.buf.slice([start[, end]])剪切 Buffer 对象，根据 start(默认是 0 ) 和 end (默认是 buffer.length ) 偏移和裁剪了索引。 负的索引是从 buffer 尾部开始计算的。 11.buf.fill(value[, offset][, end])使用指定的 value 来填充这个 buffer。如果没有指定 offset (默认是 0) 并且 end (默认是 buffer.length) ，将会填充整个buffer。]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js基础学习</tag>
        <tag>Buffer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js基础学习03--EventEmitter]]></title>
    <url>%2F2017%2F05%2F25%2FNode-js%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A003-EventEmitter%2F</url>
    <content type="text"><![CDATA[Node.js EventEmitterNode.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。 Node.js里面的许多对象都会分发事件：一个net.Server对象会在每次有新连接时分发一个事件， 一个fs.readStream对象会在文件被打开的时候发出一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。 EventEmitter 类events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。 你可以通过require(“events”);来访问该模块。 1234// 引入 events 模块var events = require('events');// 创建 eventEmitter 对象var eventEmitter = new events.EventEmitter(); EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。 下面我们用一个简单的例子说明 EventEmitter 的用法： 123456789// event.js 文件var EventEmitter = require('events').EventEmitter; var event = new EventEmitter(); event.on('myEvent', function() &#123; console.log('myEvent 事件触发'); &#125;); setTimeout(function() &#123; event.emit('some_event'); &#125;, 1000); event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在 1000 毫秒以后向 event 对象发送事件 some_event，此时会调用some_event 的监听器。 EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。 当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。 让我们以下面的例子解释这个过程： 123456789var events=require('events');var emitter=new events.EventEmitter();emitter.on('myEvent',function(arg1,arg2)&#123; console.log('listener1',arg1,arg2);&#125;);emitter.on('myEvent',function(arg1,arg2)&#123; console.log('listener2',arg1,arg2);&#125;);emitter.emit('myEvent','arg1参数','arg2参数'); 执行以上代码，运行的结果如下： 以上例子中，emitter 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件。 运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是EventEmitter最简单的用法。 EventEmitter 提供了多个属性，如 on 和 emit。on 函数用于绑定事件函数，emit 属性用于触发一个事件。接下来我们来具体看下 EventEmitter 的属性介绍。 方法1.addListener(event, listener) 为指定事件添加一个监听器到监听器数组的尾部。 2.on(event, listener) 为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。 123server.on('connection', function (stream) &#123; console.log('someone connected!');&#125;); 3.once(event, listener) 为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。 123server.once('connection', function (stream) &#123; console.log('Ah, we have our first user!');&#125;); 4.removeListener(event, listener) 移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。 它接受两个参数，第一个是事件名称，第二个是回调函数名称。 123456var callback = function(stream) &#123; console.log('someone connected!');&#125;;server.on('connection', callback);// ...server.removeListener('connection', callback); 5.removeAllListeners([event]) 移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。 6.setMaxListeners(n) 默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。 7.listeners(event) 返回指定事件的监听器数组。 8.emit(event, [arg1], [arg2], […]) 按参数的顺序执行每个监听器，如果事件有注册监听返回 true，否则返回 false。 类方法1.listenerCount(emitter, event) 返回指定事件的监听器数量。 事件1.newListener event - 字符串，事件名称 listener - 处理事件函数 该事件在添加新监听器时被触发。 2.removeListener event - 字符串，事件名称 listener - 处理事件函数 从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引。 实例以下实例通过 connection（连接）事件演示了 EventEmitter 类的应用。 创建 main.js 文件，代码如下： 123456789101112131415161718192021222324252627282930313233343536var events = require('events');var eventEmitter = new events.EventEmitter();// 监听器 #1var listener1 = function listener1() &#123; console.log('监听器 listener1 执行。');&#125;// 监听器 #2var listener2 = function listener2() &#123; console.log('监听器 listener2 执行。');&#125;// 绑定 connection 事件，处理函数为 listener1 eventEmitter.addListener('connection', listener1);// 绑定 connection 事件，处理函数为 listener2eventEmitter.on('connection', listener2);var eventListeners = require('events').EventEmitter.listenerCount(eventEmitter,'connection');console.log(eventListeners + " 个监听器监听连接事件。");// 处理 connection 事件 eventEmitter.emit('connection');// 移除监绑定的 listener1 函数eventEmitter.removeListener('connection', listener1);console.log("listener1 不再受监听。");// 触发连接事件eventEmitter.emit('connection');eventListeners = require('events').EventEmitter.listenerCount(eventEmitter,'connection');console.log(eventListeners + " 个监听器监听连接事件。");console.log("程序执行完毕。"); 执行以上代码，运行的结果如下： error 事件EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。 当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。 我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。例如： 123var events = require('events'); var emitter = new events.EventEmitter(); emitter.emit('error'); 运行时会显示以下错误： 继承 EventEmitter大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。 为什么要这样做呢？原因有两点： 首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发射应该是一个对象的方法。 其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js基础学习</tag>
        <tag>EventEmitter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js基础学习02--回调函数、事件循环]]></title>
    <url>%2F2017%2F05%2F24%2FNode-js%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A002-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E3%80%81%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[Node.js回调函数Node.js 异步编程的直接体现就是回调。 异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。 回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。 例如，我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I/O 操作。这就大大提高了 Node.js 的性能，可以处理大量的并发请求。 阻塞代码实例创建一个文件 input.txt ，内容如下： 1苹果味博客：itcabin.com 创建 main.js 文件, 代码如下： 123456var fs = require("fs");var data = fs.readFileSync('input.txt');console.log(data.toString());console.log("程序执行结束!"); 以上代码执行结果如下： 1234$ node main.js苹果味博客：itcabin.com程序执行结束! 非阻塞代码实例创建 main.js 文件, 代码如下： 12345678var fs = require("fs");fs.readFile('input.txt', function (err, data) &#123; if (err) return console.error(err); console.log(data.toString());&#125;);console.log("程序执行结束!"); 以上代码执行结果如下： 123$ node main.js程序执行结束!苹果味博客：itcabin.com 以上两个实例我们了解了阻塞与非阻塞调用的不同。第一个实例在文件读取完后才执行完程序。 第二个实例我们不需要等待文件读取完，这样就可以在读取文件时同时执行接下来的代码，大大提高了程序的性能。 因此，阻塞是按顺序执行的，而非阻塞是不需要按顺序的，所以如果需要处理回调函数的参数，我们就需要写在回调函数内。 Node.js 事件循环Node.js 是单进程单线程应用程序，但是通过事件和回调支持并发，所以性能非常高。 Node.js 的每一个 API 都是异步的，并作为一个独立线程运行，使用异步函数调用，并处理并发。 Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。 Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数. 事件驱动程序Node.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。 当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。 在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。 整个事件驱动的流程就是这么实现的，非常简洁。有点类似于观察者模式，事件相当于一个主题(Subject)，而所有注册到这个事件上的处理函数相当于观察者(Observer)。 Node.js 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件，如下实例： 1234// 引入 events 模块var events = require('events');// 创建 eventEmitter 对象var eventEmitter = new events.EventEmitter(); 以下程序绑定事件处理程序： 12// 绑定事件及事件的处理程序eventEmitter.on('eventName', eventHandler); 我们可以通过程序触发事件： 12// 触发事件eventEmitter.emit('eventName'); 实例创建 main.js 文件，代码如下所示： 12345678910111213141516171819202122232425// 引入 events 模块var events = require('events');// 创建 eventEmitter 对象var eventEmitter = new events.EventEmitter();// 创建事件处理程序var connectHandler = function connected() &#123; console.log('连接成功。'); // 触发 data_received 事件 eventEmitter.emit('data_received');&#125;// 绑定 connection 事件处理程序eventEmitter.on('connection', connectHandler); // 使用匿名函数绑定 data_received 事件eventEmitter.on('data_received', function()&#123; console.log('数据接收成功。');&#125;);// 触发 connection 事件 eventEmitter.emit('connection');console.log("程序执行完毕。"); 执行结果： Node 应用程序是如何工作的？在 Node 应用程序中，执行异步操作的函数将回调函数作为最后一个参数， 回调函数接收错误对象作为第一个参数。 接下来让我们来重新看下前面的实例，创建一个 input.txt ,文件内容如下： 1苹果味博客：itcabin.com 创建 main.js 文件，代码如下： 12345678910var fs = require("fs");fs.readFile('input.txt', function (err, data) &#123; if (err)&#123; console.log(err.stack); return; &#125; console.log(data.toString());&#125;);console.log("程序执行完毕"); 以上程序中 fs.readFile() 是异步函数用于读取文件。 如果在读取文件过程中发生错误，错误 err 对象就会输出错误信息。 如果没发生错误，readFile 跳过 err 对象的输出，文件内容就通过回调函数输出。 执行以上代码，执行结果如下： 接下来我们删除 input.txt 文件，执行结果如下所示： 因为文件 input.txt 不存在，所以输出了错误信息。]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js基础学习</tag>
        <tag>回调函数</tag>
        <tag>事件循环</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js基础学习01--创建第一个应用]]></title>
    <url>%2F2017%2F05%2F23%2FNode-js%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A001-%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Node.js简介简单的说 Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。 Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。 Node.js 创建第一个应用在我们创建 Node.js 第一个 “Hello, World!” 应用前，让我们先了解下 Node.js 应用是由哪几部分组成的： 引入 required 模块：我们可以使用 require 指令来载入 Node.js 模块。 创建服务器：服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。 接收请求与响应请求 服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。 创建 Node.js 应用步骤一、引入 required 模块我们使用 require 指令来载入 http 模块，并将实例化的 HTTP 赋值给变量 http，实例如下: 1var http = require("http"); 步骤二、创建服务器接下来我们使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。 函数通过 request, response 参数来接收和响应数据。 实例如下，在你项目的根目录下创建一个叫 server.js 的文件，并写入以下代码： 12345678910111213var http=require('http');http.createServer(function(request,response)&#123; // 发送HTTP头部 // HTTP 状态值：200：ok // 内容类型：text/plain response.writeHead(200,&#123;'Content-Type':'text/plain'&#125;); // 发送响应数据"Hello World\n" response.end('Hello World\n');&#125;).listen(8888);// 终端打印信息如下console.log('Server running at http://127.0.0.1:8888/') 以上代码我们完成了一个可以工作的 HTTP 服务器。 使用 node 命令执行以上的代码： 12node server.jsServer running at http://127.0.0.1:8888/ 接下来，打开浏览器访问 http://127.0.0.1:8888/，你会看到一个写着 “Hello World”的网页。 分析Node.js 的 HTTP 服务器： 第一行请求（require）Node.js 自带的 http 模块，并且把它赋值给 http 变量。 接下来我们调用 http 模块提供的函数： createServer 。这个函数会返回 一个对象，这个对象有一个叫做 listen 的方法，这个方法有一个数值参数， 指定这个 HTTP 服务器监听的端口号。]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js基础学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js安装及配置]]></title>
    <url>%2F2017%2F05%2F22%2FNode-js%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Node.js安装及配置安装node.js 下载完成后，双击“node-v6.9.2-x64.msi”，开始安装Node.js,建议不要安装到C盘，后期下载扩展包会存在权限问题，nodejs安装目录：E:\nodejs，默认安装会在系统变量Path后添加 E:\nodejs 值。 安装完毕后输入 node -v 和 npm -v 命令，能正常输出版本信息则安装正确。 配置系统环境变量 在nodejs安装目录 E:\nodejs 下添加 node_global和node_cache文件夹 运行命令 npm config set prefix “E:\nodejs\node_global” ; npm config set cache “E:\nodejs\node_cache” 在系统环境变量Path后加上 E:\nodejs\node_global ,以”;”隔开 添加 “NODE_PATH”系统环境变量，变量值 E:\nodejs\node_global\node_modules 常用模块安装1234567891011121314淘宝 NPM 镜像：npm install -g cnpm --registry=https://registry.npm.taobao.orgnode-gdal模块：cnpm install gdal -g --saveexpress框架：cnpm install -g express 其他常用模块：cnpm install -g requestcnpm install -g geojson2wkt cnpm install pm2 -gcnpm install express-generator -g]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>安装配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript整理：this,call,apply,bind总结]]></title>
    <url>%2F2017%2F05%2F21%2FJavaScript%E6%95%B4%E7%90%86%EF%BC%9Athis-call-apply-bind%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、thisJavaScript 中的 this 总是指向一个对象，而具体指向那个对象是在运行时基于函数的执行环境动态绑定的，而非函数声明时的环境实际应用中 this 的指向大致可以分为以下 4 中： 作为对象的方法调用 作为普通函数掉用 构造器调用 Function.prototype.call 或 Function.prototype.apply 调用, 可以动态地改变出入函数的 this 1.作为对象的方法调用时， this 指向该对象12345678var obj = &#123; a: 1, getA: function()&#123; console.log( this == obj ); // true console.log( this.a ); // 1 &#125;&#125;;obj.getA(); 2.作为普通函数掉用，this 总是指向全局对象 window12345678console.log(this); // Windowswindow.name = "globalName";var getName = function() &#123; return this.name;&#125;console.log( getName() ); // globalName 3.构造器调用, 当用 new 运算符调用函数时，该函数总是会返回一个对象，通常情况下，构造函数里的 this 就指向返回的这个对象12345var MyClass = function()&#123; this.name = "class"; &#125;var obj = new MyClass();console.log( obj.name ); // class 如果使用 new 调用构造器时，构造器显式地返回了一个 object 类型的对象，那么此次运算结果最终会返回这个对象，而不是我么之前期待的 this 12345678var MyClass = function()&#123; this.name = "class"; return &#123; name: "other" &#125;&#125;var obj = new MyClass(); // 返回的是 &#123;name:"other"&#125; 这个对象console.log(obj.name); // other 二、 call 和 apply 他们的作用一模一样，区别仅在于传入参数形式的不同。​ apply 接收两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以是数组，也可以是类数组，apply 方法把这个集合中的元素作为参数传入被调用的函数。​ call 传入的参数不固定，跟 apply 相同的是，第一个参数也代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数 1234567var func = function(a, b, c)&#123; console.log([a, b, c]);&#125;//传入的第一个参数为 null ，函数体内的 this 会指向默认的宿主对象，在浏览器中则是 windowfunc.apply(null, [1, 2, 3]); // 输出：[ 1, 2, 3 ]func.call(null, 1, 2, 3); // 输出：[ 1, 2, 3 ] call 和 apply 的用途: 1.改变 this 指向12345678910111213141516var obj1 = &#123; name: "obj1"&#125;;var obj2 = &#123; name: "obj2"&#125;;window.name = "window";var getName = function()&#123; console.log( this.name );&#125;getName(); // windowgetName.call( obj1 ); // obj1getName.call( obj2 ); // obj2 当执行 getName.call( obj1 ) 这句代码时， getName 函数体内的 this 就指向 obj1 对象，所以此处的 123var getName = function()&#123; console.log( this.name );&#125; 实际上相当于 123var getName = function()&#123; console.log( obj1.name );&#125; 2.用来模拟 Function.prototype.bind 指定函数内部的 this 指向3.借用其他对象的方法， 可以模拟实现继承123456789101112var A = function(name)&#123; this.name = name;&#125;var B = function()&#123; A.apply( this, arguments);&#125;B.prototype.getName = function()&#123; return this.name;&#125;var b = new B("2B铅笔");console.log( b.getName() ); // 输出： 2B铅笔 借用 Array.prototype 对象上的方法，对参数列表 arguments 这个类数组对象，进行数组对象方法的调用 1234(function()&#123; Array.prototype.push.call( arguments, 3); console.log( arguments ); // 输出： [1, 2, 3]&#125;)(1, 2); 三、ECMAScript 5 中的 bind() 方法可以将函数绑定到一个对象上1234function f(y) &#123;return this.x + y&#125;;var o = &#123; x: 1&#125;;var g = f.bind(o);g(2); // 3]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>this</tag>
        <tag>call</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL日常记录]]></title>
    <url>%2F2017%2F05%2F21%2FSQL%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[SQL语句增加字段、修改字段、修改类型、修改默认值一、添加字段123ALTER TABLE table_name ADD column_name datatype-- 例如ALTER TABLE Persons ADD Birthday date 二、删除字段123ALTER TABLE table_name DROP COLUMN column_name-- 例如ALTER TABLE Person DROP COLUMN Birthday 三、改变字段数据类型123ALTER TABLE table_name ALTER COLUMN column_name datatype-- 例如ALTER TABLE Persons ALTER COLUMN Birthday int 四、修改字段名1234567891011--不能用SQL修改字段名,试用以下方法alter table table_name add new_field_name intgoupdate table_nameset new_field_name = old_field_namegoalter table table_name drop column old_field_namego-- 添加新的字段，赋值，删除旧的字段]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL日常笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL常用函数]]></title>
    <url>%2F2017%2F05%2F20%2FSQL%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[类型转换函数123456789101112131415161718--select :输出为结果集--虚拟表--print：以文本形式输出 只能输出一个字符串值.print 1+'a'select 1,2select * from Student--类型转换--Convert(目标类型,源数据,[格式]) --日期有格式print '我的成绩是：'+convert(char(3),100)print '今天是个大日子：'+convert(varchar(30),getdate(),120)select getdate()select len(getdate())--cast(源数据 as 目标类型) 它没有格式print '我的成绩是：'+cast(100 as char(3)) 日期函数12345678910--getdate():获取当前服务器日期select GETDATE()--可以在源日期值是追加指定时间间隔的日期数select DATEADD(dd,-90,GETDATE())--dateDiff:找到两个日期之间指定格式的差异值select StudentName,DATEDIFF(yyyy,getdate(),BornDate) as age from Student order by age--DATENAME:可以获取日期的指定格式的字符串表现形式select DATENAME(dw,getdate())--DATEPART:可以获取指定的日期部分select cast(DATEPART(yyyy,getdate()) as CHAR(4))+'-' +cast(DATEPART(mm,getdate()) as CHAR(2))+'-' +cast(DATEPART(dd,getdate()) as CHAR(2)) 数学函数12345678910111213141516--rand:随机数:返回0到1之间的数，理论上说可以返回0但是不能返回1select RAND()--abs:absolute:取绝对值select ABS(-100)--ceiling:获取比当前数大的最小整数select CEILING(1.00)--floor:获取比当前数小的最大整数select floor(1.99999)--power:幂运算 3*3*3*3select POWER(3,4) ---81--round():四舍五入.只关注指定位数后一位select ROUND(1.549,1)--sign:正数==1 负数 ==-1 0=0select SIGN(-100)select ceiling(17*1.0/5) 联合结果集union123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657--联合结果集unionselect * from Student where Sex='男'--unionselect * from Student where Sex='女'--联合的前提是：--1.列的数量需要一致:使用 UNION、INTERSECT 或 EXCEPT 运算符合并的所有查询必须在其目标列表中有相同数目的表达式--2.列的类型需要可以相互转换select StudentName,Sex from Student --在字符串排序的时候，空格是最小的，排列在最前面unionselect cast(ClassId as CHAR(3)),classname from grade--union和union all的区别--union是去除重复记录的--union all不去除重复 ：效率更高，因为不需要判断记录是否重复，也没有必须在结果庥是执行去除重复记录的操作。但是可以需要消耗更多的内存存储空间select * from Student where ClassId=2union allselect * from Student where ClassId=2--查询office这科目的全体学员的成绩，同时在最后显示它的平均分，最高分，最低分select ' '+cast(StudentNo as CHAR(3)),cast(SubjectId as CHAR(2)),StudentResult from Result where SubjectId=1unionselect '1','平均分',AVG(StudentResult) from Result where SubjectId=1unionselect '1','最高分',max(StudentResult) from Result where SubjectId=1unionselect '1','最低分',min(StudentResult) from Result where SubjectId=1--一次性插入多条数据--1.先将数据复制到另外一个新表中，删除源数据表，再将新表的数据插入到源数据表中--1.select */字段 into 新表 from 源表--1.新表是系统自动生成的，不能人为创建，如果新表名称已经存在就报错--2.新表的表结构与查询语句所获取的列一致，但是列的属性消失，只保留非空和标识列。其它全部消失，如主键，唯一键，关系，约束，默认值select * into newGrade from gradetruncate table gradeselect * from newGrade--select * into grade from newGrade--2.insert into 目标表 select 字段列表/* from 数据源表--1、目标表必须先存在，如果没有就报错--2.查询的数据必须符合目标表的数据完整性--3.查询的数据列的数量和类型必须的目标的列的数量和对象完全对应insert into grade select classname from newGradedelete from admin--使用union一次性插入多条记录--insert into 表(字段列表)--select 值。。。。 用户自定义数据--union--select 值 。。。。insert into Adminselect 'a','a'union allselect 'a','a'union allselect 'a','a'union allselect 'a',null CASE函数用法12345678910相当于switch case—c#中的switch…case只能做等值判断这可以对字段值或者表达式进行判断，返回一个用户自定义的值，它会生成一个新列2.要求then后面数据的类型一致1.第一种做等值判断的case..endcase 字段或者表达式when .值..then .自定义值when .值..then .自定义值…..else 如果不满足上面所有的when就满足这个elseend 1234567891011121314151617181920212223242526272829303132333435363738394041--显示具体班级的名称select StudentNo,StudentName,case ClassId --如果case后面接有表达式或者字段，那么这种结构就只能做等值判断，真的相当于switch..case when 1 then '一班' when 2 then '2班' when 3 then '3班' when null then 'aa' --不能判断null值 else '搞不清白'end,sex from Student--2.做范围判断，相当于if..else，它可以做null值判断--case --如果没有表达式或者字段就可实现范围判断-- when 表达式 then 值 --不要求表达式对同一字段进行判断-- when 表达式 then 值 -- .....--else 其它情况 --endselect StudentNo,StudentName,case when BornDate&gt;'2000-1-1' then '小屁孩' when BornDate&gt;'1990-1-1' then '小青年' when BornDate&gt;'1980-1-1' then '青年' --when Sex='女' then '是女的' when BornDate is null then '出生不详' else '中年'end from Student--百分制转换为素质教育 90 -A 80--B 70 --C 60 --D &lt;60 E NULL--没有参加考试select StudentNo,SubjectId,case when StudentResult&gt;=90 then 'A' when StudentResult&gt;=80 then 'B' when StudentResult&gt;=70 then 'C' when StudentResult&gt;=60 then 'D' when StudentResult is null then '没有参加考试' else 'E'end 成绩,ExamDate from Result IF ELSE语法12341,.没有｛｝，使用begin..end.如果后面只有一句，可以不使用begin..end包含2.没有bool值，只能使用关系运算符表达式3.也可以嵌套和多重4.if后面的（）可以省略 123456789101112131415declare @subjectname nvarchar(50)='office' --科目名称declare @subjectId int=(select Subjectid from Subject where SubjectName=@subjectname) --科目IDdeclare @avg int --平均分set @avg=(select AVG(StudentResult) from Result where SubjectId=@subjectId and StudentResult is not null) --获取平均分print @avgif @avg&gt;=60 begin print '成绩不错，输出前三名：' select top 3 * from Result where SubjectId=@subjectId order by StudentResult desc end else begin print '成绩不好，输出后三名：' select top 3 * from Result where SubjectId=@subjectId order by StudentResult end 子查询1234567子查询–一个查询中包含另外一个查询。被包含的查询就称为子查询，。包含它的查询就称父查询1.子查询的使用方式：使用（）包含子查询2.子查询分类：1.独立子查询：子查询可以直接独立运行查询比“王八”年龄小的学员信息select * from Student where BornDate&lt;(select BornDate from Student where StudentName=’王八’)2.相关子查询:子查询使用了父查询中的结果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152--子查询的三种使用方式--1.子查询做为条件,子查询接在关系运算符后面 &gt; &lt; &gt;= &lt;= = &lt;&gt; !=,如果是接这关系运算符后面，必须保证 子查询只返回一个值--查询六期班的学员信息select * from Student where ClassId=(select ClassId from grade where classname='八期班')--子查询返回的值不止一个。当子查询跟随在 =、!=、&lt;、&lt;=、&gt;、&gt;= 之后，或子查询用作表达式时，这种情况是不允许的。select * from Student where ClassId=(select ClassId from grade)--查询八期班以外的学员信息--当子查询返回多个值(多行一列),可以使用in来指定这个范围select * from Student where ClassId in(select ClassId from grade where classname&lt;&gt;'八期班')--当没有用 EXISTS 引入子查询时，在选择列表中只能指定一个表达式。如果是多行多列或者一行多列就需要使用exists--使用 EXISTS 关键字引入子查询后，子查询的作用就相当于进行存在测试。外部查询的 WHERE 子句测试子查询返回的行是否存在select * from Student where EXISTS(select * from grade)select * from Student where ClassId in(select * from grade)--2.子查询做为结果集--select top 5 * from Student --前五条--使用top分页select top 5 * from Student where StudentNo not in(select top 5 studentno from Student)--使用函数分页 ROW_NUMBER() over(order by studentno),可以生成行号,排序的原因是因为不同的排序方式获取的记录顺序不一样select ROW_NUMBER() over(order by studentno),* from Student--查询拥有新生成行号的结果集 注意:1.子查询必须的别名 2.必须为子查询中所有字段命名,也就意味着需要为新生成的行号列命名select * from (select ROW_NUMBER() over(order by studentno) id,* from Student) temp where temp.id&gt;0 and temp.id&lt;=5select * from (select ROW_NUMBER() over(order by studentno) id,* from Student) temp where temp.id&gt;5 and temp.id&lt;=10select * from (select ROW_NUMBER() over(order by studentno) id,* from Student) temp where temp.id&gt;10 and temp.id&lt;=15--3.子查询还可以做为列的值select (select studentname from student where studentno=result.studentno),(select subjectname from subject where subjectid=result.SubjectId), StudentResult from Result--使用Row_number over()实现分页--1.先写出有行号的结果集select ROW_NUMBER() over(order by studentno),* from Student--2.查询有行号的结果集 子查询做为结果集必须添加别名，子查询的列必须都有名称select * from (select ROW_NUMBER() over(order by studentno) id,* from Student) temp where id&gt;0 and id&lt;=5--查询年龄比“廖杨”大的学员，显示这些学员的信息select * from Student where BornDate&lt;(select BornDate from Student where StudentName='廖杨')--查询二期班开设的课程select * from Subject where ClassId=(select ClassId from grade where classname='二期班')--查询参加最近一次“office”考试成绩最高分和最低分--1查询出科目 IDselect subjectid from Subject where SubjectName='office'--2.查询出这一科目的考试日期select MAX(ExamDate) from Result where SubjectId=(select subjectid from Subject where SubjectName='office')--3,写出查询的框架select MAX(StudentResult),MIN(StudentResult) from Result where SubjectId=() and ExamDate=()--4.使用子查询做为条件select MAX(StudentResult),MIN(StudentResult) from Result where SubjectId=( select subjectid from Subject where SubjectName='office' ) and ExamDate=( select MAX(ExamDate) from Result where SubjectId=( select subjectid from Subject where SubjectName='office' ) ) 表连接Join12345--1.inner join :能够找到两个表中建立连接字段值相等的记录--查询学员信息显示班级名称select Student.StudentNo,Student.StudentName,grade.classnamefrom Studentinner join grade on Student.ClassId=grade.ClassId 12345--左连接: 关键字前面的表是左表，后面的表是右表--左连接可以得到左表所有数据，如果建立关联的字段值在右表中不存在，那么右表的数据就以null值替换select PhoneNum.*,PhoneType.*from PhoneNum left join PhoneType on PhoneNum.pTypeId=PhoneType.ptId 12345--右连接: 关键字前面的表是左表，后面的表是右表--右连接可以得到右表所有数据，如果建立关联的字段值在右左表中不存在，那么左表的数据就以null值替换select PhoneNum.*,PhoneType.*from PhoneNum right join PhoneType on PhoneNum.pTypeId=PhoneType.ptId 1234--full join :可以得到左右连接的综合结果--去重复select PhoneNum.*,PhoneType.*from PhoneNum full join PhoneType on PhoneNum.pTypeId=PhoneType.ptId 事务1234567891011121314一种处理机制。以事务处理的操作，要么都能成功执行，要么都不执行事务的四个特点 ACID：A:原子性：事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。它是一个整体，不能再拆分C：一致性：事务在完成时，必须使所有的数据都保持一致状态。。某种程度的一致I:隔离性：事务中隔离，每一个事务是单独的请求将单独的处理，与其它事务没有关系，互不影响D：持久性：如果事务一旦提交，就对数据的修改永久保留使用事务：将你需要操作的sql命令包含在事务中1.在事务的开启和事务的提交之间2.在事务的开启和事务的回滚之间三个关键语句：开启事务：begin transaction提交事务：commit transaction回滚事务：rollback transaction 1234567891011121314151617181920212223declare @num int =0 --记录操作过程中可能出现的错误号begin transaction update bank set cmoney=cmoney-500 where name='aa' set @num=@num+@@ERROR --说明这一句的执行有错误 但是不能在语句执行的过程中进行提交或者回滚 --语句块是一个整体，如果其中一句进行了提交或者回滚，那么后面的语句就不再属于当前事务， --事务不能控制后面的语句的执行 update bank set cmoney=cmoney+500 where name='bb' set @num=@num+@@ERROR select * from bank if(@num&lt;&gt;0 ) --这个@@ERROR只能得到最近一一条sql语句的错误号 begin print '操作过程中有错误，操作将回滚' rollback transaction end else begin print '操作成功' commit transaction end --事务一旦开启，就必须提交或者回滚 --事务如果有提交或者回滚，必须保证它已经开启 视图12345678视图就是一张虚拟表，可以像使用子查询做为结果集一样使用视图select * from vw_getinfo使用代码创建视图语法：create view vw_自定义名称as查询命令go 1234567891011121314151617--查询所有学员信息if exists(select * from sysobjects where name='vw_getAllStuInfo') drop view vw_getAllStuInfogo --上一个批处理结束的标记create view vw_getAllStuInfoas--可以通过聚合函数获取所以记录数 select top (select COUNT(*) from Student) Student.StudentNo,Student.StudentName,grade.ClassId,grade.classname from Studentinner join grade on Student.ClassId=grade.ClassId order by StudentName --视图中不能使用order by--select * from grade --只能创建一个查询语句--delete from grade where ClassId&gt;100 --在视图中不能包含增加删除修改go--使用视图。。就像使用表一样select * from vw_getAllStuInfo --对视图进行增加删除和修改操作--可以对视图进行增加删除和修改操作,只是建议不要这么做:所发可以看到：如果操作针对单个表就可以成功，但是如果 多张的数据就会报错：不可更新，因为修改会影响多个基表。update vw_getAllStuInfo set classname='asdas' ,studentname='aa' where studentno=1 触发器123456触发器:执行一个可以改变表数据的操作（增加删除和修改），会自动触发另外一系列（类似于存储过程中的模块）的操作。语法：create trigger tr_表名_操作名称on 表名 after|instead of 操作名称asgo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576if exists(select * from sysobjects where name='tr_grade_insert') drop trigger tr_grade_insertgocreate trigger tr_grade_inserton grade for insert ---为grade表创建名称为tr_grade_insert的触发器，在执行insert操作之后触发asdeclare @cnt int set @cnt = (select count(*) from student) select * ,@cnt from studentselect * from grade go--触发器不是被调用的，而是被某一个操作触 发的，意味着执行某一个操作就会自动触发 触发器insert into grade values('fasdfdssa')---替换触 发器：本来需要执行某一个操作，结果不做了，使用触 发器中的代码语句块进行替代if exists(select * from sysobjects where name='tr_grade_insert') drop trigger tr_grade_insertgocreate trigger tr_grade_inserton grade instead of insert ---为grade表创建名称为tr_grade_insert的触发器，在执行insert操作之后触发asdeclare @cnt int set @cnt = (select count(*) from student) select * ,@cnt from studentselect * from grade goinsert into grade values('aaaaaaaaaaaa')go---触 发器的两个临时表：--inserted: 操作之后的新表:所有新表与原始的物理表没有关系，只与当前操作的数据有关--deleted:操作之前的旧表：所有新表与原始的物理表没有关系，只与当前操作的数据有关if exists(select * from sysobjects where name='tr_grade_insert') drop trigger tr_grade_insertgocreate trigger tr_grade_inserton grade after insert as print '操作之前的表：操作之前，这一条记录还没有插入，所以没有数据' select * from deleted print '操作之后的表：已经成功插入一条记录，所有新表中有一条记录' select * from inserted go--测试：insert into grade values('aaaaa')if exists(select * from sysobjects where name='tr_grade_update') drop trigger tr_grade_updategocreate trigger tr_grade_updateon grade after update as print '操作之前的表：存储与这个修改操作相关的没有被修改之前的记录' select * from deleted print '操作之后的表：存储这个操作相关的被修改之后 记录' select * from inserted go--测试update grade set classname=classname+'aa' where ClassId&gt;15if exists(select * from sysobjects where name='tr_grade_delete') drop trigger tr_grade_deletegocreate trigger tr_grade_deleteon grade after delete as print '操作之前的表：存储与这个修改操作相关的没有被删除之前的记录' select * from deleted print '操作之后的表：存储这个操作相关的被删除之后 记录--没有记录' select * from inserted go--测试delete from grade where ClassId&gt;15 存储过程1234567891011存储过程就相当于c#中的方法参数，返回值，参数默认值，参数：值的方式调用在调用的时候有三个对应：类型对应，数量对应，顺序对应创建语法：create proc usp_用户自定义名称对应方法的形参 –(int age, out string name)as对应方法体:创建变量,逻辑语句,增加删除修改和查询..return返回值go调用语法：exec 存储过程名称 实参，实参，实参 … 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697--获取所有学员信息if exists(select * from sysobjects where name='usp_getAllStuInfo') drop proc usp_getAllStuInfo go create procedure usp_getAllStuInfoas select * from Studentgo --调用存储过程，获取的有学员信息execute usp_getAllStuInfo--exec sp_executesql 'select * from Student'--查询指定性别的学员信息goif exists(select * from sysobjects where name='usp_getAllStuInfoBySex') drop proc usp_getAllStuInfoBySex go create procedure usp_getAllStuInfoBySex @sex nchar(1) --性别 参数不需要declareas select * from Student where Sex=@sexgo--调用存储过程，获取指定性别的学员信息Exec usp_getAllStuInfoBySex '女'--创建存储过程获取指定班级和性别的学员信息goif exists(select * from sysobjects where name='usp_getAllStuInfoBySexandClassName') drop proc usp_getAllStuInfoBySexandClassName go create procedure usp_getAllStuInfoBySexandClassName @classname nvarchar(50), --班级名称 @sex nchar(1)='男'--性别 有默认的参数建议写在参数列表的最后as declare @classid int ---班级IDset @classid=(select classid from grade where classname=@classname) --通过参数班级名称获取对应的班级ID select * from Student where Sex=@sex and ClassId=@classidgo--执行存储过程获取指定班级和性别的学员信息--exec usp_getAllStuInfoBySexandClassName '八期班'exec usp_getAllStuInfoBySexandClassName default, '八期班' --有默认值的参数可以传递defaultexec usp_getAllStuInfoBySexandClassName @classname='八期班' --也可以通过参数=值的方式调用exec usp_getAllStuInfoBySexandClassName @classname='八期班' ,@sex='女'exec usp_getAllStuInfoBySexandClassName @classname='八期班',@sex='女'--创建存储过程,获取指定性别的学员人数及总人数goif exists(select * from sysobjects where name='usp_getCountBySexandClassName') drop proc usp_getCountBySexandClassName go create procedure usp_getCountBySexandClassName@cnt int=100 output, --output标记说明它是一个输出参数。output意味着你向服务器请求这个参数的值，那么在执行的时候，服务器发现这个参数标记了output，就会将这个参数的值返回输出@totalnum int =200output, --总人数@className nvarchar(50), --输入参数没有默认值，在调用的时候必须传入值@sex nchar(1)='男'--输入参数有默认值，用户可以选择是否传入值as declare @classid int ---班级ID set @classid=(select classid from grade where classname=@classname) --通过参数班级名称获取对应的班级ID select * from Student where Sex=@sex and ClassId=@classidset @cnt= (select COUNT(*) from Student where Sex=@sex and ClassId=@classid) --获取指定班级和性别的总人数set @totalnum=(select COUNT(*) from Student) ----获取总人数go--调用存储过程,获取指定性别的学员人数及总人数declare @num int,@tnum intexec usp_getCountBySexandClassName @cnt=@num output ,@totalnum=@tnum output , @className='八期班'print @numprint @tnumprint '做完了'---获取指定班级的人数if exists(select * from sysobjects where name='usp_getCount') drop proc usp_getCount go create procedure usp_getCount @className nvarchar(50)='八期班'asdeclare @classid int=(select classid from grade where classname=@className) declare @cnt intset @cnt =(select COUNT(*) from Student where ClassId=@classid) --return 只能返回int整数值--return '总人数是'+cast(@cnt as varchar(2))return @cnt go--调用存储过程，接收存储过程的返回值declare @count int--set @count=(exec usp_getCount)exec @count=usp_getCount '八期班'print @countif exists(select * from sysobjects where name='usp_getClassList') drop proc usp_getClassList go create procedure usp_getClassListas select classid,classname from gradego 分页存储过程1234567891011if exists(select * from sysobjects where name='usp_getPageData') drop proc usp_getPageData go create procedure usp_getPageData@totalPage int output,--总页数@pageIndex int =1 ,--当前页码，默认是第一页@pageCount int =5 --每一页显示的记录数asselect * from (select ROW_NUMBER() over(order by studentno) id,* from Student) temp where temp.id&gt;(@pageindex-1)*@pagecount and temp.id&lt;=(@pageindex*@pagecount)set @totalPage=CEILING((select COUNT(*) from Student)*1.0/@pageCount)go 索引1234567891011121314select * from sysindexes--create index IX_Student_studentName--on 表名(字段名)--clustered index:聚集索引 nonclustered index--非聚集索引if exists(select * from sysindexes where name='IX_Student_studentName') drop index student.IX_Student_studentNamego create clustered index IX_Student_studentNameon student(studentname)--如果是先创建主键再创建聚集索引就不可以，因为主键默认就是聚集索引--但是如果先创建聚集索引，那么还可以再创建主键，因为主键不一定需要是聚集的 临时表1234567891011121314151617181920212223242526--创建局部临时表create table #newGrade( classid int , classname nvarchar(50) )---局部临时表只有在当前创建它的会话中使用，离开这个会话临时表就失效.如果关闭创建它的会话，那么临时表就会消失insert into #newGrade select * from grade select * from #newGradeselect * into #newnewnew from gradeselect * into newGrade from #newgrade--创建全局临时表:只要不关闭当前会话，全局临时表都可以使用，但是关闭当前会话，全局临时表也会消失create table ##newGrade( classid int , classname nvarchar(50) )drop table ##newGradeselect * into ##newGrade from gradeselect * from ##newGrade--创建表变量declare @tb table(cid int,cname nvarchar(50))insert into @tb select * from gradeselect * from @tb]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL常用函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL笔记梳理]]></title>
    <url>%2F2017%2F05%2F20%2FSQL%E7%AC%94%E8%AE%B0%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"><![CDATA[什么是SQL语句sql语言：结构化的查询语言。（Structured Query Language），是关系数据库管理系统的标准语言。 它是一种解释语言：写一句执行一句，不需要整体编译执行。语法特点： 没有“ ”，字符串使用‘ ’包含 没有逻辑相等，赋值和逻辑相等都是= 类型不再是最严格的。任何数据都可以包含在‘ ’以内 没有bool值的概念，但是在视图中可以输入true/false 它也有关系运算符：&gt; &lt; &gt;= &lt;= = &lt;&gt; != ,它返回一个bool值 它也有逻辑运算符： ！(not) &amp;&amp;(and) ||(or) 它不区别大小写 使用sql语句创建数据库和表123456789101112131415161718语法：create database 数据库名称on primary –默认在主文件组上( name=’逻辑名称_data’ , –当你发现它不是一句完整的sql语句，而仅仅是一个处理结构中的某一句的时候，就需要添加 , size=初始大小,–数值不包含在‘’以内 filegrowth=文件增长 , maxsize=最大容量, filename=’物理路径’)log on( name=’逻辑名称_log’ , –当你发现它不是一句完整的sql语句，而仅仅是一个处理结构中的某一句的时候，就需要添加 , size=初始大小,–数值不包含在‘’以内 filegrowth=文件增长 , maxsize=最大容量, –一般来说日志文件不限制最大容量 filename=’物理路径’) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647--判断数据库文件是否已经存在 ：数据库的记录都存储在master库中的sysdatabases表中--自动切换当前数据库--使用代码开启外围应该配置器exec sp_configure &apos;show advanced options&apos; ,1RECONFIGUREexec sp_configure &apos;xp_cmdshell&apos;,1RECONFIGURE--自定义目录 xp_cmdshell可以创建出目录 &apos;mkdir f:\project&apos;：指定创建目录exec xp_cmdshell &apos;mkdir f:\project&apos;use master--exists 函数判断（）中的查询语句是否返回结果集，如果返回了结果集则得到true,否则得到falseif exists( select * from sysdatabases where name=&apos;School&apos;) drop database School --删除当前指定名称的数据库create database Schoolon primary( name=&apos;School_data&apos;,--逻辑名称.说明最多能够存储100mb数据，如果没有限制就可以将硬盘存储满 size=3mb,--初始大小 maxsize=100mb,--最大容量 filegrowth=10%,--文件增长一次增长10% filename=&apos;f:\project\School_data.mdf&apos; ),--创建文件组filegroup mygroup( name=&apos;School_data1&apos;,--逻辑名称.说明最多能够存储100mb数据，如果没有限制就可以将硬盘存储满 size=3mb,--初始大小 maxsize=100mb,--最大容量 filegrowth=10%,--文件增长一次增长10% filename=&apos;F:\qiyi\School_data1.ndf&apos; )log on( name=&apos;School_log&apos;,--逻辑名称 size=3mb,--初始大小 --maxsize=100mb,--最大容量 filegrowth=10%,--文件增长一次增长10% filename=&apos;f:\project\School_log.ldf&apos; ),( name=&apos;School_log1&apos;,--逻辑名称 size=3mb,--初始大小 --maxsize=100mb,--最大容量 filegrowth=10%,--文件增长一次增长10% filename=&apos;F:\qiyi\School_log1.ldf&apos; ) 创建数据表1234567语法：create table 表名( 字段名称 字段类型 字段特征(是否为null,默认值 标识列 主键 唯一键 外键 check约束), 字段名称 字段类型 字段特征(是否为null,默认值 标识列 主键 唯一键 外键 check约束))创建老师表Teacher :Id、Name、Gender、Age、Salary、Birthday 1234567891011121314151617181920use Schoolif exists(select * from sysobjects where name=&apos;Classes&apos;) drop table Classescreate table Classes( Classid int identity(1,1) primary key, ClassName nvarchar(50) not null )if exists(select * from sysobjects where name=&apos;teacher&apos;) drop table teachercreate table Teacher( Id int identity(1,1) primary key,--可以同时创建多个特征，用空格 分隔开。 identity是标识列，第一个参数是种子，第二个是增量 Name nvarchar(50) not null,-- not null标记它的值不能为null--不能不填写 ClassId int not null, Gender bit not null, Age int , Salary money, --如果不标记为 not null.那么就相当于标记了null Birthday datetime ) 数据完整性约束实体完整性：实体就是指一条记录。这种完整性就是为了保证每一条记录不是重复记录。是有意义的 主键：非空和唯一.一个表只有一个主键，但是一个主键可以是由多个字段组成的 组合键 标识列：系统自动生成，永远不重复 唯一键：唯一，但是可以为null,只能null一次 域完整性：域就是指字段，它是为了保证字段的值是准和有效，合理值 类型 是否null，默认值，check约束，关系 自定义完整性： check约束 ， 存储过程 触发器 引用完整性：一个表的某个字段的值是引用自另外一个表的某个字段的值。引用的表就是外键表，被引用的表就是主键表 建立引用的字段类型必须一致 建立引用的字段的意义一样 建立主外键关系的时候选择 外键表 去建立主外键关系 建立主外键关系的字段在主表中必须是主键或者唯一键 对于操作的影响 ： 在添加数据时，先添加主键表再添加外键表数据在删除的时候先外键表数据再删除主键表数据 1234主键约束（PK Primary key） 唯一键约束(UQ unique) 外键约束(FK foreign key) 默认值约束(DF default) check约束(CK check)语法：alter table 表名add constraint 前缀_约束名称 约束类型 约束说明（字段 关系表达式 值) 1234567891011121314151617181920212223242526use Schoolif exists(select * from sysobjects where name='PK_Classes_Classid')alter table classes drop constraint PK_Classes_Classidalter table classes add constraint PK_Classes_Classid primary key(classid)--为id添加主键alter table teacher add constraint PK_teacher_id primary key(id)--为name添加唯一键alter table teacheradd constraint UQ_Teacher_Name unique(Name)--同时创建salary的默认约束和age的check约束alter table teacheradd constraint DF_Teacher_Salary default(5000) for salary,constraint CK_Teacher_Age check(age&gt;0 and age&lt;=100)--为teacher表的classid字段创建主外键if exists(select * from sysobjects where name='FK_Teacher_Classes_Classid') alter table teacher drop constraint FK_Teacher_Classes_Classidalter table teacherwith nocheck --不检查现有数据add constraint FK_Teacher_Classes_Classid foreign key(classid) references classes(classid)--on delete set default 级联操作--不执行任何操作：该报错就报错，该删除就删除 --no action --默认选择--级联：删除主表记录，从表引用该值的记录也被删除 --cascade--设置null:删除主表记录，从表对应的字段值设置为null,前提是可以为null --set null--设置为default:删除主表记录，从表对应的字段值设置为default,前提是可以为default --set default 四中基本字符类型说明123456789101112131415161718--len(参数) --获取指定参数内容的字符个数select LEN('abcd') 【4】运行结果select LEN('中华人民共和国') 【7】--DataLength(参数)：获取指定内占据的字节数--空间大小select DataLength('abcd') 【4】select DataLength('中华人民共和国') 【14】--char类型：当空间分配后，不会因为存储的内容比分配的空间小就回收分配的空间。但是如果存储的内容超出了指定的空间大小，就会报错，当你存储的内容的长度变化区间不大的时候可以考虑使用charselect LEN(char) from CharTest 【2】select DataLength(char) from CharTest 【10】--varchar var--变化的：当你存储的内容小于分配的空间的时候，多余的空间会自动收缩。但是如果存储的内容超出了指定的空间大小，就会报错 当存储的内容波动区间比较大时候使用varcharselect LEN(varchar) from CharTest 【2】select DataLength(varchar) from CharTest 【2】--nchar-- n代表它是一个unicode字符。规定不管什么样的字符都占据两个字节。 char:空间是固定的select LEN(nchar) from CharTest 【10】select DataLength(nchar) from CharTest 【20】--nvarchar n var char select LEN(nvarchar) from CharTest 【2】select DataLength(nvarchar) from CharTest 【4】 SQL基本语句123456数据插入调用方法 一 一对应原则：类型对应，数量对应，顺序对应语法： 形参 实参insert into 表名([字段列表]) values(值列表) –数据必须要符合数据完整性插入操作是单个表的操作插入操作insert一次只能插入一条记录 123456789101112131415161718192021222324252627use School--插入teacher所有字段的数据.如果在表后没有指定需要插入的字段名称，那么就默认为所有字段添加值--但是一定需要注意的是：标识列永远不能自定义值--不能人为插入值--仅当使用了列列表并且 IDENTITY_INSERT 为 ON 时，才能为表'Teacher'中的标识列指定显式值。insert into Teacher values('张三',5,1,30,4000,'1984-9-11')insert into Teacher(Name,ClassId,Gender,Age,Salary,Birthday) values('张三',5,1,30,4000,'1984-9-11')--不为可以为null的字段插入值 :可以null的字段可以不赋值 --列名或所提供值的数目与表定义不匹配insert into Teacher(Name,ClassId,Gender,Age,Salary) values('李四',5,1,30,4000)--非空字段一定需要赋值 ：不能将值 NULL 插入列 'Gender'，表 'School.dbo.Teacher'；列不允许有 Null 值。INSERT 失败insert into Teacher(Name,ClassId,Age,Salary) values('李四',5,30,4000)--为有默认值的字段插入值：--1.不写这一列让系统自动赋值insert into Teacher(Name,ClassId,Gender,Age) values('王五',5,1,30)--指定 null或者defaultinsert into Teacher(Name,ClassId,Gender,Age,Salary,Birthday) values('赵六',5,1,30,default,null)--数据必须完全符合表的完整性约束insert into Teacher(Name,ClassId,Gender,Age,Salary,Birthday) values('赵六1',5,1,300,default,null)--任意类型的数据都可以包含在''以内, 不包括关键字insert into Teacher(Name,ClassId,Gender,Age,Salary,Birthday) values('马鹏飞','5','0','15',default,null)--但是字符串值如果没有包含在''以内.会报错 列名 '兰鹏' 无效。insert into Teacher(Name,ClassId,Gender,Age,Salary,Birthday) values('兰鹏','5','0','15',default,null)--但是数值组成的字符串可以不使用''包含insert into Teacher(Name,ClassId,Gender,Age,Salary,Birthday) values(123,'5','0','15',default,null)--日期值必须包含在’‘以内，否则就是默认值insert into Teacher(Name,ClassId,Gender,Age,Salary,Birthday) values('邹元标2','5','0','15',default,'1991-9-11') 123数据删除语法:delete [from] 表名 where 条件 12345678910111213delete from Teacher where Age&lt;20--特点:--1.删除是一条一条进行删除的--2.每一条记录的删除都需要将操作写入到日志文件中--3.标识列不会从种子值重新计算,以从上次最后一条标识列值往下计算--4.这种删除可以触发delete触发器--truncate table 表名 --没有条件，它是一次性删除所有数据--特点：--1.一次性删除所有数据，没有条件，那么日志文件只以最小化的数据写入--2.它可以使用标识列从种子值重新计算--3.它不能触发delete触发器truncate table teacher 123数据更新(数据修改)：一定需要考虑是否有条件语法:update 表名 set 字段=值，字段=值 。。where 条件 1234567update Teacher set Gender='true'--修改时添加条件update Teacher set Gender=0 where Id=20--多字段修改update Teacher set ClassId=4,Age+=5,Salary=5000 where Id=22--修改班级id=4，同时年龄》20岁的人员工资+500update Teacher set Salary=Salary+500 where ClassId=4 and Age&gt;20 123数据检索–查询语法： *代表所有字段select */字段名称列表 from 表列表 12345select StudentNo,StudentName,Sex,[Address] from Student--可以为标题设置 别名，别名可以是中文别名select StudentNo as 学号,StudentName 姓名,性别=Sex,[Address] from Student--添加常量列select StudentNo as 学号,StudentName 姓名,性别=Sex,[Address] ,国籍='中华人民共和国' from Student select的作用12345678910111213141516171819202122--select的作用--1.查询--2.输出select 1+1--+是运算符,系统会自动为你做类型转换select 1+'1'select '1'+1--如果+两边都是字符串,那么它就是一字符串连接符select '1'+'1'select 'a'+1--可以输出多列值select 1,2,34,3,545,67,567,6,7--Top、Distinctselect * from Student--top可以获取指定的记录数,值可以大于总记录数.但是不能是负值select top 100 * from Student--百分比是取ceiling()select top 10 percent * from Student--重复记录与原始的数据表数据无关,只与你查询的结果集有关系 distinct可以去除结果集中的重复记录--结果集中每一列的值都一样select distinct LoginPwd,Sex,Email from Studentselect distinct Sex from Student 聚合函数12345678910111213141516171819202122232425262728293031323334353637--聚合函数：--1.对null过滤--2.都需要有一个参数--3.都是返回一个数值--sum()：求和:只能对数值而言,对字符串和日期无效--avg()：求平均值--count()：计数：得到满足条件的记录数--max()：求最大值:可以对任意类型的数据进行聚合，如果是字符串就比较拼音字母进行排序--min()：求最小值--获取学员总人数select COUNT(*) from Student--查询最大年龄值select MIN(BornDate) from Studentselect max(BornDate) from Student--查询总分select SUM(StudentResult) from Result where StudentNo=2--平均分select avg(StudentResult) from Result where SubjectId=1--注意细节：select SUM(StudentName) from Studentselect SUM(BornDate) from Studentselect min(StudentName) from Studentselect max(StudentName) from Student--查询学号，姓名，性别，年龄，电话，地址 ---查询女生select StudentNo,StudentName,Sex,BornDate,Address from Student where Sex='女' and BornDate &gt;'1990-1-1' and Address='广州'--指定区间范围select StudentNo,StudentName,Sex,BornDate,Address from Student where BornDate &gt;='1990-1-1' and BornDate&lt;='1993-1-1'--between...and &gt;= &lt;=select StudentNo,StudentName,Sex,BornDate,Address from Student where BornDate between '1990-1-1' and '1993-1-1'--查询班级id 1 3 5 7的学员信息select * from Student where ClassId=1 or ClassId=3 or ClassId=5 or ClassId=7--指定具体的取值范围--可以是任意类型的范围.值的类型需要一致--可以相互转换select * from Student where ClassId in(1,3,'5',7)select * from Student where ClassId not in(1,3,'5',7) 模糊查询12345678910111213141516171819202122232425--带条件的查询-模糊查询-- 只针对字符串而言--查询 姓 林 的女生信息--=是一种精确查询，需要完全匹配select * from Student where Sex='女' and StudentName='林'--通配符--元字符--%：任意个任意字段 window:* 正则表达式 ：.*--_:任意的单个字符--[]:代表一个指定的范围，范围可以是连续也可以是间断的。与正则表达式完全一样[0-9a-zA-Z].可以从这个范围中取一个字符--[^]:取反值select * from Student where Sex='女' and StudentName='林%'--通配符必须在模糊查询关键的中才可以做为通配符使用，否则就是普通字符--like 像 。。。。一样select * from Student where Sex='女' and StudentName like '林%'select * from Student where Sex='女' and StudentName like '林_'--[]的使用 学号在11~15之间的学员信息select * from Student where StudentNo like '[13579]'---处理null值--null:不是地址没有分配,而是不知道你需要存储什么值 所以null是指 不知道。但是=只能匹配具体的值，而null根本就不是一个值select COUNT(email) from Student where Email !=null (错误)select COUNT(email) from Student where Email is nullselect count(email) from Student where Email is not null--将null值替换为指定的字符串值select StudentName,ISNULL(Email,'没有填写电子邮箱') from Student where ClassId=2 分组统计123456789101112131415--当你看到 每一个，，各自，不同，，分别 需要考虑分组--查询每一个班级的男生人数--与聚合函数一起出现在查询中的列，要么也被聚合，要么被分组select classid,Sex,COUNT(*) from Student where Sex='男' group by ClassId,sex--查询每一个班级的总人数,显示人数&gt;=2的信息--1.聚合不应出现在 WHERE 子句中--语法错误select ClassId ,COUNT(*) as num from Student where Email is not null GROUP by ClassId having COUNT(*)&gt;=2 order by num desc--完整的sql查询家庭 --select 字段列表 from 表列表 where 数据源做筛选 group by 分组字段列表 having 分组结果集做筛选 Order by 对结果集做记录重排select ClassId ,COUNT(*) as num from Student where Email is not null GROUP by ClassId order by ClassId desc--关于top的执行顺序 排序之后再取top值select top 1 ClassId ,COUNT(*) as num from Student GROUP by ClassId order by num desc]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery常用函数总结]]></title>
    <url>%2F2017%2F05%2F13%2FjQuery%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[jQuery常用函数总结这篇文章主要介绍了jQuery自带的一些常用方法总结,包括$.trim 、$.contains、$.each、$.map、$.inArray、$.extend等,需要的朋友可以参考下 常用工具方法（1）$.trim $.trim方法用于移除字符串头部和尾部多余的空格。复制代码 代码如下: 1$.trim(' Hello ') // Hello （2）$.contains $.contains方法返回一个布尔值，表示某个DOM元素（第二个参数）是否为另一个DOM元素（第一个参数）的下级元素。复制代码 代码如下: 1234$.contains(document.documentElement, document.body); // true$.contains(document.body, document.documentElement); // false （3）$.each， $.map $.each方法用于遍历数组和对象，然后返回原始对象。它接受两个参数，分别是数据集合和回调函数。复制代码 代码如下: 1234567891011121314$.each([ 52, 97 ], function( index, value ) &#123; console.log( index + ": " + value );&#125;);// 0: 52 // 1: 97 var obj = &#123; p1: "hello", p2: "world"&#125;;$.each( obj, function( key, value ) &#123; console.log( key + ": " + value );&#125;);// p1: hello// p2: world 需要注意的，jQuery对象实例也有一个each方法（$.fn.each），两者的作用差不多。$.map方法也是用来遍历数组和对象，但是会返回一个新对象。复制代码 代码如下: 123456var a = ["a", "b", "c", "d", "e"];a = $.map(a, function (n, i)&#123; return (n.toUpperCase() + i);&#125;);console.log(a);// ["A0", "B1", "C2", "D3", "E4"] （4）$.inArray $.inArray方法返回一个值在数组中的位置（从0开始）。如果该值不在数组中，则返回-1。复制代码 代码如下: 12var a = [1,2,3,4];$.inArray(4,a) // 3 （5）$.extend $.extend方法用于将多个对象合并进第一个对象。复制代码 代码如下: 1234var o1 = &#123;p1:'a',p2:'b'&#125;;var o2 = &#123;p1:'c'&#125;;$.extend(o1,o2);o1.p1 // "c" $.extend的另一种用法是生成一个新对象，用来继承原有对象。这时，它的第一个参数应该是一个空对象。复制代码 代码如下: 12345var o1 = &#123;p1:'a',p2:'b'&#125;;var o2 = &#123;p1:'c'&#125;;var o = $.extend(&#123;&#125;,o1,o2);o// Object &#123;p1: "c", p2: "b"&#125; 默认情况下，extend方法生成的对象是“浅拷贝”，也就是说，如果某个属性是对象或数组，那么只会生成指向这个对象或数组的指针，而不会复制值。如果想要“深拷贝”，可以在extend方法的第一个参数传入布尔值true。复制代码 代码如下: 123456var o1 = &#123;p1:['a','b']&#125;;var o2 = $.extend(&#123;&#125;,o1);var o3 = $.extend(true,&#123;&#125;,o1); // 深拷贝 复制值o1.p1[0]='c'; // 赋值o2.p1 // ["c", "b"] 浅拷贝 指针 没有复制值o3.p1 // ["a", "b"] 深拷贝 复制的值 上面代码中，o2是浅拷贝，o3是深拷贝。结果，改变原始数组的属性，o2会跟着一起变，而o3不会。 （6）$.proxy $.proxy方法类似于ECMAScript 5的bind方法，可以绑定函数的上下文（也就是this对象）和参数，返回一个新函数。jQuery.proxy()的主要用处是为回调函数绑定上下文对象。复制代码 代码如下: 123456789var o = &#123; type: "object", test: function(event) &#123; console.log(this.type); &#125;&#125;;$("#button") .on("click", o.test) // 无输出 .on("click", $.proxy(o.test, o)) // object 上面的代码中，第一个回调函数没有绑定上下文，所以结果为空，没有任何输出；第二个回调函数将上下文绑定为对象o，结果就为object。这个例子的另一种等价的写法是：复制代码 代码如下: 1$("#button").on( "click", $.proxy(o, test)) 上面代码的$.proxy(o, test)的意思是，将o的方法test与o绑定。这个例子表明，proxy方法的写法主要有两种。复制代码 代码如下: 123jQuery.proxy(function, context)// orjQuery.proxy(context, name) 第一种写法是为函数（function）指定上下文对象（context），第二种写法是指定上下文对象（context）和它的某个方法名（name）。再看一个例子。正常情况下，下面代码中的this对象指向发生click事件的DOM对象。复制代码 代码如下: 123$('#myElement').click(function() &#123; $(this).addClass('aNewClass');&#125;); 如果我们想让回调函数延迟运行，使用setTimeout方法，代码就会出错，因为setTimeout使得回调函数在全局环境运行，this将指向全局对象。复制代码 代码如下: 12345$('#myElement').click(function() &#123; setTimeout(function() &#123; $(this).addClass('aNewClass'); &#125;, 1000);&#125;); 上面代码中的this，将指向全局对象window，导致出错。这时，就可以用proxy方法，将this对象绑定到myElement对象。复制代码 代码如下: 12345$('#myElement').click(function() &#123; setTimeout($.proxy(function() &#123; $(this).addClass('aNewClass'); &#125;, this), 1000);&#125;); （7）$.data，$.removeData$.data方法可以用来在DOM节点上储存数据。复制代码 代码如下: 123456// 存入数据$.data(document.body, "foo", 52 );// 读取数据$.data(document.body, "foo");// 读取所有数据$.data(document.body); 上面代码在网页元素body上储存了一个键值对，键名为“foo”，键值为52。 $.removeData方法用于移除.data方法所储存的数据。复制代码 代码如下: 12$.data(div, "test1", "VALUE-1");$.removeData(div, "test1"); （8）$.parseHTML，$.parseJSON，.parseXML $.parseHTML方法用于将字符串解析为DOM对象。$.parseJSON方法用于将JSON字符串解析为JavaScript对象，作用与原生的JSON.parse()类似。但是，jQuery没有提供类似JSON.stringify()的方法，即不提供将JavaScript对象转为JSON对象的方法。$.parseXML方法用于将字符串解析为XML对象。复制代码 代码如下: 1234var html = $.parseHTML("hello, &lt;b&gt;my name is&lt;/b&gt; jQuery.");var obj = $.parseJSON('&#123;"name": "John"&#125;');var xml = "&lt;rss version='2.0'&gt;&lt;channel&gt;&lt;title&gt;RSS Title&lt;/title&gt;&lt;/channel&gt;&lt;/rss&gt;";var xmlDoc = $.parseXML(xml); （9）$.makeArray$.makeArray方法将一个类似数组的对象，转化为真正的数组。复制代码 代码如下: 1var a = $.makeArray(document.getElementsByTagName("div")); （10）$.merge $.merge方法用于将一个数组（第二个参数）合并到另一个数组（第一个参数）之中。复制代码 代码如下: 12345var a1 = [0,1,2];var a2 = [2,3,4];$.merge(a1, a2);a1// [0, 1, 2, 2, 3, 4] （11）$.now $.now方法返回当前时间距离1970年1月1日00:00:00 UTC对应的毫秒数，等同于(new Date).getTime()。复制代码 代码如下: 12$.now()// 1388212221489 （12）判断数据类型的方法jQuery提供一系列工具方法，用来判断数据类型，以弥补JavaScript原生的typeof运算符的不足。以下方法对参数进行判断，返回一个布尔值。jQuery.isArray()：是否为数组。jQuery.isEmptyObject()：是否为空对象（不含可枚举的属性）。jQuery.isFunction()：是否为函数。jQuery.isNumeric()：是否为数组。jQuery.isPlainObject()：是否为使用“{}”或“new Object”生成的对象，而不是浏览器原生提供的对象。jQuery.isWindow()：是否为window对象。jQuery.isXMLDoc()：判断一个DOM节点是否处于XML文档之中。下面是一些例子。复制代码 代码如下: 1234$.isEmptyObject(&#123;&#125;) // true$.isPlainObject(document.location) // false$.isWindow(window) // true$.isXMLDoc(document.body) // false 除了上面这些方法以外，还有一个$.type方法，可以返回一个变量的数据类型。它的实质是用Object.prototype.toString方法读取对象内部的[[Class]]属性（参见《标准库》的Object对象一节）。复制代码 代码如下: 1$.type(/test/) // "regexp" （13）Ajax操作 $.ajaxjQuery对象上面还定义了Ajax方法（$.ajax()），用来处理Ajax操作。调用该方法后，浏览器就会向服务器发出一个HTTP请求。$.ajax()的用法有多种，最常见的是提供一个对象参数。复制代码 代码如下: 1234567891011121314151617181920$.ajax(&#123; async: true, url: '/url/to/json', type: 'GET', data : &#123; id : 123 &#125;, dataType: 'json', timeout: 30000, success: successCallback, error: errorCallback, complete: completeCallback&#125;)function successCallback(json) &#123; $('&lt;h1/&gt;').text(json.title).appendTo('body');&#125;function errorCallback(xhr, status)&#123; console.log('出问题了！');&#125;function completeCallback(xhr, status)&#123; console.log('Ajax请求已结束。');&#125; 上面代码的对象参数有多个属性，含义如下：async：该项默认为true，如果设为false，则表示发出的是同步请求。cache: 该项默认为true，如果设为false，则浏览器不缓存返回服务器返回的数据。注意，浏览器本身就不会缓存POST请求返回的数据，所以即使设为false，也只对HEAD和GET请求有效。url：服务器端网址。这是唯一必需的一个属性，其他属性都可以省略。type：向服务器发送信息所使用的HTTP动词，默认为GET，其他动词有POST、PUT、DELETE。dataType：向服务器请求的数据类型，可以设为text、html、script、json、jsonp和xml。data：向服务器发送的数据，如果使用GET方法，此项将转为查询字符串，附在网址的最后。success：请求成功时的回调函数，函数参数为服务器传回的数据、状态信息、发出请求的原始对象。timeout: 等待的最长毫秒数。如果过了这个时间，请求还没有返回，则自动将请求状态改为失败。error：请求失败时的回调函数，函数参数为发出请求的原始对象以及返回的状态信息。complete：不管请求成功或失败，都会执行的回调函数，函数参数为发出请求的原始对象以及返回的状态信息。这些参数之中，url可以独立出来，作为ajax方法的第一个参数。也就是说，上面代码还可以写成下面这样。复制代码 代码如下: 123456$.ajax('/url/to/json',&#123; type: 'GET', dataType: 'json', success: successCallback, error: errorCallback&#125;) 简便写法ajax方法还有一些简便写法。$.get()：发出GET请求。$.getScript()：读取一个JavaScript脚本文件并执行。$.getJSON()：发出GET请求，读取一个JSON文件。$.post()：发出POST请求。$.fn.load()：读取一个html文件，并将其放入当前元素之中。一般来说，这些简便方法依次接受三个参数：url、数据、成功时的回调函数。 （1）$.get()，$.post() 这两个方法分别对应HTTP的GET方法和POST方法。复制代码 代码如下: 123456$.get('/data/people.html', function(html)&#123; $('#target').html(html);&#125;);$.post('/data/save', &#123;name: 'Rebecca'&#125;, function (resp)&#123; console.log(JSON.parse(resp));&#125;); get方法接受两个参数，分别为服务器端网址和请求成功后的回调函数。post方法在这两个参数中间，还有一个参数，表示发给服务器的数据。上面的post方法对应的ajax写法如下。复制代码 代码如下: 123456789$.ajax(&#123; type: 'POST', url: '/data/save', data: &#123;name: 'Rebecca'&#125;, dataType: 'json', success: function (resp)&#123; console.log(JSON.parse(resp)); &#125;&#125;); （2）$.getJSON() ajax方法的另一个简便写法是getJSON方法。当服务器端返回JSON格式的数据，可以用这个方法代替$.ajax方法。复制代码 代码如下: 123$.getJSON('url/to/json', &#123;'a': 1&#125;, function(data)&#123; console.log(data);&#125;); 上面的代码等同于下面的写法。复制代码 代码如下: 12345678$.ajax(&#123; dataType: "json", url: '/url/to/data', data: &#123;'a': 1&#125;, success: function(data)&#123; console.log(data); &#125;&#125;); （3）$.getScript()$.getScript方法用于从服务器端加载一个脚本文件。复制代码 代码如下: 123$.getScript('/static/js/myScript.js', function() &#123; functionFromMyScript();&#125;); 上面代码先从服务器加载myScript.js脚本，然后在回调函数中执行该脚本提供的函数。getScript的回调函数接受三个参数，分别是脚本文件的内容，HTTP响应的状态信息和ajax对象实例。复制代码 代码如下: 12345$.getScript( "ajax/test.js", function (data, textStatus, jqxhr)&#123; console.log( data ); // test.js的内容 console.log( textStatus ); // Success console.log( jqxhr.status ); // 200&#125;); getScript是ajax方法的简便写法，因此返回的是一个deferred对象，可以使用deferred接口。复制代码 代码如下: 1234567jQuery.getScript("/path/to/myscript.js") .done(function() &#123; // ... &#125;) .fail(function() &#123; // ...&#125;); （4）$.fn.load() $.fn.load不是jQuery的工具方法，而是定义在jQuery对象实例上的方法，用于获取服务器端的HTML文件，将其放入当前元素。由于该方法也属于ajax操作，所以放在这里一起讲。复制代码 代码如下: 1$('#newContent').load('/foo.html'); $.fn.load方法还可以指定一个选择器，将远程文件中匹配选择器的部分，放入当前元素，并指定操作完成时的回调函数。复制代码 代码如下: 1234$('#newContent').load('/foo.html #myDiv h1:first', function(html) &#123; console.log('内容更新！');&#125;); 上面代码只加载foo.html中匹配“#myDiv h1:first”的部分，加载完成后会运行指定的回调函数。Ajax事件jQuery提供以下一些方法，用于指定特定的AJAX事件的回调函数。.ajaxComplete()：ajax请求完成。.ajaxError()：ajax请求出错。.ajaxSend()：ajax请求发出之前。.ajaxStart()：第一个ajax请求开始发出，即没有还未完成ajax请求。.ajaxStop()：所有ajax请求完成之后。.ajaxSuccess()：ajax请求成功之后。下面是示例。复制代码 代码如下: 123$('#loading_indicator').ajaxStart(function ()&#123;$(this).show();&#125;).ajaxStop(function ()&#123;$(this).hide();&#125;); 返回值ajax方法返回的是一个deferred对象，可以用then方法为该对象指定回调函数（详细解释参见《deferred对象》一节）。复制代码 代码如下: 123456$.ajax(&#123; url: '/data/people.json', dataType: 'json'&#125;).then(function (resp)&#123; console.log(resp.people);&#125;) JSONP由于浏览器存在“同域限制”，ajax方法只能向当前网页所在的域名发出HTTP请求。但是，通过在当前网页中插入script元素（\），可以向不同的域名发出GET请求，这种变通方法叫做JSONP（JSON with Padding）。ajax方法可以发出JSONP请求，方法是在对象参数中指定dataType为JSONP。复制代码 代码如下: 12345678$.ajax(&#123; url: '/data/search.jsonp', data: &#123;q: 'a'&#125;, dataType: 'jsonp', success: function(resp) &#123; $('#target').html('Results: ' + resp.results.length); &#125;&#125;); JSONP的通常做法是，在所要请求的URL后面加在回调函数的名称。ajax方法规定，如果所请求的网址以类似“callback=?”的形式结尾，则自动采用JSONP形式。所以，上面的代码还可以写成下面这样。复制代码 代码如下: 12345$.getJSON('/data/search.jsonp?q=a&amp;callback=?', function(resp) &#123; $('#target').html('Results: ' + resp.results.length); &#125;);]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>函数</tag>
        <tag>jQuery</tag>
        <tag>选择器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery常用语法]]></title>
    <url>%2F2017%2F05%2F13%2FjQuery%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[基础语法：$(selector).action() 美元符号定义 jQuery $ 选择符（selector）“查询”和“查找” HTML 元素 jQuery 的 action() 执行对元素的操作 示例： 1234$(this).hide() - 隐藏当前元素$("p").hide() - 隐藏所有段落$("p.test").hide() - 隐藏所有 class="test" 的段落$("#test").hide() - 隐藏所有 id="test" 的元素 选择器-by prop： jQuery 使用 XPath 表达式来选择带有给定属性的元素。 示例： 1234$("[href]") 选取所有带有 href 属性的元素。 $("[href='#']") 选取所有带有 href 值等于 "#" 的元素。$("[href!='#']") 选取所有带有 href 值不等于 "#" 的元素。$("[href$='.jpg']") 选取所有 href 值以 ".jpg" 结尾的元素。 选择器-css： jQuery CSS 选择器可用于改变 HTML 元素的 CSS 属性。 示例： 1$("p").css("background-color","red"); 事件： 基于事件，我们可以做许多事情。 示例： 123$(document).ready(function)$(selector).click(function)$(selector).focus(function) jQuery与html： jQuery 提供一系列与 DOM 相关的方法，这使访问和操作元素和属性变得很容易。 三个简单实用的用于 DOM 操作的 jQuery 方法，get – set： 12345$(selector).text() -- text("")$(selector).html() -- html("")$(selector).val() -- html("") $(selector).attr("") -- attr("", "")/* 等同于，获name来找，$("input[name='whichName']").val()，对它重新赋值$("input[name='whichName']").val(oldTopic); */ jQuery-GET： $.get(“yourUrl”, function(data, status){}); 其中，data是controller里这样写回的response.write(“”) /modelMap带回 示例： 12345$("button").click(function()&#123; $.get("demo_test.asp",function(data,status)&#123; alert("Data: " + data + "\nStatus: " + status); &#125;);&#125;); jQuery-POST： $.post(URL,data,callback); 其中，data是controller里这样写回的response.write(“”) /modelMap带回 示例： 12345678910$("button").click(function()&#123; $.post("demo_test_post.asp", &#123; name:"Donald Duck", city:"Duckburg" &#125;, function(data,status)&#123; alert("Data: " + data + "\nStatus: " + status); &#125;);&#125;); jQuery-遍历：1$(selector).each(function(index,element)) 示例： 12345$("table").find("tr").each(function()&#123; $(this).find("td").each(function()&#123; alert($(this).text()); &#125;);&#125;); 常用方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;script&gt; /** elementName标识的页面元素的值，是否为空. */ function isNULL(elementname)&#123; if($("input[name=" + elementname + "]").val() == "")&#123; return true; &#125; return false; &#125; /** elementName标识的页面元素的值，是否超时limitedLength. */ function exceedLimitedLength(elementname, limitedLength)&#123; if($("input[name=" + elementname + "]").val().length &gt; limitedLength)&#123; return true; &#125; return false; &#125; /** elementName标识的页面元素的值，是否为数字. */ function isNum(elementname)&#123; return isNaN($("input[name=" + elementname + "]").val()); &#125; /** 光标显示在elementname标识的元素内. */ function focus(elementname)&#123; $("input[name=" + elementname + "]").focus(); &#125; /** elementname标识的页面元素是否为数字，如果不是，那么光标标在那里，并且提示用户. */ function isNumber(elementname)&#123; if(isNum(elementname))&#123; focus(elementname); alert(elementname + "必须为数字"); return false; &#125; return true; &#125; /** elementname标识的页面元素的值，是否包含了中文. */ function containsChinese(elementname)&#123; var str = $("input[name=" + elementname + "]").val(); if(escape(str).indexOf("%u")&gt;=0)&#123; return true; &#125; return false; &#125; /** elementname标识的页面元素的值，是否只包括字母、数字、中划线和下划线. */ function containsOnlyLettersNumberAndTwoDash(elementname)&#123; var str = $("input[name=" + elementname + "]").val(); var patten = new RegExp(/^[a-zA-Z0-9\_\-]+$/); return patten.test(str); &#125; /** elementname标识的页面元素的值，是否满足这些约束：不为空、 长度&lt;limitedLength、不包含中文、只包含字母数字中划下划. */ function satisfyAllConstraints(elementname, limitedLength)&#123; if(isNULL(elementname))&#123; focus(elementname); alert(elementname + "不可为空"); return false; &#125; if(exceedLimitedLength(elementname, limitedLength))&#123; focus(elementname); alert(elementname + "超过长度限制" + limitedLength); return false; &#125; if(containsChinese(elementname))&#123; focus(elementname); alert(elementname + "不支持中文"); return false; &#125; // 注意！ if(!containsOnlyLettersNumberAndTwoDash(elementname))&#123; focus(elementname); alert(elementname + "仅支持字母、数字、中划线-、下滑线_"); return false; &#125; return true; &#125;&lt;/script&gt; 判断字符串开头、结尾，正则表达式：12345678var str = "xxx.xml.bak";if (str.match("^xxx")) &#123; alert("xxx starts");&#125;if (str.match("xml$")) &#123; alert("xml ends");&#125;]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>事件</tag>
        <tag>jQuery</tag>
        <tag>jQuery常用语法</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[苹果味喜欢的音乐]]></title>
    <url>%2F2017%2F05%2F13%2F%E8%8B%B9%E6%9E%9C%E5%91%B3%E5%96%9C%E6%AC%A2%E7%9A%84%E9%9F%B3%E4%B9%90%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript数组及JSON操作]]></title>
    <url>%2F2017%2F05%2F13%2FJavaScript%E6%95%B0%E7%BB%84%E5%8F%8AJSON%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[JavaScript数组及JSON操作javascript删除数组的3种方法1.用shift()方法shift：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined 123var myArray=[2,34,56,32,12,9];var a=myArray.shift(); // 得到2console.log(myArray); // [34,56,,32,12,9] 2.用pop()方法pop：删除原数组最后一项，并返回删除元素的值；如果数组为空则返回undefined 123var myArray=[2,34,56,32,12,9];var a=myArray.pop(); // 得到9console.log(myArray); // [2,34,56,,32,12] 前面的方法只能操作数组开头和结尾，无法操作中间项，如果要操作中间的项，使用splice方法 3.用splice方法这个方法很强大，可以对数组任意项进行增加，删除，替换操作 删除操作123var myArray=[2,34,56,32,12,9];var a=myArray.splice(2,1); // 得到56console.log(myArray); // [2,34,32,12,9] 上面例子中，把myArray中的索引为2开始的1项替换成空的，因为后面没有内容，结果可以看到，把56这项删除了 修改操作：123var myArray=[2,34,56,32,12,9];var a=myArray.splice(2,1,8,9); // 得到56console.log(myArray); // [2,34,8,9,32,12,9] 第一个参数是准备操作的数组索引，第二个参数是操作位置后面的数组项数，第三个以后的就是，被替换后的内容 添加操作123var myArray=[2,34,56,32,12,9];var a=myArray.splice(2,0,8,9); // 得到空[]console.log(myArray); // [2,34,8,9,56,32,12,9] 从数组索引为2后的0项换成8,9，也就等于添加了两项 javascript对JSON增删改查概要JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式,同时，JSON是 JavaScript 原生格式，这意味着在 JavaScript 中处理 JSON数据不须要任何特殊的 API 或工具包。 在JSON中，有两种结构：对象和数组 1、对象以“{”开始，“}”结束，“key/value”之间运用 “,”分隔。1packJson=&#123;"name":"Liza","password":"123"&#125; 2、数组以“[”开始，“]”结束。值之间运用 “,”分隔。1packJson=[&#123;"name":"Liza","password":"123"&#125;,&#123;"name":"Mike","password":"456"&#125;]; JSON对象和JSON字符串的转换在数据传输过程中，JSON是以字符串的形式传递的，而JS操作的是JSON对象，所以，JSON对象和JSON字符串之间的相互转换是关键。如下： JSON字符串： 1var jsonStr='&#123;"name":"Liza","password":"123"&#125;'; JSON对象： 1var packJson=[&#123;"name":"Liza","password":"123"&#125;,&#123;"name":"Mike","password":"456"&#125;]; 1、将String转化为JSON 1var jsonObject=jQuery.parseJSON(jsonStr); 2、将JSON转化为String 1var jsonStr=JSON.stringify(jsonObject) 增删改查Demo 1234567891011121314151617181920212223242526272829303132var p =&#123; "name": "kakaxi", "age":45, "sex":"male"&#125;;function JsonOperation()&#123; // 读取 for(var i in p)&#123; console.log(i+'=='+p[i]); // name==kakaxi... &#125; // 查找 console.log(p['age']); // 45 console.log(p.age); // 45 // 增加 p['卡卡西']='copy忍者，木叶上忍'; p['鼬']='天才忍者'; console.log(p['卡卡西']); // copy忍者，木叶上忍 // 修改 p.age=88; console.log(p['age']); // 88 // 删除 delete p['name']; delete p.age; for(var i in p)&#123; console.log(i+'=='+p[i]); // 已删除 name、age项 &#125;&#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript常用函数]]></title>
    <url>%2F2017%2F05%2F08%2FJavaScript%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[常规函数 alert函数：显示一个警告对话框，包括一个OK按钮。 confirm函数：显示一个确认对话框，包括OK、Cancel按钮。 escape函数：将字符转换成Unicode码。 eval函数：计算表达式的结果。 isNaN函数：测试是(true)否(false)不是一个数字。 parseFloat函数：将字符串转换成符点数字形式。 parseInt函数：将符串转换成整数数字形式(可指定几进制)。 prompt函数：显示一个输入对话框，提示等待用户输入。例如： 123alert("输入错误"); prompt("请输入您的姓名","姓名");confirm("确定否！"); unescape函数：解码由escape函数编码的字符。 toFixed 函数:这个函数牛逼 就是转化小数点几位的 checkprice.toFixed(2)； 将checkprice转化为有小数点后两位的值 数组函数javascript数组函数包括以下4个函数：(1) join函数：转换并连接数组中的所有元素为一个字符串。例: 123456function JoinDemo()&#123; var a, b; a = new Array(0,1,2,3,4); b = a.join("-");//分隔符 return(b);//返回的b=="0-1-2-3-4" &#125; (2) length函数：返回数组的长度。例： 123456function LengthDemo()&#123; var a, l; a = new Array(0,1,2,3,4); l = a.length; return(l);//l==5 &#125; (3) reverse函数：将数组元素顺序颠倒。例： 123456function ReverseDemo()&#123; var a, l; a = new Array(0,1,2,3,4); l = a.reverse(); return(l); &#125; (4) sort函数：将数组元素重新排序。例： 123456function SortDemo()&#123; var a, l; a = new Array("X" ,"y" ,"d", "Z", "v","m","r"); l = a.sort(); return(l); &#125; (5) push函数:将新元素添加到一个数组中，并返回数组的新长度值。例: 12345&lt;script type="text/javascript"&gt; var my_array = new Array('1','2','3','4'); my_array.push('5','6','7','8'); alert(my_array.length); //将返回8 数组中添加了4个元素&lt;/script&gt; (6) unshift函数：将指定的元素插入数组开始位置并返回该数组。例： 12345&lt;script type="text/javascript"&gt; var my_array = new Array('1','2','3','4'); my_array.unshift('0'); //在数组前面追加元素 alert(my_array.length); //返回5&lt;/script&gt; (7) pop函数:移除数组中的最后一个元素并返回该元素。例: 12345&lt;script type="text/javascript"&gt; var my_array = new Array('1','2','3','411'); alert(my_array.pop()); //返回411 alert(my_array.length); //返回3&lt;/script&gt; (8) shift函数:移除数组中的第一个元素并返回该元素。例: 12345&lt;script type="text/javascript"&gt; var my_array = new Array('1','2','3','4'); alert(my_array.shift()); //返回1 alert(my_array.length); //返回3&lt;/script&gt; (9) Obj.slice(start,end) 返回一个数组的一段，得到一个新数组。注意不包括 end 对应的元素，如果省略 end 将复制 start 之后的所有元素,例如： 123456789&lt;script type="text/javascript"&gt; var my_array = new Array('1','2','3','4'); var new_array = my_array.slice(0,2); //返回0-2个元素 var new_array = my_array.slice(0,-1); //返回除了最后一个之外的元素 var new_array = my_array.slice(0); //返回第0以后的所有的元素 for(var i =0;i&lt;new_array.length;i++)&#123; alert(new_array[i]); &#125;&lt;/script&gt; (10) Obj.concat(item1,item2,item3,item4,item5……) 返回一个新数组，这个新数组是由两个或更多数组（也可以是一个变量）组合而成的,。例: 12345678910&lt;script type="text/javascript"&gt; var my_array = new Array('1','2','3','4'); var my_array1 = new Array('5','6'); var my_array2 = new Array('7','8'); var my_array3 = new Array('9'); var my_name = 'SmarTop'; //也可以是一个字符串 var my_age = 26; //也可以是一个数字 var new_array = my_array.concat(my_array1,my_array2,my_array3,my_name,my_age); alert(new_array);&lt;/script&gt; 日期函数javascript日期函数包括以下20个函数： (1) getDate函数：返回日期的”日”部分，值为1～31。例： 12345678function DateDemo()&#123; var d, s = "Today's date is: "; d = new Date(); s += (d.getMonth() + 1) + "/"; s += d.getDate() + "/"; s += d.getYear(); return(s);&#125; (2) getDay函数：返回星期几，值为0～6，其中0表示星期日，1表示星期一，…，6表示星期六。例： 123456789function DateDemo()&#123; var d, day, x, s = "Today is: "; var x = new Array("Sunday", "Monday", "Tuesday"); var x = x.concat("Wednesday","Thursday", "Friday"); var x = x.concat("Saturday"); d = new Date(); day = d.getDay(); return(s += x[day]);&#125; (3) getHours函数：返回日期的”小时”部分，值为0～23。例： 12345678910function TimeDemo()&#123; var d, s = "The current local time is: "; var c = ":"; d = new Date(); s += d.getHours() + c; s += d.getMinutes() + c; s += d.getSeconds() + c; s += d.getMilliseconds(); return(s);&#125; (4) getMinutes函数：返回日期的”分钟”部分，值为0～59。见上例。(5) getMonth函数：返回日期的”月”部分，值为0～11。其中0表示1月，2表示3月，…，11表示12月。见前面的例子。(6) getSeconds函数：返回日期的”秒”部分，值为0～59。见前面的例子。(7) getTime函数：返回系统时间。 1234567891011function GetTimeTest()&#123; var d, s, t; var MinMilli = 1000 * 60; var HrMilli = MinMilli * 60; var DyMilli = HrMilli * 24; d = new Date(); t = d.getTime(); s = "It's been " s += Math.round(t / DyMilli) + " days since 1/1/70"; return(s);&#125; (8) getTimezoneOffset函数：返回此地区的时差(当地时间与GMT格林威治标准时间的地区时差)，单位为分钟。 123456789101112function TZDemo()&#123; var d, tz, s = "The current local time is "; d = new Date(); tz = d.getTimezoneOffset(); if (tz &lt; 0) s += tz / 60 + " hours before GMT"; else if (tz == 0) s += "GMT"; else s += tz / 60 + " hours after GMT"; return(s);&#125; (9) getYear函数：返回日期的”年”部分。返回值以1900年为基数，例如1999年为99。前面有例子。(10) parse函数：返回从1970年1月1日零时整算起的毫秒数(当地时间)。 123456789101112function GetTimeTest(testdate)&#123; var d, s, t; var MinMilli = 1000 * 60; var HrMilli = MinMilli * 60; var DyMilli = HrMilli * 24; d = new Date(); t = Date.parse(testdate); s = "There are " s += Math.round(Math.abs(t / DyMilli)) + " days " s += "between " + testdate + " and 1/1/70"; return(s);&#125; (11) setDate函数：设定日期的”日”部分，值为0～31。(12) setHours函数：设定日期的”小时”部分，值为0～23。(13) setMinutes函数：设定日期的”分钟”部分，值为0～59。(14) setMonth函数：设定日期的”月”部分，值为0～11。其中0表示1月，…，11表示12月。(15) setSeconds函数：设定日期的”秒”部分，值为0～59。(16) setTime函数：设定时间。时间数值为1970年1月1日零时整算起的毫秒数。(17) setYear函数：设定日期的”年”部分。(18) toGMTString函数：转换日期成为字符串，为GMT格林威治标准时间。(19) setLocaleString函数：转换日期成为字符串，为当地时间。(20) UTC函数：返回从1970年1月1日零时整算起的毫秒数，以GMT格林威治标准时间计算。 数学函数javascript数学函数其实就是Math对象，它包括属性和函数(或称方法)两部分。其中，属性主要有下列内容。Math.e:e(自然对数)、Math.LN2（2的自然对数)、Math.LN10(10的自然对数)、Math.LOG2E(e的对数，底数为2)、 Math.LOG10E(e的对数，底数为10)、Math.PI(π)、Math.SQRT1_2(1/2的平方根值)、Math.SQRT2(2的平方根值)。函数有以下18个：(1) abs函数：即Math.abs(以下同)，返回一个数字的绝对值。(2) acos函数：返回一个数字的反余弦值，结果为0～π弧度(radians)。(3) asin函数：返回一个数字的反正弦值，结果为-π/2～π/2弧度。(4) atan函数：返回一个数字的反正切值，结果为-π/2～π/2弧度。(5) atan2函数：返回一个坐标的极坐标角度值。(6) ceil函数：返回一个数字的最小整数值(大于或等于)。(7) cos函数：返回一个数字的余弦值，结果为-1～1。(8) exp函数：返回e(自然对数)的乘方值。(9) floor函数：返回一个数字的最大整数值(小于或等于)。(10) log函数：自然对数函数，返回一个数字的自然对数(e)值。(11) max函数：返回两个数的最大值。(12) min函数：返回两个数的最小值。(13) pow函数：返回一个数字的乘方值。(14) random函数：返回一个0～1的随机数值。(15) round函数：返回一个数字的四舍五入值，类型是整数。(16) sin函数：返回一个数字的正弦值，结果为-1～1。(17) sqrt函数：返回一个数字的平方根值。(18) tan函数：返回一个数字的正切值。 字符串函数(1) concat函数:将两个或多个字符的文本组合起来，返回一个新的字符串。 12345var a = "hello";var b = ",world";var c = a.concat(b);alert(c);//c = "hello,world" (2) indexOf函数：返回字符串中一个子串第一处出现的索引（从左到右搜索）。如果没有匹配项，返回 -1 。 1234var index1 = a.indexOf("l");//index1 = 2var index2 = a.indexOf("l",3); //3表示从第三个开始向右搜索//index2 = 3 (3) lastIndexOf:返回字符串中一个子串第一处出现的索引（从右到左搜索）。如果没有匹配项，返回 -1 。 1234var index1 = lastIndexOf('l');//index1 = 3var index2 = lastIndexOf('l',2)//3表示从第三个开始向左搜索//index2 = 2 (4) charAt：返回字符串中指定的某个字符。 12var get_char = a.charAt(0);//get_char = "h" (5) match：检查一个字符串匹配一个正则表达式内容，如果没有匹配返回 null。 12345var re = new RegExp(/^\w+$/); //存储检索模式var is_alpha1 = a.match(re);//is_alpha1 = "hello"var is_alpha2 = b.match(re);//is_alpha2 = null (6) substring:返回位于 String 对象中指定位置的子字符串。 1234var sub_string1 = a.substring(1);//sub_string1 = "ello"var sub_string2 = a.substring(1,4);//sub_string2 = "ell" (6) substr：返回字符串的一个子串，传入参数是起始位置和长度 1234var sub_string1 = a.substr(1);//sub_string1 = "ello"var sub_string2 = a.substr(1,4); //长度//sub_string2 = "ello" (7) replace：用来查找匹配一个正则表达式的字符串，然后使用新字符串代替匹配的字符串。 12345var r, re; // 声明变量。var ss = "The man hit the ball with the bat.\n";ss += "while the fielder caught the ball with the glove.";re = /The/g; // 创建正则表达式模式。r = ss.replace(re, "A"); // 用 "A" 替换 "The"。 var r, re; // 声明变量。var ss = “The rain in Spain falls mainly in the plain.”;re = /(\S+)(\s+)(\S+)/g; // 创建正则表达式模式。r = ss.replace(re, “$3$2$1”); // 交换每一对单词。 (8) search：执行一个正则表达式匹配查找。如果查找成功，返回字符串中匹配的索引值。否则返回 -1 。 1234var index1 = a.search(re);//index1 = 0var index2 = b.search(re);//index2 = -1 (9) slice:提取字符串的一部分，并返回一个新字符串（与 substring 相同）。 1234var sub_string1 = a.slice(1);//sub_string1 = "ello"var sub_string2 = a.slice(1,4);//sub_string2 = "ell" (10) split:通过将字符串划分成子串，将一个字符串做成一个字符串数组。 123var arr1 = a.split(""); //使用分割的字符 //arr1 = [h,e,l,l,o] length (11) length:返回字符串的长度，所谓字符串的长度是指其包含的字符的个数。 12var len = a.length(); //len = 5 (12) toLowerCase:将整个字符串转成小写字母。 12var lower_string = a.toLowerCase();//lower_string = "hello" (13) toUpperCase:将整个字符串转成大写字母。 12var upper_string = a.toUpperCase();//upper_string = "HELLO"]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>常用函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript事件]]></title>
    <url>%2F2017%2F05%2F07%2FJavaScript%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[与浏览器进行交互的时候浏览器就会触发各种事件。比如当我们打开某一个网页的时候，浏览器加载完成了这个网页，就会触发一个 load 事件；当我们点击页面中的某一个“地方”，浏览器就会在那个“地方”触发一个 click 事件。 这样，我们就可以编写 JavaScript，通过监听某一个事件，来实现某些功能扩展。例如监听 load 事件，显示欢迎信息，那么当浏览器加载完一个网页之后，就会显示欢迎信息。 下面就来介绍一下事件。 基础事件操作监听事件浏览器会根据某些操作触发对应事件，如果我们需要针对某种事件进行处理，则需要监听这个事件。监听事件的方法主要有以下几种： HTML 内联属性（避免使用）HTML 元素里面直接填写事件有关属性，属性值为 JavaScript 代码，即可在触发该事件的时候，执行属性值的内容。 例如： 1&lt;button onclick="alert('你点击了这个按钮');"&gt;点击这个按钮&lt;/button&gt; 上面代码就是监听 element 节点的 click 事件。它比较简单易懂，而且有较好的兼容性。但是也有缺陷，因为直接赋值给对应属性，如果你在后面代码中再次为 element 绑定一个回调函数，会覆盖掉之前回调函数的内容。 虽然也可以用一些方法实现多个绑定，但还是推荐下面的标准事件监听函数。 DOM 属性绑定也可以直接设置 DOM 属性来指定某个事件对应的处理函数，这个方法比较简单： 123456element.onclick = function(event)&#123; alert('你点击了这个按钮');&#125;;/* 上面代码就是监听 element 节点的 click 事件。它比较简单易懂，而且有较好的兼容性。但是也有缺陷，因为直接赋值给对应属性，如果你在后面代码中再次为 element 绑定一个回调函数，会覆盖掉之前回调函数的内容。虽然也可以用一些方法实现多个绑定，但还是推荐下面的标准事件监听函数。 */ 使用事件监听函数标准的事件监听函数如下： 1element.addEventListener(&lt;event-name&gt;, &lt;callback&gt;, &lt;use-capture&gt;); 表示在 element 这个对象上面添加一个事件监听器，当监听到有 &lt;event-name&gt; 事件发生的时候，调用 &lt;callback&gt; 这个回调函数。至于 &lt;use-capture&gt; 这个参数，表示该事件监听是在“捕获”阶段中监听（设置为 true）还是在“冒泡”阶段中监听（设置为 false）。关于捕获和冒泡，我们会在下面讲解。 用标准事件监听函数改写上面的例子： 1234567&lt;button id="btn"&gt;点击这里&lt;/button&gt;&lt;script&gt;var btn = document.getElementById('btn');btn.addEventListener('click', function()&#123; alert('你点击了这里');&#125;, false);&lt;/script&gt; 移除事件监听当我们为某个元素绑定了一个事件，每次触发这个事件的时候，都会执行事件绑定的回调函数。如果我们想解除绑定，需要使用 removeEventListener 方法： 1element.removeEventListener(&lt;event-name&gt;, &lt;callback&gt;, &lt;use-capture&gt;); 需要注意的是，绑定事件时的回调函数不能是匿名函数，必须是一个声明的函数，因为解除事件绑定时需要传递这个回调函数的引用，才可以断开绑定。例如： 123456789&lt;button id="btn"&gt;点击这里&lt;/button&gt;&lt;script&gt; var btn = document.getElementById('btn'); var fun = function()&#123; alert('这个按钮只支持一次点击'); btn.removeEventListener('click', fun, false);&#125;;btn.addEventListener('click', fun, false);&lt;/script&gt; 事件触发过程在上面大体了解了事件是什么、如何监听并执行某些操作，但我们对事件触发整个过程还不够了解。 下图就是事件的触发过程，借用了 W3C 的图片 JavaScript中的一些常用事件onclick事件点击事件（onclick并不是js中的方法，onclick只是浏览器提供js的一个dom接口，让js可以操作dom，所以onclick大小写都是没问题的，比如HTML代码就不用区分大小写） 1234567&lt;buttononclick="myFunction()"&gt;点击这里&lt;/button&gt;&lt;script&gt; functionmyFunction()&#123; alert("测试onclick点击事件"); &#125;&lt;/script&gt; onclick通常在下列基本对象中产生： button(按钮对象)、checkbox(复选框)、radio(单选框)、reset buttons(重置按钮)、submit buttons(提交按钮) onload事件可以body执行，,其中onload后面可以写一个方法，如：onload=”test()”,然后在JavaScript中写一个test()方法，则在页面一开始加载的时候会先调用这个方法 12345678&lt;bodyonload="test()"&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; functiontest()&#123; alert("测试onload方法"); &#125;&lt;/script&gt; 注意：此方法只能写在标签之中 onchange事件事件在内容改变的时候触发，和jQuery中的change()方法一样 当内容改变时触发。可用于文本框、列表框等对象，该事件一般用于响应用户修改内容带来的其他改变操作。 说明：当用户向一个文本框中输入文本时，不会触发onchange事件，只有用户输入结束后，单击文本框以外的区域，使文本框失去焦点时才触发该事件，如果是下拉框，则选择结束后即触发。 1234567891011&lt;p&gt; &lt;labelfor="name"&gt;用户名：&lt;/label&gt; &lt;input type="text" id="fname" onchange="upperCase()" value=""/&gt;&lt;/p&gt;&lt;script type="text/javascript"&gt; functionupperCase()&#123; var x = document.getElementById("fname").value; document.getElementById("fname").value = x.toUpperCase(); &#125;&lt;/script&gt; 说明：上例实际效果是，当输入框失去焦点时内容转成大写。出现这种情况是由于input必须是失去焦点才会检测到内容发生改变。而change事件通常是用于下拉菜单select标签。 onblur事件和onfocus事件onblur事件：当前元素失去焦点时触发该事件；onfocus事件：得到焦点事件 123456789101112131415&lt;body&gt;失去焦点：&lt;inputtype="text" name="name" value=" "size="30" onblur="chkvalue(this)"&gt;&lt;br&gt;得到焦点：&lt;inputtype="text" id="name" value="" size="30" onfocus="setStyle(this.id)"&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; function chkvalue(txt) &#123; if(txt.value=="") alert("文本框里必须填写内容!"); &#125; function setStyle(x)&#123; document.getElementById(x).style.background="yellow" &#125;&lt;/script&gt; onscroll事件窗口滚动事件：当页面滚动时调用函数。此事件写在方法的外面，且函数名后面不加括号，例如window.onscroll=move 123456&lt;script type="text/javascript"&gt; functionmove() &#123; alert("页面滚动时调用"); &#125; window.onscroll = move;&lt;/script&gt; onsubmit事件属于表单元素，写在表单标签内。语法：onsubmit=”return 函数名()” 1234567891011&lt;form action="" method="post" name="testForm" onsubmit="returnmove()"&gt; &lt;inputtype="text"name="name"value=""&gt; &lt;br&gt; &lt;input type="submit" name="submit" value="测试onsubmit"/&gt;&lt;/form&gt;&lt;script type="text/javascript"&gt; functionmove() &#123; alert("测试onsubmit........"+testForm.name.value); &#125;&lt;/script&gt; 鼠标相关事件onmousemove和onmouseout和onmouseover事件Onmouseover:鼠标移动到某对象范围的上方时，触发事件调用函数。注意：在同一个区域中，无论怎样移动都只触发一次函数。 Onmouseout:鼠标离开某对象范围时，触发事件调用函数。 Onmousemove:鼠标移动到某对象范围的上方时，触发事件调用函数。注意：在同一个区域中，只要鼠标动一次就触发一次事件。 12345678910111213&lt;img onmousemove="bigImg(this)" onmouseout="normalImg(this)" border="0" src="images/defaultAvatar.gif" alt="Smiley"&gt;&lt;script type="text/javascript"&gt; functionbigImg(x)&#123; x.style.height="180px"; x.style.width="180px"; &#125; functionnormalImg(x)&#123; x.style.height="128px"; x.style.width="128px"; &#125;&lt;/script&gt; onmouseup和onmousedownOnmouseup:当鼠标松开时触发事件 Onmousedown:当鼠标按下键时触发事件 123456789101112&lt;p id="p1" onmousedown="mouseDown()" onmouseup="mouseUp()"&gt;请点击文本！mouseDown()函数当鼠标按钮在段落上被按下时触发。此函数把文本颜色设置为红色。mouseUp() 函数在鼠标按钮被释放时触发。mouseUp() 函数把文本的颜色设置为绿色。&lt;/p&gt;&lt;script type="text/javascript"&gt; functionmouseDown()&#123; document.getElementById("p1").style.color="red"; &#125; functionmouseUp()&#123; document.getElementById("p1").style.color="green"; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript之DOM操作]]></title>
    <url>%2F2017%2F05%2F06%2Fjavascript%E4%B9%8BDOM%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[前言DOM 中的三个字母，D（文档）可以理解为整个 Web 加载的网页文档；O（对象）可以理解为类似 window 对象之类的东西，可以调用属性和方法，这里我们说的是 document对象；M（模型）可以理解为网页文档的树型结构。 一、document.getElementById() 根据Id获取元素节点1234567891011&lt;div id="div1"&gt; &lt;p id="p1"&gt; 我是第一个P&lt;/p&gt; &lt;p id="p2"&gt; 我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var str = document.getElementById("p1").innerHTML; alert(str); //弹出 我是第一个P &#125; 二、document.getElementsByName() 根据name获取元素节点12345678910111213&lt;div id="div1"&gt; &lt;p id="p1"&gt; 我是第一个P&lt;/p&gt; &lt;p id="p2"&gt; 我是第二个P&lt;/p&gt; &lt;input type="text" value="请输入值" name="userName" /&gt; &lt;input type="button" value="确定" onclick="fun1()"&gt;&lt;/div&gt; function fun1() &#123; var username = document.getElementsByName("userName")[0].value; alert(username); //输出userName里输入的值&#125; 三、document.getElementsByTagName() 根据HTML标签名获取元素节点，注意getElements*的选择器返回的是一个NodeList对象，能根据索引号选择其中1个，可以遍历输出。123456789101112131415161718192021222324&lt;div id="div1"&gt; &lt;p id="p1"&gt; 我是第一个P&lt;/p&gt; &lt;p id="p2"&gt; 我是第二个P&lt;/p&gt; &lt;/div&gt; window.onload = function () &#123; var str = document.getElementsByTagName("p")[1].innerHTML; alert(str); //输出 我是第二个P，因为获取的是索引为1的P，索引从0开始 &#125; window.onload = function () &#123; var arr = document.getElementsByTagName("p"); for (var i = 0; i &lt; arr.length; i++) &#123; alert(arr[i].innerHTML); &#125; &#125; window.onload = function () &#123; var node = document.getElementById("div1"); var node1 = document.getElementsByTagName("p")[1]; //从获取到的元素再获取 alert(node1.innerHTML); &#125; 四、document.getElementsByClassName() 根据class获取元素节点1234567891011&lt;div id="div1"&gt; &lt;p id="p1" class="class1"&gt; 我是第一个P&lt;/p&gt; &lt;p id="p2"&gt; 我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var node = document.getElementsByClassName("class1")[0]; alert(node.innerHTML); &#125; 五、javascript中的CSS选择器1234567891011121314151617181920document.querySelector() //根据CSS选择器的规则，返回第一个匹配到的元素document.querySelectorAll() //根据CSS选择器的规则，返回所有匹配到的元素&lt;div id="div1"&gt; &lt;p id="p1" class="class1"&gt; 我是第一个P&lt;/p&gt; &lt;p id="p2" class="class2"&gt; 我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var node = document.querySelector("#div1 &gt; p"); alert(node.innerHTML); //输出 我是第一个P var node1 = document.querySelector(".class2"); alert(node1.innerHTML); //输出 我是第二个P var nodelist = document.querySelectorAll("p"); alert(nodelist[0].innerHTML + " - " + nodelist[1].innerHTML); //输出 我是第一个P - 我是第二个P&#125; 六、文档结构和遍历作为节点数的文档 ​ parentNode 获取该节点的父节点 ​ childNodes 获取该节点的子节点数组 ​ firstChild 获取该节点的第一个子节点 ​ lastChild 获取该节点的最后一个子节点 ​ nextSibling 获取该节点的下一个兄弟元素 ​ previoursSibling 获取该节点的上一个兄弟元素 ​ nodeType 节点的类型，9代表Document节点，1代表Element节点，3代表Text节点，8代表 Comment节点，11代表DocumentFragment节点 ​ nodeVlue Text节点或Comment节点的文本内容 ​ nodeName 元素的标签名(如P,SPAN,#text(文本节点),DIV)，以大写形式表示 注意，以上6个方法连元素节点也算一个节点。 12345678910111213141516171819202122232425262728293031323334353637&lt;div id="div1"&gt; &lt;p id="p1" class="class1"&gt; 我是第一个P&lt;/p&gt; &lt;p id="p2" class="class2"&gt; 我是第二个P&lt;/p&gt;&lt;/div&gt; window.onload = function () &#123; var node1 = document.querySelector(".class2"); alert(node1.parentNode.innerHTML); //输出 &lt;p id="p1" class="class1"&gt;我是第一个P&lt;/p&gt;&lt;p id="p2" class="class2"&gt;我是第二个P&lt;/p&gt; var nodelist = document.getElementById("div1"); var arr = nodelist.childNodes; alert(arr[1].innerHTML + " - " + arr[3].innerHTML); //输出 我是第一个P - 我是第二个P 为什么是1，3呢？因为本方法文本节点也会获取，也就是说0,2,4是文本节点 &#125;&lt;div id="div1"&gt; 文本1 &lt;p id="p1" class="class1"&gt; 我是第一个P&lt;/p&gt; 文本2 &lt;p id="p2" class="class2"&gt; 我是第二个P&lt;/p&gt; 文本3&lt;/div&gt;window.onload = function () &#123; //依次输出，文本1，我是第一个P，文本2，我是第二个P，文本3 var node = document.getElementById("div1"); for (var i = 0; i &lt; node.childNodes.length; i++) &#123; if (node.childNodes[i].nodeType == 1) &#123; alert(node.childNodes[i].innerHTML); &#125; else if (node.childNodes[i].nodeType == 3) &#123; alert(node.childNodes[i].nodeValue); &#125; &#125;&#125; 作为元素树的文档 ​ firstElementChild 第一个子元素节点 ​ lastElementChild 最后一个子元素节点 ​ nextElementSibling 下一个兄弟元素节点 ​ previousElementSibling 前一个兄弟元素节点 ​ childElementCount 子元素节点个数量 注意，此5个方法文本节点不算进去 123456789101112131415161718&lt;div id="div1"&gt; &lt;p id="p1" class="class1"&gt; 我是第一个P&lt;/p&gt; &lt;p id="p2" class="class2"&gt; 我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var node = document.getElementById("div1"); var node1 = node.firstElementChild; var node2 = node.lastElementChild; alert(node.childElementCount); //输出2，div1一共有两个非文档子元素节点 alert(node1.innerHTML); //输出 我是第一个P alert(node2.innerHTML); //输出 我是第二个P alert(node2.previousElementSibling.innerHTML); //输出 我是第一个P(第二个元素节点的上一个非文本元素节点是P1) alert(node1.nextElementSibling.innerHTML); //输出 我是第二个P(第一个元素节点的下一个兄弟非文本节点是P2)&#125; 七、javascript操作HTML属性1、属性的读取，此处要注意的是，某些HTML属性名称在javascript之中是保留字，因此会有些许不同，如class,lable中的for在javascript中变为htmlFor,className。1234567891011121314&lt;div id="div1"&gt; &lt;p id="p1" class="class1"&gt; 我是第一个P&lt;/p&gt; &lt;img src="123.jpg" alt="我是一张图片" id="img1" /&gt; &lt;input type="text" value="我是一个文本框" id="input1" /&gt;&lt;/div&gt;window.onload = function () &#123; var nodeText = document.getElementById("input1"); alert(nodeText.value); //输出 我是一个文本框 var nodeImg = document.getElementById("img1"); alert(nodeImg.alt); //输出 我是一张图片 var nodeP = document.getElementById("p1"); alert(nodeP.className); //输出 class1 注意获取class是className，如果写成nodeP.class则输出undefined&#125; 2、属性的设置，此处同样要注意的是保留字1234567&lt;div id="div1"&gt; &lt;img src="1big.jpg" alt="我是一张图片" id="img1" onclick="fun1()" /&gt;&lt;/div&gt;function fun1() &#123; document.getElementById("img1").src = "1small.jpg"; //改变图片的路径属性。实现的效果为，当点击图片时，大图变小图。&#125; 3、非标准HTML属性getAttribute(); // 注意这两个方法是不必理会javascript保留字的，HTML属性是什么就怎么写。setAttribute(); 12345678&lt;div id="div1"&gt; &lt;img src="1big.jpg" alt="我是一张图片" class="imgClass" id="img1" onclick="fun1()" /&gt;&lt;/div&gt;function fun1() &#123; document.getElementById("img1").setAttribute("src", "1small.jpg"); alert(document.getElementById("img1").getAttribute("class"));&#125; 4、Attr节点的属性attributes属性 非Element对象返回null，Element一半返回Attr对象。Attr对象是一个特殊的Node,通过name与value获取属性名称与值。如:document.getElementById(“img1”)[0]; document.getElementById(“img1”).src; 123456789&lt;div id="div1"&gt; &lt;img src="1big.jpg" alt="我是一张图片" class="imgClass" id="img1" onclick="fun1()" /&gt;&lt;/div&gt;function fun1() &#123; alert(document.getElementById("img1").attributes[0].name); //输出 onclick 注意，通过索引器访问是写在右面在排前面，从0开始 alert(document.getElementById("img1").attributes.src.value); //输出1big.jpg document.getElementById("img1").attributes.src.value = "1small.jpg"; //点击后改变src属性，实现了点击大图变小图效果&#125; 八、元素的内容1、innerText、textContent innerText与textContent的区别，当文本为空时，innerText是””，而textContent是undefined2、innerHTML 123456789101112&lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p id="p2"&gt;我是第&lt;b&gt;二&lt;/b&gt;个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; alert(document.getElementById("p1").innerText); //注意火狐浏览器不支持innerText alert(document.getElementById("p1").textContent); //基本都支持textContent document.getElementById("p1").textContent = "我是p1，javascript改变了我"; //设置文档Text alert(document.getElementById("p2").textContent); alert(document.getElementById("p2").innerHTML); //innerHTML与innerText的区别，就是对HTML代码的输出方式Text不会输出HTML代码&#125; 九、创建，插入，删除节点1、document.createTextNode() 创建一个文本节点12345678910111213141516&lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p id="p2"&gt;我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var textNode = document.createTextNode("&lt;p&gt;我是一个javascript新建的节点&lt;/p&gt;"); document.getElementById("div1").appendChild(textNode);&#125;/* 完成后HTML变为： div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p id="p2"&gt;我是第二个P&lt;/p&gt; &lt;p&gt;我是一个javascript新建的节点&lt;/p&gt; &lt;/div&gt; */ 2、document.createElement() 创建一个元素节点12345678910111213141516&lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p id="p2"&gt;我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var pNode = document.createElement("p"); pNode.textContent = "新建一个P节点"; document.getElementById("div1").appendChild(pNode);&#125;/* &lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p id="p2"&gt;我是第二个P&lt;/p&gt; &lt;p&gt;新建一个P节点&lt;/p&gt; &lt;/div&gt; */ 3、插入节点appendChild() //将一个节点插入到调用节点的最后面insertBefore() //接受两个参数，第一个为待插入的节点，第二个指明在哪个节点前面，如果不传入第二个参数，则跟appendChild一样，放在最后。 12345678910111213141516171819&lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var pNode1 = document.createElement("p"); pNode1.textContent = "insertBefore插入的节点"; var pNode2 = document.createElement("p"); pNode2.textContent = "appendChild插入的节点"; document.getElementById("div1").appendChild(pNode2); document.getElementById("div1").insertBefore(pNode1,document.getElementById("p1"));&#125;/* 执行之后HTML代码为： &lt;div id="div1"&gt; &lt;p&gt;insertBefore插入的节点&lt;/p&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p&gt;appendChild插入的节点&lt;/p&gt; &lt;/div&gt; */ 十、删除和替换节点。1、removeChild(); 由父元素调用，删除一个子节点。注意是直接父元素调用，删除直接子元素才有效，删除孙子元素就没有效果了。1234567891011121314&lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p id="p2"&gt;我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var div1 = document.getElementById("div1"); div1.removeChild(document.getElementById("p2"));&#125;/* 执行之后代码变为： &lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; //注意到第二个P元素已经被移除了 &lt;/div&gt; */ 2、replaceChild() //删除一个子节点，并用一个新节点代替它，第一个参数为新建的节点，第二个节点为被替换的节点1234567891011121314151617&lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p id="p2"&gt;我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var div1 = document.getElementById("div1"); var span1 = document.createElement("span"); span1.textContent = "我是一个新建的span"; div1.replaceChild(span1,document.getElementById("p2"));&#125;/* 执行完成后HTML代码变为： &lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;span&gt;我是一个新建的span&lt;/span&gt; //留意到p2节点已经被替换为span1节点了 &lt;/div&gt; */ 十一、javascript操作元素CSS通过元素的style属性可以随意读取和设置元素的CSS样式，例子： 123456789101112&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; window.onload = function () &#123; alert(document.getElementById("div1").style.backgroundColor); document.getElementById("div1").style.backgroundColor = "yellow"; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="div1" style="width:100px; height:100px; background-color:red"&gt;&lt;/div&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>DOM操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript之DOM操作(2)]]></title>
    <url>%2F2017%2F05%2F06%2Fjavascript%E4%B9%8BDOM%E6%93%8D%E4%BD%9C-2%2F</url>
    <content type="text"><![CDATA[DOM操作总结jQuery select操作控制方法小结123456&lt;select id="mySelect"&gt; &lt;option value ="volvo"&gt;Volvo&lt;/option&gt; &lt;option value ="saab"&gt;Saab&lt;/option&gt; &lt;option value="opel"&gt;Opel&lt;/option&gt; &lt;option value="audi"&gt;Audi&lt;/option&gt;&lt;/select&gt; jQuery获取Select选择的Text和Value12345678// 为Select添加事件，当选择其中一项时触发 $('#mySelect').change(function()&#123; console.log($('#mySelect').val()); // 获取Select选择的Value console.log($('#mySelect').find('option:selected').val()); // 获取Select选择的option的Value console.log($('#mySelect').find('option:selected').text()); // 获取Select选择的option的Text console.log($('#mySelect').get(0).selectedIndex); // 获取Select选择的索引值 console.log($('#mySelect option:last').attr('index')); // 获取Select最大的索引值 &#125;); jQuery设置Select选择的Text和Value1234$('#mySelect').get(0).selectedIndex=1; // 设置Select索引值为1的项选中 $('#mySelect').val('audi'); // 设置Select的Value值为audi的项选中 $("#mySelect option[value='opel']").attr('selected',true); // 设置Select的value值为opel的项选中$("#mySelect option[name='kakaxi']").attr('selected',true); // 设置Select的name值为kakaxi的项选中 jQuery添加/删除Select的Option项123456$('#mySelect').empty(); // 清空下拉框$("#mySelect").append("&lt;option value='.net'&gt;.Net&lt;/option&gt;"); // 为Select追加一个Option(下拉项)$("#mySelect").prepend("&lt;option value='.net'&gt;.Net&lt;/option&gt;"); // 为Select插入一个Option(第一个位置) $('#mySelect option:last').remove(); // 删除Select中索引值最大Option(最后一个) $("#mySelect option[index=0]").remove(); // 删除Select中索引值为0的Option(第一个) $("#mySelect option[name='kakaxi']").remove(); // 删除Select中name='kakaxi'的Option jQuery checkbox操作控制方法小结1234567891011121314151617181920212223242526272829&lt;script type="text/javascript"&gt; $(function()&#123; //全选 $('#btnAll').click(function()&#123; $('div :checkbox').attr('checked',true); &#125;); //全不选 $('#btnNoAll').click(function()&#123; $('div :checkbox').attr('checked',false); &#125;); //反选 $('#btnFanXuan').click(function()&#123; $('div :checkbox').each(function()&#123; $(this).attr('checked',!$(this).attr('checked')); &#125;); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="button"name="name"value="全选"id="btnAll"/&gt; &lt;input type="button"name="name"value="全不选"id="btnNoAll"/&gt; &lt;input type="button"name="name"value="反选"id="btnFanXuan"/&gt; &lt;div&gt; &lt;input type="checkbox"name="name"value="1"/&gt;吃饭 &lt;input type="checkbox"name="name"value="2"/&gt;睡觉 &lt;input type="checkbox"name="name"value="3"/&gt;打豆豆 &lt;/div&gt; &lt;/body&gt; js中子页面父页面方法 变量相互调用子页面调用父页面的方法或者变量window.parent.方法()或者变量名window.parent相当于定位到父页面 之后的操作和在父页面中写代码一样写 123456789var parent=window.parent; // 获取当前窗体的父窗体 window.parent.aa(); // 调取aa函数window.parent.bb; // 调取bb变量例如：想在子页面中得到id为aaa的文本框的值window.parent.$("#aaa").val(); // 这种写法的前提是引用了jquery window.parent.getElementById("aaa").value; // js的写法 父页面调取子页面主要是通过contentWindow定位到子页面 123456document.getElementById("childframe").contentWindow.childtest();// 调取子页面中的childtest方法 js的写法var childWindow = $("#addFrame")[0].contentWindow; // 获取子窗体中的对象childWindow.formSubmit(); // 调取子页面的formSubmit方法 jquery的写法// 注释：其中 childframe和addFrame 都时iframe的id]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>DOM操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 开发规范]]></title>
    <url>%2F2017%2F05%2F06%2FJavaScript-%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[JavaScript 开发规范命名规范驼峰式命名法介绍：驼峰式命名法由小(大)写字母开始，后续每个单词首字母都大写。 Pascal Case 大驼峰式命名法：首字母大写。eg：StudentInfo、UserInfo、ProductInfo Camel Case 小驼峰式命名法：首字母小写。eg：studentInfo、userInfo、productInfo 变量命名方法：小驼峰式命名法。 命名规范：前缀应当是名词。(函数的名字前缀为动词，以此区分变量和函数) 命名建议：尽量在变量名字中体现所属类型，如:length、count等表示数字类型；而包含name、title表示为字符串类型。 示例： 1234567// 好的命名方式var maxCount = 10;var tableTitle = 'LoginTable'; // 不好的命名方式var setCount = 10;var getTitle = 'LoginTable'; 函数命名方法：小驼峰式命名法。 命名规范：前缀应当为动词。 命名建议：可使用常见动词约定 动词 含义 返回值 can 判断是否可执行某个动作(权限) 函数返回一个布尔值。true：可执行；false：不可执行 has 判断是否含有某个值 函数返回一个布尔值。true：含有此值；false：不含有此值 is 判断是否为某个值 函数返回一个布尔值。true：为某个值；false：不为某个值 get 获取某个值 函数返回一个非布尔值 set 设置某个值 无返回值、返回是否设置成功或者返回链式对象 load 加载某些数据 无返回值或者返回是否加载完成的结果 示例： 123456789// 是否可阅读function canRead() &#123; return true;&#125; // 获取名称function getName() &#123; return this.name;&#125; 常量命名方法：名称全部大写。 命名规范：使用大写字母和下划线来组合命名，下划线用以分割单词。 命名建议：无。 示例： 12var MAX_COUNT = 10;var URL = 'http://www.baidu.com'; 构造函数介绍：在JS中，构造函数也属于函数的一种，只不过采用new 运算符创建对象。 命名方法：大驼峰式命名法，首字母大写。 命名规范：前缀为名称。 命名建议：无。 示例： 12345function Student(name) &#123; this.name = name;&#125; var st = new Student('tom'); 类的成员类的成员包含： 公共属性和方法：跟变量和函数的命名一样。 私有属性和方法：前缀为_(下划线)，后面跟公共属性和方法一样的命名方式。 示例： 12345678910111213141516function Student(name) &#123; var _name = name; // 私有成员 // 公共方法 this.getName = function () &#123; return _name; &#125; // 公共方式 this.setName = function (value) &#123; _name = value; &#125;&#125;var st = new Student('tom');st.setName('jerry');console.log(st.getName()); // =&gt; jerry：输出_name私有变量的值 注释规范单行注释单行注释以 // 开头。 示例 1234// 输出标题：document.getElementById("myH1").innerHTML="Welcome to my Homepage";// 输出段落：document.getElementById("myP").innerHTML="This is my first paragraph."; 多行注释多行注释以 / 开始，以 / 结尾。 示例 123456789101112131415/* 功能：获取样式* 参数：要素，分辨率* 时间：2017-07-11* 创建人：张三*/function getStyle(feature,resolution)&#123; var type=feature.get('TYPE'); if(type.indexOf('铁路')!=-1)&#123; return new ol.style.Style(&#123; stroke:new ol.style.Stroke(&#123; color:'#330000', width:0 &#125;) &#125;);&#125; 行末注释 示例 12var x=5; // 声明 x 并把 5 赋值给它var y=x+2; // 声明 y 并把 x+2 赋值给它]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>开发规范</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript编码规范]]></title>
    <url>%2F2017%2F05%2F06%2FJavaScript%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[前言好的编码规范可以尽可能的减少一个软件的维护成本，并且几乎没有任何一个软件，在其整个生命周期中，均由最初的开发人员来维护；好的编码规范可以改善软件的可读性，可以让开发人员尽快而彻底地理解新的代码；好的编码规范可以最大限度的提高团队开发的合作效率；长期的规范性编码还可以让开发人员养成好的编码习惯，甚至锻炼出更加严谨的思维。 不规范写法举例句尾没有分号1var isHotel = json.type == "hotel" ? true : false 变量命名各种各样123var is_hotel;var isHotel;var ishotel; if缩写1234if (isHotel) console.log(true)else console.log(false) 使用eval1234567var json = eval(jsonText);/* eval 好不好取决于怎么使用它，一般认为的缺点： 1. 可读性非常差 2. 不好再做优化和编译 3. 会轻微增加性能消耗 4. 不安全，比如 eval input 的值 */ 变量未定义到处都是123456function() &#123; var isHotel = 'true'; ....... var html = isHotel ? '&lt;p&gt;hotel&lt;/p&gt;' : "";&#125; 超长函数12345function() &#123; var isHotel = 'true'; //....... 此处省略500行 return false;&#125; ……….书写不规范的代码让我们难以维护，有时候也让我们头疼。 （禁止）、（必须）等字眼，在这里只是表示强调，未严格要求。 前端规范之JavaScripttab键用（必须）用四个空格代替​ 因为在不同系统的编辑工具对tab解析不一样，windows下的tab键是占四个空格的位置，而在linux下会变成占八个空格的位置（除非你自己设定了tab键所占的位置长度）。 一些童鞋可能会有疑问，tab键换成四个空格，多麻烦啊~ 其实不然，我平时用sublime text比较多，在这个工具中可以对tab键进行设置。 每句代码后（必须）加”;” 这个是要引起注意的，比如： 1234a = b // 赋值(function()&#123; //....&#125;)() // 自执行函数 未加分号，结果被解析成 1a = b(function()&#123;//...&#125;)() //将b()()返回的结果赋值给a 这是截然不同的两个结果，所以对于这个问题必须引起重视！！！ 变量、常量、类的命名按（必须）以下规则执行：变量：必须采用骆驼峰的命名且首字母小写123456789// 正确的命名 var isHotel, isHotelBeijing, isHotelBeijingHandian; // 不推荐的命名 var is_Hotel, ishotelbeijing, IsHotelBeiJing; 常量：必须采用全大写的命名，且单词以_分割**，常量通常用于ajax请求url，和一些不会改变的数据 123// 正确的命名 var HOTEL_GET_URL = 'http://map.baidu.com/detail', PLACE_TYPE = 'hotel'; 类：必须采用骆驼峰的命名且首字母大写，如：1234// 正确的写法 var FooAndToo = function(name) &#123; this.name = name; &#125; 空格的使用1.if中的空格，先上例子 1234567891011 //正确的写法 if (isOk) &#123; console.log("ok"); &#125; //不推荐的写法 if(isOk)&#123; console.log("ok"); &#125;/* ()中的判断条件前后都(必须)加空格 ()里的判断前后(禁止)加空格，如：正确的写法: if (isOk)；不推荐的写法: if ( isOk ) */ 2.switch中的空格, 先上例子 1234567891011121314151617181920212223242526//正确的写法 switch(name) &#123; case "hotel": console.log(name); break; case "moive": console.log(name); break; default: // code &#125; //不推荐的写法 switch (name) &#123; // switch 后不应该有空格, 正确的写法: switch(name) &#123; // code case "hotel": console.log(name); break; // break; 应该和console.log对齐 case "movie": // 每个case之前需要有换行 console.log(name); break; // break; 应该和console.log对齐 default: // code &#125; 3.for中的空格，先上例子 12345678910111213141516171819 // 正确的写法 var names = ["hotel", "movie"], i, len; for (i=0, len=names.length; i &lt; len; i++) &#123; // code &#125; // 不推荐的写法 var names = ["hotel", "movie"], i, len; for(i = 0, len = names.length;i &lt; len;i++) &#123; // for后应该有空格，每个`;`号后需要有空格，变量的赋值不应该有空格 // code &#125;/* for后（必须）加空格 每个;后（必须）加空格 ()中禁止用var声明变量; 且变量的赋值 = 前后（禁止）加空格 */ 4.function 中的空格, 先上例子 12345678910111213141516 // 正确的写法 function call(name) &#123; &#125; var cell = function () &#123; &#125;; // 不推荐的写法 var call = function(name)&#123; // code &#125; /* 参数的反括号后（必须）加空格 function 后（必须）加空格 */ 5.var 中空格及定义，先上例子 12345678910111213 // 一个推荐的var写法组 function(res) &#123; var code = 1 + 1, json = JSON.parse(res), type, html; // code &#125;/* 声明变量 = 前后（必须）添加空格 每个变量的赋值声明以,结束后（必须）换行进行下一个变量赋值声明 （推荐）将所有不需要进行赋值的变量声明放置最后一行，且变量之间不需要换行 （推荐）当一组变量声明完成后，空一行后编写其余代码 */ 6.在同一个函数内部，局部变量的声明必须置于顶端 因为即使放到中间，js解析器也会提升至顶部（hosting） 1234567891011121314151617181920// 正确的书写var clear = function(el) &#123; var id = el.id, name = el.getAttribute("data-name"); ......... return true;&#125;// 不推荐的书写var clear = function(el) &#123; var id = el.id; ...... var name = el.getAttribute("data-name"); ......... return true;&#125; 7.块内函数必须用局部变量声明 123456789101112131415161718192021222324// 错误的写法 var call = function(name) &#123; if (name == "hotel") &#123; function foo() &#123; console.log("hotel foo"); &#125; &#125; foo &amp;&amp; foo(); &#125; // 推荐的写法 var call = function(name) &#123; var foo; if (name == "hotel") &#123; foo = function() &#123; console.log("hotel foo"); &#125; &#125; foo &amp;&amp; foo(); &#125;/* 引起的bug：第一种写法foo的声明被提前了; 调用call时：第一种写法会调用foo函数，第二种写法不会调用foo函数 */ 8.（禁止）使用eval，采取$.parseJSON 三个原因： 有注入风险，尤其是ajax返回数据 不方便debug 效率低，eval是一个执行效率很低的函数 建议： 使用new Function来代替eval的使用，最好就别用。 9.除了三目运算，if,else等（禁止）简写 12345678910111213// 正确的书写if (true) &#123; alert(name);&#125;console.log(name);// 不推荐的书写if (true) alert(name);console.log(name);// 不推荐的书写if (true)alert(name);console.log(name) 10.（推荐）在需要以{}闭合的代码段前增加换行，如：for if 1234567891011121314151617181920212223242526272829303132// 没有换行，小的代码段无法区分 if (wl &amp;&amp; wl.length) &#123; for (i = 0, l = wl.length; i &lt; l; ++i) &#123; p = wl[i]; type = Y.Lang.type(r[p]); if (s.hasOwnProperty(p)) &#123; if (merge &amp;&amp; type == 'object') &#123; Y.mix(r[p], s[p]); &#125; else if (ov || !(p in r)) &#123; r[p] = s[p]; &#125; &#125; &#125; &#125; // 有了换行，逻辑清楚多了 if (wl &amp;&amp; wl.length) &#123; for (i = 0, l = wl.length; i &lt; l; ++i) &#123; p = wl[i]; type = Y.Lang.type(r[p]); if (s.hasOwnProperty(p)) &#123; // 处理merge逻辑 if (merge &amp;&amp; type == 'object') &#123; Y.mix(r[p], s[p]); &#125; else if (ov || !(p in r)) &#123; r[p] = s[p]; &#125; &#125; &#125; &#125;/* 换行可以是空行，也可以是注释 */ 11.（推荐）使用Function进行类的定义，(不推荐)继承，如需继承采用成熟的类库实现继承 12345678910111213141516171819// 类的实现 function Person(name) &#123; this.name = name; &#125; Person.prototype.sayName = function() &#123; alert(this.name); &#125;; var me = new Person("Nicholas"); // 将this放到局部变量self function Persion(name, sex) &#123; var self = this; self.name = name; self.sex = sex; &#125;/* 平时咱们写代码，基本都是小程序，真心用不上什么继承，而且继承并不是JS的擅长的语言特性，尽量少用。如果非要使用的话，注意一点： */ 123456789function A()&#123; //...&#125;function B()&#123; //...&#125;B.prototype = new A();B.prototype.constructor = B; //原则上，记得把这句话加上/* 继承从原则上来讲，别改变他的构造函数，否则这个继承就显得很别扭了~ */ 12.(推荐)使用局部变量缓存反复查找的对象(包括但不限于全局变量、dom查询结果、作用域链较深的对象) 1234567// 缓存对象var getComment = function() &#123; var dom = $("#common-container"), // 缓存dom appendTo = $.appendTo, // 缓存全局变量 data = this.json.data; // 缓存作用域链较深的对象&#125; 13.当需要缓存 this 时必须使用 self 变量进行缓存 12345678910// 缓存this function Row(name) &#123; var self = this; self.name = name; $(".row").click(function() &#123; self.getName(); &#125;); &#125;/* self是一个保留字，不过用它也没关系。在这里，看个人爱好吧，可以用_this, that, me等这些词，都行，但是团队开发的时候统一下比较好。 */ 14.（不推荐）超长函数, 当函数超过100行，就要想想是否能将函数拆为两个或多个函数 15.待挖掘… 小结规范是死的，罗列这些东西，目的是为了让程序猿们对这些东西引起注意，平时写代码的时候注意格式，不仅仅方便了自己，也让其他阅读者看得舒服。可能还有一些地方没有涉及到，如果你有好的建议，欢迎提出来补充！]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>编码规范</tag>
      </tags>
  </entry>
</search>