<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript数组及JSON操作]]></title>
    <url>%2F2017%2F05%2F13%2FJavaScript%E6%95%B0%E7%BB%84%E5%8F%8AJSON%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[JavaScript数组及JSON操作javascript删除数组的3种方法1.用shift()方法shift：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined 123var myArray=[2,34,56,32,12,9];var a=myArray.shift(); // 得到2console.log(myArray); // [34,56,,32,12,9] 2.用pop()方法pop：删除原数组最后一项，并返回删除元素的值；如果数组为空则返回undefined 123var myArray=[2,34,56,32,12,9];var a=myArray.pop(); // 得到9console.log(myArray); // [2,34,56,,32,12] 前面的方法只能操作数组开头和结尾，无法操作中间项，如果要操作中间的项，使用splice方法 3.用splice方法这个方法很强大，可以对数组任意项进行增加，删除，替换操作 删除操作123var myArray=[2,34,56,32,12,9];var a=myArray.splice(2,1); // 得到56console.log(myArray); // [2,34,32,12,9] 上面例子中，把myArray中的索引为2开始的1项替换成空的，因为后面没有内容，结果可以看到，把56这项删除了 修改操作：123var myArray=[2,34,56,32,12,9];var a=myArray.splice(2,1,8,9); // 得到56console.log(myArray); // [2,34,8,9,32,12,9] 第一个参数是准备操作的数组索引，第二个参数是操作位置后面的数组项数，第三个以后的就是，被替换后的内容 添加操作123var myArray=[2,34,56,32,12,9];var a=myArray.splice(2,0,8,9); // 得到空[]console.log(myArray); // [2,34,8,9,56,32,12,9] 从数组索引为2后的0项换成8,9，也就等于添加了两项 javascript对JSON增删改查概要JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式,同时，JSON是 JavaScript 原生格式，这意味着在 JavaScript 中处理 JSON数据不须要任何特殊的 API 或工具包。 在JSON中，有两种结构：对象和数组 1、对象以“{”开始，“}”结束，“key/value”之间运用 “,”分隔。1packJson=&#123;"name":"Liza","password":"123"&#125; 2、数组以“[”开始，“]”结束。值之间运用 “,”分隔。1packJson=[&#123;"name":"Liza","password":"123"&#125;,&#123;"name":"Mike","password":"456"&#125;]; JSON对象和JSON字符串的转换在数据传输过程中，JSON是以字符串的形式传递的，而JS操作的是JSON对象，所以，JSON对象和JSON字符串之间的相互转换是关键。如下： JSON字符串： 1var jsonStr='&#123;"name":"Liza","password":"123"&#125;'; JSON对象： 1var packJson=[&#123;"name":"Liza","password":"123"&#125;,&#123;"name":"Mike","password":"456"&#125;]; 1、将String转化为JSON 1var jsonObject=jQuery.parseJSON(jsonStr); 2、将JSON转化为String 1var jsonStr=JSON.stringify(jsonObject) 增删改查Demo 1234567891011121314151617181920212223242526272829303132var p =&#123; "name": "kakaxi", "age":45, "sex":"male"&#125;;function JsonOperation()&#123; // 读取 for(var i in p)&#123; console.log(i+'=='+p[i]); // name==kakaxi... &#125; // 查找 console.log(p['age']); // 45 console.log(p.age); // 45 // 增加 p['卡卡西']='copy忍者，木叶上忍'; p['鼬']='天才忍者'; console.log(p['卡卡西']); // copy忍者，木叶上忍 // 修改 p.age=88; console.log(p['age']); // 88 // 删除 delete p['name']; delete p.age; for(var i in p)&#123; console.log(i+'=='+p[i]); // 已删除 name、age项 &#125;&#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript常用函数]]></title>
    <url>%2F2017%2F05%2F08%2FJavaScript%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[常规函数 alert函数：显示一个警告对话框，包括一个OK按钮。 confirm函数：显示一个确认对话框，包括OK、Cancel按钮。 escape函数：将字符转换成Unicode码。 eval函数：计算表达式的结果。 isNaN函数：测试是(true)否(false)不是一个数字。 parseFloat函数：将字符串转换成符点数字形式。 parseInt函数：将符串转换成整数数字形式(可指定几进制)。 prompt函数：显示一个输入对话框，提示等待用户输入。例如： 123alert("输入错误"); prompt("请输入您的姓名","姓名");confirm("确定否！"); unescape函数：解码由escape函数编码的字符。 toFixed 函数:这个函数牛逼 就是转化小数点几位的 checkprice.toFixed(2)； 将checkprice转化为有小数点后两位的值 数组函数javascript数组函数包括以下4个函数：(1) join函数：转换并连接数组中的所有元素为一个字符串。例: 123456function JoinDemo()&#123; var a, b; a = new Array(0,1,2,3,4); b = a.join("-");//分隔符 return(b);//返回的b=="0-1-2-3-4" &#125; (2) length函数：返回数组的长度。例： 123456function LengthDemo()&#123; var a, l; a = new Array(0,1,2,3,4); l = a.length; return(l);//l==5 &#125; (3) reverse函数：将数组元素顺序颠倒。例： 123456function ReverseDemo()&#123; var a, l; a = new Array(0,1,2,3,4); l = a.reverse(); return(l); &#125; (4) sort函数：将数组元素重新排序。例： 123456function SortDemo()&#123; var a, l; a = new Array("X" ,"y" ,"d", "Z", "v","m","r"); l = a.sort(); return(l); &#125; (5) push函数:将新元素添加到一个数组中，并返回数组的新长度值。例: 12345&lt;script type="text/javascript"&gt; var my_array = new Array('1','2','3','4'); my_array.push('5','6','7','8'); alert(my_array.length); //将返回8 数组中添加了4个元素&lt;/script&gt; (6) unshift函数：将指定的元素插入数组开始位置并返回该数组。例： 12345&lt;script type="text/javascript"&gt; var my_array = new Array('1','2','3','4'); my_array.unshift('0'); //在数组前面追加元素 alert(my_array.length); //返回5&lt;/script&gt; (7) pop函数:移除数组中的最后一个元素并返回该元素。例: 12345&lt;script type="text/javascript"&gt; var my_array = new Array('1','2','3','411'); alert(my_array.pop()); //返回411 alert(my_array.length); //返回3&lt;/script&gt; (8) shift函数:移除数组中的第一个元素并返回该元素。例: 12345&lt;script type="text/javascript"&gt; var my_array = new Array('1','2','3','4'); alert(my_array.shift()); //返回1 alert(my_array.length); //返回3&lt;/script&gt; (9) Obj.slice(start,end) 返回一个数组的一段，得到一个新数组。注意不包括 end 对应的元素，如果省略 end 将复制 start 之后的所有元素,例如： 123456789&lt;script type="text/javascript"&gt; var my_array = new Array('1','2','3','4'); var new_array = my_array.slice(0,2); //返回0-2个元素 var new_array = my_array.slice(0,-1); //返回除了最后一个之外的元素 var new_array = my_array.slice(0); //返回第0以后的所有的元素 for(var i =0;i&lt;new_array.length;i++)&#123; alert(new_array[i]); &#125;&lt;/script&gt; (10) Obj.concat(item1,item2,item3,item4,item5……) 返回一个新数组，这个新数组是由两个或更多数组（也可以是一个变量）组合而成的,。例: 12345678910&lt;script type="text/javascript"&gt; var my_array = new Array('1','2','3','4'); var my_array1 = new Array('5','6'); var my_array2 = new Array('7','8'); var my_array3 = new Array('9'); var my_name = 'SmarTop'; //也可以是一个字符串 var my_age = 26; //也可以是一个数字 var new_array = my_array.concat(my_array1,my_array2,my_array3,my_name,my_age); alert(new_array);&lt;/script&gt; 日期函数javascript日期函数包括以下20个函数： (1) getDate函数：返回日期的”日”部分，值为1～31。例： 12345678function DateDemo()&#123; var d, s = "Today's date is: "; d = new Date(); s += (d.getMonth() + 1) + "/"; s += d.getDate() + "/"; s += d.getYear(); return(s);&#125; (2) getDay函数：返回星期几，值为0～6，其中0表示星期日，1表示星期一，…，6表示星期六。例： 123456789function DateDemo()&#123; var d, day, x, s = "Today is: "; var x = new Array("Sunday", "Monday", "Tuesday"); var x = x.concat("Wednesday","Thursday", "Friday"); var x = x.concat("Saturday"); d = new Date(); day = d.getDay(); return(s += x[day]);&#125; (3) getHours函数：返回日期的”小时”部分，值为0～23。例： 12345678910function TimeDemo()&#123; var d, s = "The current local time is: "; var c = ":"; d = new Date(); s += d.getHours() + c; s += d.getMinutes() + c; s += d.getSeconds() + c; s += d.getMilliseconds(); return(s);&#125; (4) getMinutes函数：返回日期的”分钟”部分，值为0～59。见上例。(5) getMonth函数：返回日期的”月”部分，值为0～11。其中0表示1月，2表示3月，…，11表示12月。见前面的例子。(6) getSeconds函数：返回日期的”秒”部分，值为0～59。见前面的例子。(7) getTime函数：返回系统时间。 1234567891011function GetTimeTest()&#123; var d, s, t; var MinMilli = 1000 * 60; var HrMilli = MinMilli * 60; var DyMilli = HrMilli * 24; d = new Date(); t = d.getTime(); s = "It's been " s += Math.round(t / DyMilli) + " days since 1/1/70"; return(s);&#125; (8) getTimezoneOffset函数：返回此地区的时差(当地时间与GMT格林威治标准时间的地区时差)，单位为分钟。 123456789101112function TZDemo()&#123; var d, tz, s = "The current local time is "; d = new Date(); tz = d.getTimezoneOffset(); if (tz &lt; 0) s += tz / 60 + " hours before GMT"; else if (tz == 0) s += "GMT"; else s += tz / 60 + " hours after GMT"; return(s);&#125; (9) getYear函数：返回日期的”年”部分。返回值以1900年为基数，例如1999年为99。前面有例子。(10) parse函数：返回从1970年1月1日零时整算起的毫秒数(当地时间)。 123456789101112function GetTimeTest(testdate)&#123; var d, s, t; var MinMilli = 1000 * 60; var HrMilli = MinMilli * 60; var DyMilli = HrMilli * 24; d = new Date(); t = Date.parse(testdate); s = "There are " s += Math.round(Math.abs(t / DyMilli)) + " days " s += "between " + testdate + " and 1/1/70"; return(s);&#125; (11) setDate函数：设定日期的”日”部分，值为0～31。(12) setHours函数：设定日期的”小时”部分，值为0～23。(13) setMinutes函数：设定日期的”分钟”部分，值为0～59。(14) setMonth函数：设定日期的”月”部分，值为0～11。其中0表示1月，…，11表示12月。(15) setSeconds函数：设定日期的”秒”部分，值为0～59。(16) setTime函数：设定时间。时间数值为1970年1月1日零时整算起的毫秒数。(17) setYear函数：设定日期的”年”部分。(18) toGMTString函数：转换日期成为字符串，为GMT格林威治标准时间。(19) setLocaleString函数：转换日期成为字符串，为当地时间。(20) UTC函数：返回从1970年1月1日零时整算起的毫秒数，以GMT格林威治标准时间计算。 数学函数javascript数学函数其实就是Math对象，它包括属性和函数(或称方法)两部分。其中，属性主要有下列内容。Math.e:e(自然对数)、Math.LN2（2的自然对数)、Math.LN10(10的自然对数)、Math.LOG2E(e的对数，底数为2)、 Math.LOG10E(e的对数，底数为10)、Math.PI(π)、Math.SQRT1_2(1/2的平方根值)、Math.SQRT2(2的平方根值)。函数有以下18个：(1) abs函数：即Math.abs(以下同)，返回一个数字的绝对值。(2) acos函数：返回一个数字的反余弦值，结果为0～π弧度(radians)。(3) asin函数：返回一个数字的反正弦值，结果为-π/2～π/2弧度。(4) atan函数：返回一个数字的反正切值，结果为-π/2～π/2弧度。(5) atan2函数：返回一个坐标的极坐标角度值。(6) ceil函数：返回一个数字的最小整数值(大于或等于)。(7) cos函数：返回一个数字的余弦值，结果为-1～1。(8) exp函数：返回e(自然对数)的乘方值。(9) floor函数：返回一个数字的最大整数值(小于或等于)。(10) log函数：自然对数函数，返回一个数字的自然对数(e)值。(11) max函数：返回两个数的最大值。(12) min函数：返回两个数的最小值。(13) pow函数：返回一个数字的乘方值。(14) random函数：返回一个0～1的随机数值。(15) round函数：返回一个数字的四舍五入值，类型是整数。(16) sin函数：返回一个数字的正弦值，结果为-1～1。(17) sqrt函数：返回一个数字的平方根值。(18) tan函数：返回一个数字的正切值。 字符串函数(1) concat函数:将两个或多个字符的文本组合起来，返回一个新的字符串。 12345var a = "hello";var b = ",world";var c = a.concat(b);alert(c);//c = "hello,world" (2) indexOf函数：返回字符串中一个子串第一处出现的索引（从左到右搜索）。如果没有匹配项，返回 -1 。 1234var index1 = a.indexOf("l");//index1 = 2var index2 = a.indexOf("l",3); //3表示从第三个开始向右搜索//index2 = 3 (3) lastIndexOf:返回字符串中一个子串第一处出现的索引（从右到左搜索）。如果没有匹配项，返回 -1 。 1234var index1 = lastIndexOf('l');//index1 = 3var index2 = lastIndexOf('l',2)//3表示从第三个开始向左搜索//index2 = 2 (4) charAt：返回字符串中指定的某个字符。 12var get_char = a.charAt(0);//get_char = "h" (5) match：检查一个字符串匹配一个正则表达式内容，如果没有匹配返回 null。 12345var re = new RegExp(/^\w+$/); //存储检索模式var is_alpha1 = a.match(re);//is_alpha1 = "hello"var is_alpha2 = b.match(re);//is_alpha2 = null (6) substring:返回位于 String 对象中指定位置的子字符串。 1234var sub_string1 = a.substring(1);//sub_string1 = "ello"var sub_string2 = a.substring(1,4);//sub_string2 = "ell" (6) substr：返回字符串的一个子串，传入参数是起始位置和长度 1234var sub_string1 = a.substr(1);//sub_string1 = "ello"var sub_string2 = a.substr(1,4); //长度//sub_string2 = "ello" (7) replace：用来查找匹配一个正则表达式的字符串，然后使用新字符串代替匹配的字符串。 12345var r, re; // 声明变量。var ss = "The man hit the ball with the bat.\n";ss += "while the fielder caught the ball with the glove.";re = /The/g; // 创建正则表达式模式。r = ss.replace(re, "A"); // 用 "A" 替换 "The"。 var r, re; // 声明变量。var ss = “The rain in Spain falls mainly in the plain.”;re = /(\S+)(\s+)(\S+)/g; // 创建正则表达式模式。r = ss.replace(re, “$3$2$1”); // 交换每一对单词。 (8) search：执行一个正则表达式匹配查找。如果查找成功，返回字符串中匹配的索引值。否则返回 -1 。 1234var index1 = a.search(re);//index1 = 0var index2 = b.search(re);//index2 = -1 (9) slice:提取字符串的一部分，并返回一个新字符串（与 substring 相同）。 1234var sub_string1 = a.slice(1);//sub_string1 = "ello"var sub_string2 = a.slice(1,4);//sub_string2 = "ell" (10) split:通过将字符串划分成子串，将一个字符串做成一个字符串数组。 123var arr1 = a.split(""); //使用分割的字符 //arr1 = [h,e,l,l,o] length (11) length:返回字符串的长度，所谓字符串的长度是指其包含的字符的个数。 12var len = a.length(); //len = 5 (12) toLowerCase:将整个字符串转成小写字母。 12var lower_string = a.toLowerCase();//lower_string = "hello" (13) toUpperCase:将整个字符串转成大写字母。 12var upper_string = a.toUpperCase();//upper_string = "HELLO"]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>常用函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript事件]]></title>
    <url>%2F2017%2F05%2F07%2FJavaScript%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[与浏览器进行交互的时候浏览器就会触发各种事件。比如当我们打开某一个网页的时候，浏览器加载完成了这个网页，就会触发一个 load 事件；当我们点击页面中的某一个“地方”，浏览器就会在那个“地方”触发一个 click 事件。 这样，我们就可以编写 JavaScript，通过监听某一个事件，来实现某些功能扩展。例如监听 load 事件，显示欢迎信息，那么当浏览器加载完一个网页之后，就会显示欢迎信息。 下面就来介绍一下事件。 基础事件操作监听事件浏览器会根据某些操作触发对应事件，如果我们需要针对某种事件进行处理，则需要监听这个事件。监听事件的方法主要有以下几种： HTML 内联属性（避免使用）HTML 元素里面直接填写事件有关属性，属性值为 JavaScript 代码，即可在触发该事件的时候，执行属性值的内容。 例如： 1&lt;button onclick="alert('你点击了这个按钮');"&gt;点击这个按钮&lt;/button&gt; 上面代码就是监听 element 节点的 click 事件。它比较简单易懂，而且有较好的兼容性。但是也有缺陷，因为直接赋值给对应属性，如果你在后面代码中再次为 element 绑定一个回调函数，会覆盖掉之前回调函数的内容。 虽然也可以用一些方法实现多个绑定，但还是推荐下面的标准事件监听函数。 DOM 属性绑定也可以直接设置 DOM 属性来指定某个事件对应的处理函数，这个方法比较简单： 123456element.onclick = function(event)&#123; alert('你点击了这个按钮');&#125;;/* 上面代码就是监听 element 节点的 click 事件。它比较简单易懂，而且有较好的兼容性。但是也有缺陷，因为直接赋值给对应属性，如果你在后面代码中再次为 element 绑定一个回调函数，会覆盖掉之前回调函数的内容。虽然也可以用一些方法实现多个绑定，但还是推荐下面的标准事件监听函数。 */ 使用事件监听函数标准的事件监听函数如下： 1element.addEventListener(&lt;event-name&gt;, &lt;callback&gt;, &lt;use-capture&gt;); 表示在 element 这个对象上面添加一个事件监听器，当监听到有 &lt;event-name&gt; 事件发生的时候，调用 &lt;callback&gt; 这个回调函数。至于 &lt;use-capture&gt; 这个参数，表示该事件监听是在“捕获”阶段中监听（设置为 true）还是在“冒泡”阶段中监听（设置为 false）。关于捕获和冒泡，我们会在下面讲解。 用标准事件监听函数改写上面的例子： 1234567&lt;button id="btn"&gt;点击这里&lt;/button&gt;&lt;script&gt;var btn = document.getElementById('btn');btn.addEventListener('click', function()&#123; alert('你点击了这里');&#125;, false);&lt;/script&gt; 移除事件监听当我们为某个元素绑定了一个事件，每次触发这个事件的时候，都会执行事件绑定的回调函数。如果我们想解除绑定，需要使用 removeEventListener 方法： 1element.removeEventListener(&lt;event-name&gt;, &lt;callback&gt;, &lt;use-capture&gt;); 需要注意的是，绑定事件时的回调函数不能是匿名函数，必须是一个声明的函数，因为解除事件绑定时需要传递这个回调函数的引用，才可以断开绑定。例如： 123456789&lt;button id="btn"&gt;点击这里&lt;/button&gt;&lt;script&gt; var btn = document.getElementById('btn'); var fun = function()&#123; alert('这个按钮只支持一次点击'); btn.removeEventListener('click', fun, false);&#125;;btn.addEventListener('click', fun, false);&lt;/script&gt; 事件触发过程在上面大体了解了事件是什么、如何监听并执行某些操作，但我们对事件触发整个过程还不够了解。 下图就是事件的触发过程，借用了 W3C 的图片 JavaScript中的一些常用事件onclick事件点击事件（onclick并不是js中的方法，onclick只是浏览器提供js的一个dom接口，让js可以操作dom，所以onclick大小写都是没问题的，比如HTML代码就不用区分大小写） 1234567&lt;buttononclick="myFunction()"&gt;点击这里&lt;/button&gt;&lt;script&gt; functionmyFunction()&#123; alert("测试onclick点击事件"); &#125;&lt;/script&gt; onclick通常在下列基本对象中产生： button(按钮对象)、checkbox(复选框)、radio(单选框)、reset buttons(重置按钮)、submit buttons(提交按钮) onload事件可以body执行，,其中onload后面可以写一个方法，如：onload=”test()”,然后在JavaScript中写一个test()方法，则在页面一开始加载的时候会先调用这个方法 12345678&lt;bodyonload="test()"&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; functiontest()&#123; alert("测试onload方法"); &#125;&lt;/script&gt; 注意：此方法只能写在标签之中 onchange事件事件在内容改变的时候触发，和jQuery中的change()方法一样 当内容改变时触发。可用于文本框、列表框等对象，该事件一般用于响应用户修改内容带来的其他改变操作。 说明：当用户向一个文本框中输入文本时，不会触发onchange事件，只有用户输入结束后，单击文本框以外的区域，使文本框失去焦点时才触发该事件，如果是下拉框，则选择结束后即触发。 1234567891011&lt;p&gt; &lt;labelfor="name"&gt;用户名：&lt;/label&gt; &lt;input type="text" id="fname" onchange="upperCase()" value=""/&gt;&lt;/p&gt;&lt;script type="text/javascript"&gt; functionupperCase()&#123; var x = document.getElementById("fname").value; document.getElementById("fname").value = x.toUpperCase(); &#125;&lt;/script&gt; 说明：上例实际效果是，当输入框失去焦点时内容转成大写。出现这种情况是由于input必须是失去焦点才会检测到内容发生改变。而change事件通常是用于下拉菜单select标签。 onblur事件和onfocus事件onblur事件：当前元素失去焦点时触发该事件；onfocus事件：得到焦点事件 123456789101112131415&lt;body&gt;失去焦点：&lt;inputtype="text" name="name" value=" "size="30" onblur="chkvalue(this)"&gt;&lt;br&gt;得到焦点：&lt;inputtype="text" id="name" value="" size="30" onfocus="setStyle(this.id)"&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; function chkvalue(txt) &#123; if(txt.value=="") alert("文本框里必须填写内容!"); &#125; function setStyle(x)&#123; document.getElementById(x).style.background="yellow" &#125;&lt;/script&gt; onscroll事件窗口滚动事件：当页面滚动时调用函数。此事件写在方法的外面，且函数名后面不加括号，例如window.onscroll=move 123456&lt;script type="text/javascript"&gt; functionmove() &#123; alert("页面滚动时调用"); &#125; window.onscroll = move;&lt;/script&gt; onsubmit事件属于表单元素，写在表单标签内。语法：onsubmit=”return 函数名()” 1234567891011&lt;form action="" method="post" name="testForm" onsubmit="returnmove()"&gt; &lt;inputtype="text"name="name"value=""&gt; &lt;br&gt; &lt;input type="submit" name="submit" value="测试onsubmit"/&gt;&lt;/form&gt;&lt;script type="text/javascript"&gt; functionmove() &#123; alert("测试onsubmit........"+testForm.name.value); &#125;&lt;/script&gt; 鼠标相关事件onmousemove和onmouseout和onmouseover事件Onmouseover:鼠标移动到某对象范围的上方时，触发事件调用函数。注意：在同一个区域中，无论怎样移动都只触发一次函数。 Onmouseout:鼠标离开某对象范围时，触发事件调用函数。 Onmousemove:鼠标移动到某对象范围的上方时，触发事件调用函数。注意：在同一个区域中，只要鼠标动一次就触发一次事件。 12345678910111213&lt;img onmousemove="bigImg(this)" onmouseout="normalImg(this)" border="0" src="images/defaultAvatar.gif" alt="Smiley"&gt;&lt;script type="text/javascript"&gt; functionbigImg(x)&#123; x.style.height="180px"; x.style.width="180px"; &#125; functionnormalImg(x)&#123; x.style.height="128px"; x.style.width="128px"; &#125;&lt;/script&gt; onmouseup和onmousedownOnmouseup:当鼠标松开时触发事件 Onmousedown:当鼠标按下键时触发事件 123456789101112&lt;p id="p1" onmousedown="mouseDown()" onmouseup="mouseUp()"&gt;请点击文本！mouseDown()函数当鼠标按钮在段落上被按下时触发。此函数把文本颜色设置为红色。mouseUp() 函数在鼠标按钮被释放时触发。mouseUp() 函数把文本的颜色设置为绿色。&lt;/p&gt;&lt;script type="text/javascript"&gt; functionmouseDown()&#123; document.getElementById("p1").style.color="red"; &#125; functionmouseUp()&#123; document.getElementById("p1").style.color="green"; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript之DOM操作]]></title>
    <url>%2F2017%2F05%2F06%2Fjavascript%E4%B9%8BDOM%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[前言DOM 中的三个字母，D（文档）可以理解为整个 Web 加载的网页文档；O（对象）可以理解为类似 window 对象之类的东西，可以调用属性和方法，这里我们说的是 document对象；M（模型）可以理解为网页文档的树型结构。 一、document.getElementById() 根据Id获取元素节点1234567891011&lt;div id="div1"&gt; &lt;p id="p1"&gt; 我是第一个P&lt;/p&gt; &lt;p id="p2"&gt; 我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var str = document.getElementById("p1").innerHTML; alert(str); //弹出 我是第一个P &#125; 二、document.getElementsByName() 根据name获取元素节点12345678910111213&lt;div id="div1"&gt; &lt;p id="p1"&gt; 我是第一个P&lt;/p&gt; &lt;p id="p2"&gt; 我是第二个P&lt;/p&gt; &lt;input type="text" value="请输入值" name="userName" /&gt; &lt;input type="button" value="确定" onclick="fun1()"&gt;&lt;/div&gt; function fun1() &#123; var username = document.getElementsByName("userName")[0].value; alert(username); //输出userName里输入的值&#125; 三、document.getElementsByTagName() 根据HTML标签名获取元素节点，注意getElements*的选择器返回的是一个NodeList对象，能根据索引号选择其中1个，可以遍历输出。123456789101112131415161718192021222324&lt;div id="div1"&gt; &lt;p id="p1"&gt; 我是第一个P&lt;/p&gt; &lt;p id="p2"&gt; 我是第二个P&lt;/p&gt; &lt;/div&gt; window.onload = function () &#123; var str = document.getElementsByTagName("p")[1].innerHTML; alert(str); //输出 我是第二个P，因为获取的是索引为1的P，索引从0开始 &#125; window.onload = function () &#123; var arr = document.getElementsByTagName("p"); for (var i = 0; i &lt; arr.length; i++) &#123; alert(arr[i].innerHTML); &#125; &#125; window.onload = function () &#123; var node = document.getElementById("div1"); var node1 = document.getElementsByTagName("p")[1]; //从获取到的元素再获取 alert(node1.innerHTML); &#125; 四、document.getElementsByClassName() 根据class获取元素节点1234567891011&lt;div id="div1"&gt; &lt;p id="p1" class="class1"&gt; 我是第一个P&lt;/p&gt; &lt;p id="p2"&gt; 我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var node = document.getElementsByClassName("class1")[0]; alert(node.innerHTML); &#125; 五、javascript中的CSS选择器1234567891011121314151617181920document.querySelector() //根据CSS选择器的规则，返回第一个匹配到的元素document.querySelectorAll() //根据CSS选择器的规则，返回所有匹配到的元素&lt;div id="div1"&gt; &lt;p id="p1" class="class1"&gt; 我是第一个P&lt;/p&gt; &lt;p id="p2" class="class2"&gt; 我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var node = document.querySelector("#div1 &gt; p"); alert(node.innerHTML); //输出 我是第一个P var node1 = document.querySelector(".class2"); alert(node1.innerHTML); //输出 我是第二个P var nodelist = document.querySelectorAll("p"); alert(nodelist[0].innerHTML + " - " + nodelist[1].innerHTML); //输出 我是第一个P - 我是第二个P&#125; 六、文档结构和遍历作为节点数的文档 ​ parentNode 获取该节点的父节点 ​ childNodes 获取该节点的子节点数组 ​ firstChild 获取该节点的第一个子节点 ​ lastChild 获取该节点的最后一个子节点 ​ nextSibling 获取该节点的下一个兄弟元素 ​ previoursSibling 获取该节点的上一个兄弟元素 ​ nodeType 节点的类型，9代表Document节点，1代表Element节点，3代表Text节点，8代表 Comment节点，11代表DocumentFragment节点 ​ nodeVlue Text节点或Comment节点的文本内容 ​ nodeName 元素的标签名(如P,SPAN,#text(文本节点),DIV)，以大写形式表示 注意，以上6个方法连元素节点也算一个节点。 12345678910111213141516171819202122232425262728293031323334353637&lt;div id="div1"&gt; &lt;p id="p1" class="class1"&gt; 我是第一个P&lt;/p&gt; &lt;p id="p2" class="class2"&gt; 我是第二个P&lt;/p&gt;&lt;/div&gt; window.onload = function () &#123; var node1 = document.querySelector(".class2"); alert(node1.parentNode.innerHTML); //输出 &lt;p id="p1" class="class1"&gt;我是第一个P&lt;/p&gt;&lt;p id="p2" class="class2"&gt;我是第二个P&lt;/p&gt; var nodelist = document.getElementById("div1"); var arr = nodelist.childNodes; alert(arr[1].innerHTML + " - " + arr[3].innerHTML); //输出 我是第一个P - 我是第二个P 为什么是1，3呢？因为本方法文本节点也会获取，也就是说0,2,4是文本节点 &#125;&lt;div id="div1"&gt; 文本1 &lt;p id="p1" class="class1"&gt; 我是第一个P&lt;/p&gt; 文本2 &lt;p id="p2" class="class2"&gt; 我是第二个P&lt;/p&gt; 文本3&lt;/div&gt;window.onload = function () &#123; //依次输出，文本1，我是第一个P，文本2，我是第二个P，文本3 var node = document.getElementById("div1"); for (var i = 0; i &lt; node.childNodes.length; i++) &#123; if (node.childNodes[i].nodeType == 1) &#123; alert(node.childNodes[i].innerHTML); &#125; else if (node.childNodes[i].nodeType == 3) &#123; alert(node.childNodes[i].nodeValue); &#125; &#125;&#125; 作为元素树的文档 ​ firstElementChild 第一个子元素节点 ​ lastElementChild 最后一个子元素节点 ​ nextElementSibling 下一个兄弟元素节点 ​ previousElementSibling 前一个兄弟元素节点 ​ childElementCount 子元素节点个数量 注意，此5个方法文本节点不算进去 123456789101112131415161718&lt;div id="div1"&gt; &lt;p id="p1" class="class1"&gt; 我是第一个P&lt;/p&gt; &lt;p id="p2" class="class2"&gt; 我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var node = document.getElementById("div1"); var node1 = node.firstElementChild; var node2 = node.lastElementChild; alert(node.childElementCount); //输出2，div1一共有两个非文档子元素节点 alert(node1.innerHTML); //输出 我是第一个P alert(node2.innerHTML); //输出 我是第二个P alert(node2.previousElementSibling.innerHTML); //输出 我是第一个P(第二个元素节点的上一个非文本元素节点是P1) alert(node1.nextElementSibling.innerHTML); //输出 我是第二个P(第一个元素节点的下一个兄弟非文本节点是P2)&#125; 七、javascript操作HTML属性1、属性的读取，此处要注意的是，某些HTML属性名称在javascript之中是保留字，因此会有些许不同，如class,lable中的for在javascript中变为htmlFor,className。1234567891011121314&lt;div id="div1"&gt; &lt;p id="p1" class="class1"&gt; 我是第一个P&lt;/p&gt; &lt;img src="123.jpg" alt="我是一张图片" id="img1" /&gt; &lt;input type="text" value="我是一个文本框" id="input1" /&gt;&lt;/div&gt;window.onload = function () &#123; var nodeText = document.getElementById("input1"); alert(nodeText.value); //输出 我是一个文本框 var nodeImg = document.getElementById("img1"); alert(nodeImg.alt); //输出 我是一张图片 var nodeP = document.getElementById("p1"); alert(nodeP.className); //输出 class1 注意获取class是className，如果写成nodeP.class则输出undefined&#125; 2、属性的设置，此处同样要注意的是保留字1234567&lt;div id="div1"&gt; &lt;img src="1big.jpg" alt="我是一张图片" id="img1" onclick="fun1()" /&gt;&lt;/div&gt;function fun1() &#123; document.getElementById("img1").src = "1small.jpg"; //改变图片的路径属性。实现的效果为，当点击图片时，大图变小图。&#125; 3、非标准HTML属性getAttribute(); // 注意这两个方法是不必理会javascript保留字的，HTML属性是什么就怎么写。setAttribute(); 12345678&lt;div id="div1"&gt; &lt;img src="1big.jpg" alt="我是一张图片" class="imgClass" id="img1" onclick="fun1()" /&gt;&lt;/div&gt;function fun1() &#123; document.getElementById("img1").setAttribute("src", "1small.jpg"); alert(document.getElementById("img1").getAttribute("class"));&#125; 4、Attr节点的属性attributes属性 非Element对象返回null，Element一半返回Attr对象。Attr对象是一个特殊的Node,通过name与value获取属性名称与值。如:document.getElementById(“img1”)[0]; document.getElementById(“img1”).src; 123456789&lt;div id="div1"&gt; &lt;img src="1big.jpg" alt="我是一张图片" class="imgClass" id="img1" onclick="fun1()" /&gt;&lt;/div&gt;function fun1() &#123; alert(document.getElementById("img1").attributes[0].name); //输出 onclick 注意，通过索引器访问是写在右面在排前面，从0开始 alert(document.getElementById("img1").attributes.src.value); //输出1big.jpg document.getElementById("img1").attributes.src.value = "1small.jpg"; //点击后改变src属性，实现了点击大图变小图效果&#125; 八、元素的内容1、innerText、textContent innerText与textContent的区别，当文本为空时，innerText是””，而textContent是undefined2、innerHTML 123456789101112&lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p id="p2"&gt;我是第&lt;b&gt;二&lt;/b&gt;个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; alert(document.getElementById("p1").innerText); //注意火狐浏览器不支持innerText alert(document.getElementById("p1").textContent); //基本都支持textContent document.getElementById("p1").textContent = "我是p1，javascript改变了我"; //设置文档Text alert(document.getElementById("p2").textContent); alert(document.getElementById("p2").innerHTML); //innerHTML与innerText的区别，就是对HTML代码的输出方式Text不会输出HTML代码&#125; 九、创建，插入，删除节点1、document.createTextNode() 创建一个文本节点12345678910111213141516&lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p id="p2"&gt;我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var textNode = document.createTextNode("&lt;p&gt;我是一个javascript新建的节点&lt;/p&gt;"); document.getElementById("div1").appendChild(textNode);&#125;/* 完成后HTML变为： div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p id="p2"&gt;我是第二个P&lt;/p&gt; &lt;p&gt;我是一个javascript新建的节点&lt;/p&gt; &lt;/div&gt; */ 2、document.createElement() 创建一个元素节点12345678910111213141516&lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p id="p2"&gt;我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var pNode = document.createElement("p"); pNode.textContent = "新建一个P节点"; document.getElementById("div1").appendChild(pNode);&#125;/* &lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p id="p2"&gt;我是第二个P&lt;/p&gt; &lt;p&gt;新建一个P节点&lt;/p&gt; &lt;/div&gt; */ 3、插入节点appendChild() //将一个节点插入到调用节点的最后面insertBefore() //接受两个参数，第一个为待插入的节点，第二个指明在哪个节点前面，如果不传入第二个参数，则跟appendChild一样，放在最后。 12345678910111213141516171819&lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var pNode1 = document.createElement("p"); pNode1.textContent = "insertBefore插入的节点"; var pNode2 = document.createElement("p"); pNode2.textContent = "appendChild插入的节点"; document.getElementById("div1").appendChild(pNode2); document.getElementById("div1").insertBefore(pNode1,document.getElementById("p1"));&#125;/* 执行之后HTML代码为： &lt;div id="div1"&gt; &lt;p&gt;insertBefore插入的节点&lt;/p&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p&gt;appendChild插入的节点&lt;/p&gt; &lt;/div&gt; */ 十、删除和替换节点。1、removeChild(); 由父元素调用，删除一个子节点。注意是直接父元素调用，删除直接子元素才有效，删除孙子元素就没有效果了。1234567891011121314&lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p id="p2"&gt;我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var div1 = document.getElementById("div1"); div1.removeChild(document.getElementById("p2"));&#125;/* 执行之后代码变为： &lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; //注意到第二个P元素已经被移除了 &lt;/div&gt; */ 2、replaceChild() //删除一个子节点，并用一个新节点代替它，第一个参数为新建的节点，第二个节点为被替换的节点1234567891011121314151617&lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p id="p2"&gt;我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var div1 = document.getElementById("div1"); var span1 = document.createElement("span"); span1.textContent = "我是一个新建的span"; div1.replaceChild(span1,document.getElementById("p2"));&#125;/* 执行完成后HTML代码变为： &lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;span&gt;我是一个新建的span&lt;/span&gt; //留意到p2节点已经被替换为span1节点了 &lt;/div&gt; */ 十一、javascript操作元素CSS通过元素的style属性可以随意读取和设置元素的CSS样式，例子： 123456789101112&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; window.onload = function () &#123; alert(document.getElementById("div1").style.backgroundColor); document.getElementById("div1").style.backgroundColor = "yellow"; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="div1" style="width:100px; height:100px; background-color:red"&gt;&lt;/div&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>DOM操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript编码规范]]></title>
    <url>%2F2017%2F05%2F06%2FJavaScript%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[前言好的编码规范可以尽可能的减少一个软件的维护成本，并且几乎没有任何一个软件，在其整个生命周期中，均由最初的开发人员来维护；好的编码规范可以改善软件的可读性，可以让开发人员尽快而彻底地理解新的代码；好的编码规范可以最大限度的提高团队开发的合作效率；长期的规范性编码还可以让开发人员养成好的编码习惯，甚至锻炼出更加严谨的思维。 不规范写法举例句尾没有分号1var isHotel = json.type == "hotel" ? true : false 变量命名各种各样123var is_hotel;var isHotel;var ishotel; if缩写1234if (isHotel) console.log(true)else console.log(false) 使用eval1234567var json = eval(jsonText);/* eval 好不好取决于怎么使用它，一般认为的缺点： 1. 可读性非常差 2. 不好再做优化和编译 3. 会轻微增加性能消耗 4. 不安全，比如 eval input 的值 */ 变量未定义到处都是123456function() &#123; var isHotel = 'true'; ....... var html = isHotel ? '&lt;p&gt;hotel&lt;/p&gt;' : "";&#125; 超长函数12345function() &#123; var isHotel = 'true'; //....... 此处省略500行 return false;&#125; ……….书写不规范的代码让我们难以维护，有时候也让我们头疼。 （禁止）、（必须）等字眼，在这里只是表示强调，未严格要求。 前端规范之JavaScripttab键用（必须）用四个空格代替​ 因为在不同系统的编辑工具对tab解析不一样，windows下的tab键是占四个空格的位置，而在linux下会变成占八个空格的位置（除非你自己设定了tab键所占的位置长度）。 一些童鞋可能会有疑问，tab键换成四个空格，多麻烦啊~ 其实不然，我平时用sublime text比较多，在这个工具中可以对tab键进行设置。 每句代码后（必须）加”;” 这个是要引起注意的，比如： 1234a = b // 赋值(function()&#123; //....&#125;)() // 自执行函数 未加分号，结果被解析成 1a = b(function()&#123;//...&#125;)() //将b()()返回的结果赋值给a 这是截然不同的两个结果，所以对于这个问题必须引起重视！！！ 变量、常量、类的命名按（必须）以下规则执行：变量：必须采用骆驼峰的命名且首字母小写123456789// 正确的命名 var isHotel, isHotelBeijing, isHotelBeijingHandian; // 不推荐的命名 var is_Hotel, ishotelbeijing, IsHotelBeiJing; 常量：必须采用全大写的命名，且单词以_分割**，常量通常用于ajax请求url，和一些不会改变的数据 123// 正确的命名 var HOTEL_GET_URL = 'http://map.baidu.com/detail', PLACE_TYPE = 'hotel'; 类：必须采用骆驼峰的命名且首字母大写，如：1234// 正确的写法 var FooAndToo = function(name) &#123; this.name = name; &#125; 空格的使用1.if中的空格，先上例子 1234567891011 //正确的写法 if (isOk) &#123; console.log("ok"); &#125; //不推荐的写法 if(isOk)&#123; console.log("ok"); &#125;/* ()中的判断条件前后都(必须)加空格 ()里的判断前后(禁止)加空格，如：正确的写法: if (isOk)；不推荐的写法: if ( isOk ) */ 2.switch中的空格, 先上例子 1234567891011121314151617181920212223242526//正确的写法 switch(name) &#123; case "hotel": console.log(name); break; case "moive": console.log(name); break; default: // code &#125; //不推荐的写法 switch (name) &#123; // switch 后不应该有空格, 正确的写法: switch(name) &#123; // code case "hotel": console.log(name); break; // break; 应该和console.log对齐 case "movie": // 每个case之前需要有换行 console.log(name); break; // break; 应该和console.log对齐 default: // code &#125; 3.for中的空格，先上例子 12345678910111213141516171819 // 正确的写法 var names = ["hotel", "movie"], i, len; for (i=0, len=names.length; i &lt; len; i++) &#123; // code &#125; // 不推荐的写法 var names = ["hotel", "movie"], i, len; for(i = 0, len = names.length;i &lt; len;i++) &#123; // for后应该有空格，每个`;`号后需要有空格，变量的赋值不应该有空格 // code &#125;/* for后（必须）加空格 每个;后（必须）加空格 ()中禁止用var声明变量; 且变量的赋值 = 前后（禁止）加空格 */ 4.function 中的空格, 先上例子 12345678910111213141516 // 正确的写法 function call(name) &#123; &#125; var cell = function () &#123; &#125;; // 不推荐的写法 var call = function(name)&#123; // code &#125; /* 参数的反括号后（必须）加空格 function 后（必须）加空格 */ 5.var 中空格及定义，先上例子 12345678910111213 // 一个推荐的var写法组 function(res) &#123; var code = 1 + 1, json = JSON.parse(res), type, html; // code &#125;/* 声明变量 = 前后（必须）添加空格 每个变量的赋值声明以,结束后（必须）换行进行下一个变量赋值声明 （推荐）将所有不需要进行赋值的变量声明放置最后一行，且变量之间不需要换行 （推荐）当一组变量声明完成后，空一行后编写其余代码 */ 6.在同一个函数内部，局部变量的声明必须置于顶端 因为即使放到中间，js解析器也会提升至顶部（hosting） 1234567891011121314151617181920// 正确的书写var clear = function(el) &#123; var id = el.id, name = el.getAttribute("data-name"); ......... return true;&#125;// 不推荐的书写var clear = function(el) &#123; var id = el.id; ...... var name = el.getAttribute("data-name"); ......... return true;&#125; 7.块内函数必须用局部变量声明 123456789101112131415161718192021222324// 错误的写法 var call = function(name) &#123; if (name == "hotel") &#123; function foo() &#123; console.log("hotel foo"); &#125; &#125; foo &amp;&amp; foo(); &#125; // 推荐的写法 var call = function(name) &#123; var foo; if (name == "hotel") &#123; foo = function() &#123; console.log("hotel foo"); &#125; &#125; foo &amp;&amp; foo(); &#125;/* 引起的bug：第一种写法foo的声明被提前了; 调用call时：第一种写法会调用foo函数，第二种写法不会调用foo函数 */ 8.（禁止）使用eval，采取$.parseJSON 三个原因： 有注入风险，尤其是ajax返回数据 不方便debug 效率低，eval是一个执行效率很低的函数 建议： 使用new Function来代替eval的使用，最好就别用。 9.除了三目运算，if,else等（禁止）简写 12345678910111213// 正确的书写if (true) &#123; alert(name);&#125;console.log(name);// 不推荐的书写if (true) alert(name);console.log(name);// 不推荐的书写if (true)alert(name);console.log(name) 10.（推荐）在需要以{}闭合的代码段前增加换行，如：for if 1234567891011121314151617181920212223242526272829303132// 没有换行，小的代码段无法区分 if (wl &amp;&amp; wl.length) &#123; for (i = 0, l = wl.length; i &lt; l; ++i) &#123; p = wl[i]; type = Y.Lang.type(r[p]); if (s.hasOwnProperty(p)) &#123; if (merge &amp;&amp; type == 'object') &#123; Y.mix(r[p], s[p]); &#125; else if (ov || !(p in r)) &#123; r[p] = s[p]; &#125; &#125; &#125; &#125; // 有了换行，逻辑清楚多了 if (wl &amp;&amp; wl.length) &#123; for (i = 0, l = wl.length; i &lt; l; ++i) &#123; p = wl[i]; type = Y.Lang.type(r[p]); if (s.hasOwnProperty(p)) &#123; // 处理merge逻辑 if (merge &amp;&amp; type == 'object') &#123; Y.mix(r[p], s[p]); &#125; else if (ov || !(p in r)) &#123; r[p] = s[p]; &#125; &#125; &#125; &#125;/* 换行可以是空行，也可以是注释 */ 11.（推荐）使用Function进行类的定义，(不推荐)继承，如需继承采用成熟的类库实现继承 12345678910111213141516171819// 类的实现 function Person(name) &#123; this.name = name; &#125; Person.prototype.sayName = function() &#123; alert(this.name); &#125;; var me = new Person("Nicholas"); // 将this放到局部变量self function Persion(name, sex) &#123; var self = this; self.name = name; self.sex = sex; &#125;/* 平时咱们写代码，基本都是小程序，真心用不上什么继承，而且继承并不是JS的擅长的语言特性，尽量少用。如果非要使用的话，注意一点： */ 123456789function A()&#123; //...&#125;function B()&#123; //...&#125;B.prototype = new A();B.prototype.constructor = B; //原则上，记得把这句话加上/* 继承从原则上来讲，别改变他的构造函数，否则这个继承就显得很别扭了~ */ 12.(推荐)使用局部变量缓存反复查找的对象(包括但不限于全局变量、dom查询结果、作用域链较深的对象) 1234567// 缓存对象var getComment = function() &#123; var dom = $("#common-container"), // 缓存dom appendTo = $.appendTo, // 缓存全局变量 data = this.json.data; // 缓存作用域链较深的对象&#125; 13.当需要缓存 this 时必须使用 self 变量进行缓存 12345678910// 缓存this function Row(name) &#123; var self = this; self.name = name; $(".row").click(function() &#123; self.getName(); &#125;); &#125;/* self是一个保留字，不过用它也没关系。在这里，看个人爱好吧，可以用_this, that, me等这些词，都行，但是团队开发的时候统一下比较好。 */ 14.（不推荐）超长函数, 当函数超过100行，就要想想是否能将函数拆为两个或多个函数 15.待挖掘… 小结规范是死的，罗列这些东西，目的是为了让程序猿们对这些东西引起注意，平时写代码的时候注意格式，不仅仅方便了自己，也让其他阅读者看得舒服。可能还有一些地方没有涉及到，如果你有好的建议，欢迎提出来补充！]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>编码规范</tag>
      </tags>
  </entry>
</search>