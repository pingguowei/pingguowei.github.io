<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[jQuery常用函数总结]]></title>
    <url>%2F2017%2F05%2F13%2FjQuery%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[jQuery常用函数总结这篇文章主要介绍了jQuery自带的一些常用方法总结,包括$.trim 、$.contains、$.each、$.map、$.inArray、$.extend等,需要的朋友可以参考下 常用工具方法（1）$.trim $.trim方法用于移除字符串头部和尾部多余的空格。复制代码 代码如下: 1$.trim(' Hello ') // Hello （2）$.contains $.contains方法返回一个布尔值，表示某个DOM元素（第二个参数）是否为另一个DOM元素（第一个参数）的下级元素。复制代码 代码如下: 1234$.contains(document.documentElement, document.body); // true$.contains(document.body, document.documentElement); // false （3）$.each， $.map $.each方法用于遍历数组和对象，然后返回原始对象。它接受两个参数，分别是数据集合和回调函数。复制代码 代码如下: 1234567891011121314$.each([ 52, 97 ], function( index, value ) &#123; console.log( index + ": " + value );&#125;);// 0: 52 // 1: 97 var obj = &#123; p1: "hello", p2: "world"&#125;;$.each( obj, function( key, value ) &#123; console.log( key + ": " + value );&#125;);// p1: hello// p2: world 需要注意的，jQuery对象实例也有一个each方法（$.fn.each），两者的作用差不多。$.map方法也是用来遍历数组和对象，但是会返回一个新对象。复制代码 代码如下: 123456var a = ["a", "b", "c", "d", "e"];a = $.map(a, function (n, i)&#123; return (n.toUpperCase() + i);&#125;);console.log(a);// ["A0", "B1", "C2", "D3", "E4"] （4）$.inArray $.inArray方法返回一个值在数组中的位置（从0开始）。如果该值不在数组中，则返回-1。复制代码 代码如下: 12var a = [1,2,3,4];$.inArray(4,a) // 3 （5）$.extend $.extend方法用于将多个对象合并进第一个对象。复制代码 代码如下: 1234var o1 = &#123;p1:'a',p2:'b'&#125;;var o2 = &#123;p1:'c'&#125;;$.extend(o1,o2);o1.p1 // "c" $.extend的另一种用法是生成一个新对象，用来继承原有对象。这时，它的第一个参数应该是一个空对象。复制代码 代码如下: 12345var o1 = &#123;p1:'a',p2:'b'&#125;;var o2 = &#123;p1:'c'&#125;;var o = $.extend(&#123;&#125;,o1,o2);o// Object &#123;p1: "c", p2: "b"&#125; 默认情况下，extend方法生成的对象是“浅拷贝”，也就是说，如果某个属性是对象或数组，那么只会生成指向这个对象或数组的指针，而不会复制值。如果想要“深拷贝”，可以在extend方法的第一个参数传入布尔值true。复制代码 代码如下: 123456var o1 = &#123;p1:['a','b']&#125;;var o2 = $.extend(&#123;&#125;,o1);var o3 = $.extend(true,&#123;&#125;,o1); // 深拷贝 复制值o1.p1[0]='c'; // 赋值o2.p1 // ["c", "b"] 浅拷贝 指针 没有复制值o3.p1 // ["a", "b"] 深拷贝 复制的值 上面代码中，o2是浅拷贝，o3是深拷贝。结果，改变原始数组的属性，o2会跟着一起变，而o3不会。 （6）$.proxy $.proxy方法类似于ECMAScript 5的bind方法，可以绑定函数的上下文（也就是this对象）和参数，返回一个新函数。jQuery.proxy()的主要用处是为回调函数绑定上下文对象。复制代码 代码如下: 123456789var o = &#123; type: "object", test: function(event) &#123; console.log(this.type); &#125;&#125;;$("#button") .on("click", o.test) // 无输出 .on("click", $.proxy(o.test, o)) // object 上面的代码中，第一个回调函数没有绑定上下文，所以结果为空，没有任何输出；第二个回调函数将上下文绑定为对象o，结果就为object。这个例子的另一种等价的写法是：复制代码 代码如下: 1$("#button").on( "click", $.proxy(o, test)) 上面代码的$.proxy(o, test)的意思是，将o的方法test与o绑定。这个例子表明，proxy方法的写法主要有两种。复制代码 代码如下: 123jQuery.proxy(function, context)// orjQuery.proxy(context, name) 第一种写法是为函数（function）指定上下文对象（context），第二种写法是指定上下文对象（context）和它的某个方法名（name）。再看一个例子。正常情况下，下面代码中的this对象指向发生click事件的DOM对象。复制代码 代码如下: 123$('#myElement').click(function() &#123; $(this).addClass('aNewClass');&#125;); 如果我们想让回调函数延迟运行，使用setTimeout方法，代码就会出错，因为setTimeout使得回调函数在全局环境运行，this将指向全局对象。复制代码 代码如下: 12345$('#myElement').click(function() &#123; setTimeout(function() &#123; $(this).addClass('aNewClass'); &#125;, 1000);&#125;); 上面代码中的this，将指向全局对象window，导致出错。这时，就可以用proxy方法，将this对象绑定到myElement对象。复制代码 代码如下: 12345$('#myElement').click(function() &#123; setTimeout($.proxy(function() &#123; $(this).addClass('aNewClass'); &#125;, this), 1000);&#125;); （7）$.data，$.removeData$.data方法可以用来在DOM节点上储存数据。复制代码 代码如下: 123456// 存入数据$.data(document.body, "foo", 52 );// 读取数据$.data(document.body, "foo");// 读取所有数据$.data(document.body); 上面代码在网页元素body上储存了一个键值对，键名为“foo”，键值为52。 $.removeData方法用于移除.data方法所储存的数据。复制代码 代码如下: 12$.data(div, "test1", "VALUE-1");$.removeData(div, "test1"); （8）$.parseHTML，$.parseJSON，.parseXML $.parseHTML方法用于将字符串解析为DOM对象。$.parseJSON方法用于将JSON字符串解析为JavaScript对象，作用与原生的JSON.parse()类似。但是，jQuery没有提供类似JSON.stringify()的方法，即不提供将JavaScript对象转为JSON对象的方法。$.parseXML方法用于将字符串解析为XML对象。复制代码 代码如下: 1234var html = $.parseHTML("hello, &lt;b&gt;my name is&lt;/b&gt; jQuery.");var obj = $.parseJSON('&#123;"name": "John"&#125;');var xml = "&lt;rss version='2.0'&gt;&lt;channel&gt;&lt;title&gt;RSS Title&lt;/title&gt;&lt;/channel&gt;&lt;/rss&gt;";var xmlDoc = $.parseXML(xml); （9）$.makeArray$.makeArray方法将一个类似数组的对象，转化为真正的数组。复制代码 代码如下: 1var a = $.makeArray(document.getElementsByTagName("div")); （10）$.merge $.merge方法用于将一个数组（第二个参数）合并到另一个数组（第一个参数）之中。复制代码 代码如下: 12345var a1 = [0,1,2];var a2 = [2,3,4];$.merge(a1, a2);a1// [0, 1, 2, 2, 3, 4] （11）$.now $.now方法返回当前时间距离1970年1月1日00:00:00 UTC对应的毫秒数，等同于(new Date).getTime()。复制代码 代码如下: 12$.now()// 1388212221489 （12）判断数据类型的方法jQuery提供一系列工具方法，用来判断数据类型，以弥补JavaScript原生的typeof运算符的不足。以下方法对参数进行判断，返回一个布尔值。jQuery.isArray()：是否为数组。jQuery.isEmptyObject()：是否为空对象（不含可枚举的属性）。jQuery.isFunction()：是否为函数。jQuery.isNumeric()：是否为数组。jQuery.isPlainObject()：是否为使用“{}”或“new Object”生成的对象，而不是浏览器原生提供的对象。jQuery.isWindow()：是否为window对象。jQuery.isXMLDoc()：判断一个DOM节点是否处于XML文档之中。下面是一些例子。复制代码 代码如下: 1234$.isEmptyObject(&#123;&#125;) // true$.isPlainObject(document.location) // false$.isWindow(window) // true$.isXMLDoc(document.body) // false 除了上面这些方法以外，还有一个$.type方法，可以返回一个变量的数据类型。它的实质是用Object.prototype.toString方法读取对象内部的[[Class]]属性（参见《标准库》的Object对象一节）。复制代码 代码如下: 1$.type(/test/) // "regexp" （13）Ajax操作 $.ajaxjQuery对象上面还定义了Ajax方法（$.ajax()），用来处理Ajax操作。调用该方法后，浏览器就会向服务器发出一个HTTP请求。$.ajax()的用法有多种，最常见的是提供一个对象参数。复制代码 代码如下: 1234567891011121314151617181920$.ajax(&#123; async: true, url: '/url/to/json', type: 'GET', data : &#123; id : 123 &#125;, dataType: 'json', timeout: 30000, success: successCallback, error: errorCallback, complete: completeCallback&#125;)function successCallback(json) &#123; $('&lt;h1/&gt;').text(json.title).appendTo('body');&#125;function errorCallback(xhr, status)&#123; console.log('出问题了！');&#125;function completeCallback(xhr, status)&#123; console.log('Ajax请求已结束。');&#125; 上面代码的对象参数有多个属性，含义如下：async：该项默认为true，如果设为false，则表示发出的是同步请求。cache: 该项默认为true，如果设为false，则浏览器不缓存返回服务器返回的数据。注意，浏览器本身就不会缓存POST请求返回的数据，所以即使设为false，也只对HEAD和GET请求有效。url：服务器端网址。这是唯一必需的一个属性，其他属性都可以省略。type：向服务器发送信息所使用的HTTP动词，默认为GET，其他动词有POST、PUT、DELETE。dataType：向服务器请求的数据类型，可以设为text、html、script、json、jsonp和xml。data：向服务器发送的数据，如果使用GET方法，此项将转为查询字符串，附在网址的最后。success：请求成功时的回调函数，函数参数为服务器传回的数据、状态信息、发出请求的原始对象。timeout: 等待的最长毫秒数。如果过了这个时间，请求还没有返回，则自动将请求状态改为失败。error：请求失败时的回调函数，函数参数为发出请求的原始对象以及返回的状态信息。complete：不管请求成功或失败，都会执行的回调函数，函数参数为发出请求的原始对象以及返回的状态信息。这些参数之中，url可以独立出来，作为ajax方法的第一个参数。也就是说，上面代码还可以写成下面这样。复制代码 代码如下: 123456$.ajax('/url/to/json',&#123; type: 'GET', dataType: 'json', success: successCallback, error: errorCallback&#125;) 简便写法ajax方法还有一些简便写法。$.get()：发出GET请求。$.getScript()：读取一个JavaScript脚本文件并执行。$.getJSON()：发出GET请求，读取一个JSON文件。$.post()：发出POST请求。$.fn.load()：读取一个html文件，并将其放入当前元素之中。一般来说，这些简便方法依次接受三个参数：url、数据、成功时的回调函数。 （1）$.get()，$.post() 这两个方法分别对应HTTP的GET方法和POST方法。复制代码 代码如下: 123456$.get('/data/people.html', function(html)&#123; $('#target').html(html);&#125;);$.post('/data/save', &#123;name: 'Rebecca'&#125;, function (resp)&#123; console.log(JSON.parse(resp));&#125;); get方法接受两个参数，分别为服务器端网址和请求成功后的回调函数。post方法在这两个参数中间，还有一个参数，表示发给服务器的数据。上面的post方法对应的ajax写法如下。复制代码 代码如下: 123456789$.ajax(&#123; type: 'POST', url: '/data/save', data: &#123;name: 'Rebecca'&#125;, dataType: 'json', success: function (resp)&#123; console.log(JSON.parse(resp)); &#125;&#125;); （2）$.getJSON() ajax方法的另一个简便写法是getJSON方法。当服务器端返回JSON格式的数据，可以用这个方法代替$.ajax方法。复制代码 代码如下: 123$.getJSON('url/to/json', &#123;'a': 1&#125;, function(data)&#123; console.log(data);&#125;); 上面的代码等同于下面的写法。复制代码 代码如下: 12345678$.ajax(&#123; dataType: "json", url: '/url/to/data', data: &#123;'a': 1&#125;, success: function(data)&#123; console.log(data); &#125;&#125;); （3）$.getScript()$.getScript方法用于从服务器端加载一个脚本文件。复制代码 代码如下: 123$.getScript('/static/js/myScript.js', function() &#123; functionFromMyScript();&#125;); 上面代码先从服务器加载myScript.js脚本，然后在回调函数中执行该脚本提供的函数。getScript的回调函数接受三个参数，分别是脚本文件的内容，HTTP响应的状态信息和ajax对象实例。复制代码 代码如下: 12345$.getScript( "ajax/test.js", function (data, textStatus, jqxhr)&#123; console.log( data ); // test.js的内容 console.log( textStatus ); // Success console.log( jqxhr.status ); // 200&#125;); getScript是ajax方法的简便写法，因此返回的是一个deferred对象，可以使用deferred接口。复制代码 代码如下: 1234567jQuery.getScript("/path/to/myscript.js") .done(function() &#123; // ... &#125;) .fail(function() &#123; // ...&#125;); （4）$.fn.load() $.fn.load不是jQuery的工具方法，而是定义在jQuery对象实例上的方法，用于获取服务器端的HTML文件，将其放入当前元素。由于该方法也属于ajax操作，所以放在这里一起讲。复制代码 代码如下: 1$('#newContent').load('/foo.html'); $.fn.load方法还可以指定一个选择器，将远程文件中匹配选择器的部分，放入当前元素，并指定操作完成时的回调函数。复制代码 代码如下: 1234$('#newContent').load('/foo.html #myDiv h1:first', function(html) &#123; console.log('内容更新！');&#125;); 上面代码只加载foo.html中匹配“#myDiv h1:first”的部分，加载完成后会运行指定的回调函数。Ajax事件jQuery提供以下一些方法，用于指定特定的AJAX事件的回调函数。.ajaxComplete()：ajax请求完成。.ajaxError()：ajax请求出错。.ajaxSend()：ajax请求发出之前。.ajaxStart()：第一个ajax请求开始发出，即没有还未完成ajax请求。.ajaxStop()：所有ajax请求完成之后。.ajaxSuccess()：ajax请求成功之后。下面是示例。复制代码 代码如下: 123$('#loading_indicator').ajaxStart(function ()&#123;$(this).show();&#125;).ajaxStop(function ()&#123;$(this).hide();&#125;); 返回值ajax方法返回的是一个deferred对象，可以用then方法为该对象指定回调函数（详细解释参见《deferred对象》一节）。复制代码 代码如下: 123456$.ajax(&#123; url: '/data/people.json', dataType: 'json'&#125;).then(function (resp)&#123; console.log(resp.people);&#125;) JSONP由于浏览器存在“同域限制”，ajax方法只能向当前网页所在的域名发出HTTP请求。但是，通过在当前网页中插入script元素（\），可以向不同的域名发出GET请求，这种变通方法叫做JSONP（JSON with Padding）。ajax方法可以发出JSONP请求，方法是在对象参数中指定dataType为JSONP。复制代码 代码如下: 12345678$.ajax(&#123; url: '/data/search.jsonp', data: &#123;q: 'a'&#125;, dataType: 'jsonp', success: function(resp) &#123; $('#target').html('Results: ' + resp.results.length); &#125;&#125;); JSONP的通常做法是，在所要请求的URL后面加在回调函数的名称。ajax方法规定，如果所请求的网址以类似“callback=?”的形式结尾，则自动采用JSONP形式。所以，上面的代码还可以写成下面这样。复制代码 代码如下: 12345$.getJSON('/data/search.jsonp?q=a&amp;callback=?', function(resp) &#123; $('#target').html('Results: ' + resp.results.length); &#125;);]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>函数</tag>
        <tag>选择器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery常用语法]]></title>
    <url>%2F2017%2F05%2F13%2FjQuery%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[基础语法：$(selector).action() 美元符号定义 jQuery $ 选择符（selector）“查询”和“查找” HTML 元素 jQuery 的 action() 执行对元素的操作 示例： 1234$(this).hide() - 隐藏当前元素$("p").hide() - 隐藏所有段落$("p.test").hide() - 隐藏所有 class="test" 的段落$("#test").hide() - 隐藏所有 id="test" 的元素 选择器-by prop： jQuery 使用 XPath 表达式来选择带有给定属性的元素。 示例： 1234$("[href]") 选取所有带有 href 属性的元素。 $("[href='#']") 选取所有带有 href 值等于 "#" 的元素。$("[href!='#']") 选取所有带有 href 值不等于 "#" 的元素。$("[href$='.jpg']") 选取所有 href 值以 ".jpg" 结尾的元素。 选择器-css： jQuery CSS 选择器可用于改变 HTML 元素的 CSS 属性。 示例： 1$("p").css("background-color","red"); 事件： 基于事件，我们可以做许多事情。 示例： 123$(document).ready(function)$(selector).click(function)$(selector).focus(function) jQuery与html： jQuery 提供一系列与 DOM 相关的方法，这使访问和操作元素和属性变得很容易。 三个简单实用的用于 DOM 操作的 jQuery 方法，get – set： 12345$(selector).text() -- text("")$(selector).html() -- html("")$(selector).val() -- html("") $(selector).attr("") -- attr("", "")/* 等同于，获name来找，$("input[name='whichName']").val()，对它重新赋值$("input[name='whichName']").val(oldTopic); */ jQuery-GET： $.get(“yourUrl”, function(data, status){}); 其中，data是controller里这样写回的response.write(“”) /modelMap带回 示例： 12345$("button").click(function()&#123; $.get("demo_test.asp",function(data,status)&#123; alert("Data: " + data + "\nStatus: " + status); &#125;);&#125;); jQuery-POST： $.post(URL,data,callback); 其中，data是controller里这样写回的response.write(“”) /modelMap带回 示例： 12345678910$("button").click(function()&#123; $.post("demo_test_post.asp", &#123; name:"Donald Duck", city:"Duckburg" &#125;, function(data,status)&#123; alert("Data: " + data + "\nStatus: " + status); &#125;);&#125;); jQuery-遍历：1$(selector).each(function(index,element)) 示例： 12345$("table").find("tr").each(function()&#123; $(this).find("td").each(function()&#123; alert($(this).text()); &#125;);&#125;); 常用方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;script&gt; /** elementName标识的页面元素的值，是否为空. */ function isNULL(elementname)&#123; if($("input[name=" + elementname + "]").val() == "")&#123; return true; &#125; return false; &#125; /** elementName标识的页面元素的值，是否超时limitedLength. */ function exceedLimitedLength(elementname, limitedLength)&#123; if($("input[name=" + elementname + "]").val().length &gt; limitedLength)&#123; return true; &#125; return false; &#125; /** elementName标识的页面元素的值，是否为数字. */ function isNum(elementname)&#123; return isNaN($("input[name=" + elementname + "]").val()); &#125; /** 光标显示在elementname标识的元素内. */ function focus(elementname)&#123; $("input[name=" + elementname + "]").focus(); &#125; /** elementname标识的页面元素是否为数字，如果不是，那么光标标在那里，并且提示用户. */ function isNumber(elementname)&#123; if(isNum(elementname))&#123; focus(elementname); alert(elementname + "必须为数字"); return false; &#125; return true; &#125; /** elementname标识的页面元素的值，是否包含了中文. */ function containsChinese(elementname)&#123; var str = $("input[name=" + elementname + "]").val(); if(escape(str).indexOf("%u")&gt;=0)&#123; return true; &#125; return false; &#125; /** elementname标识的页面元素的值，是否只包括字母、数字、中划线和下划线. */ function containsOnlyLettersNumberAndTwoDash(elementname)&#123; var str = $("input[name=" + elementname + "]").val(); var patten = new RegExp(/^[a-zA-Z0-9\_\-]+$/); return patten.test(str); &#125; /** elementname标识的页面元素的值，是否满足这些约束：不为空、 长度&lt;limitedLength、不包含中文、只包含字母数字中划下划. */ function satisfyAllConstraints(elementname, limitedLength)&#123; if(isNULL(elementname))&#123; focus(elementname); alert(elementname + "不可为空"); return false; &#125; if(exceedLimitedLength(elementname, limitedLength))&#123; focus(elementname); alert(elementname + "超过长度限制" + limitedLength); return false; &#125; if(containsChinese(elementname))&#123; focus(elementname); alert(elementname + "不支持中文"); return false; &#125; // 注意！ if(!containsOnlyLettersNumberAndTwoDash(elementname))&#123; focus(elementname); alert(elementname + "仅支持字母、数字、中划线-、下滑线_"); return false; &#125; return true; &#125;&lt;/script&gt; 判断字符串开头、结尾，正则表达式：12345678var str = "xxx.xml.bak";if (str.match("^xxx")) &#123; alert("xxx starts");&#125;if (str.match("xml$")) &#123; alert("xml ends");&#125;]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>事件</tag>
        <tag>jQuery</tag>
        <tag>jQuery常用语法</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[苹果味喜欢的音乐]]></title>
    <url>%2F2017%2F05%2F13%2F%E8%8B%B9%E6%9E%9C%E5%91%B3%E5%96%9C%E6%AC%A2%E7%9A%84%E9%9F%B3%E4%B9%90%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript数组及JSON操作]]></title>
    <url>%2F2017%2F05%2F13%2FJavaScript%E6%95%B0%E7%BB%84%E5%8F%8AJSON%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[JavaScript数组及JSON操作javascript删除数组的3种方法1.用shift()方法shift：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined 123var myArray=[2,34,56,32,12,9];var a=myArray.shift(); // 得到2console.log(myArray); // [34,56,,32,12,9] 2.用pop()方法pop：删除原数组最后一项，并返回删除元素的值；如果数组为空则返回undefined 123var myArray=[2,34,56,32,12,9];var a=myArray.pop(); // 得到9console.log(myArray); // [2,34,56,,32,12] 前面的方法只能操作数组开头和结尾，无法操作中间项，如果要操作中间的项，使用splice方法 3.用splice方法这个方法很强大，可以对数组任意项进行增加，删除，替换操作 删除操作123var myArray=[2,34,56,32,12,9];var a=myArray.splice(2,1); // 得到56console.log(myArray); // [2,34,32,12,9] 上面例子中，把myArray中的索引为2开始的1项替换成空的，因为后面没有内容，结果可以看到，把56这项删除了 修改操作：123var myArray=[2,34,56,32,12,9];var a=myArray.splice(2,1,8,9); // 得到56console.log(myArray); // [2,34,8,9,32,12,9] 第一个参数是准备操作的数组索引，第二个参数是操作位置后面的数组项数，第三个以后的就是，被替换后的内容 添加操作123var myArray=[2,34,56,32,12,9];var a=myArray.splice(2,0,8,9); // 得到空[]console.log(myArray); // [2,34,8,9,56,32,12,9] 从数组索引为2后的0项换成8,9，也就等于添加了两项 javascript对JSON增删改查概要JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式,同时，JSON是 JavaScript 原生格式，这意味着在 JavaScript 中处理 JSON数据不须要任何特殊的 API 或工具包。 在JSON中，有两种结构：对象和数组 1、对象以“{”开始，“}”结束，“key/value”之间运用 “,”分隔。1packJson=&#123;"name":"Liza","password":"123"&#125; 2、数组以“[”开始，“]”结束。值之间运用 “,”分隔。1packJson=[&#123;"name":"Liza","password":"123"&#125;,&#123;"name":"Mike","password":"456"&#125;]; JSON对象和JSON字符串的转换在数据传输过程中，JSON是以字符串的形式传递的，而JS操作的是JSON对象，所以，JSON对象和JSON字符串之间的相互转换是关键。如下： JSON字符串： 1var jsonStr='&#123;"name":"Liza","password":"123"&#125;'; JSON对象： 1var packJson=[&#123;"name":"Liza","password":"123"&#125;,&#123;"name":"Mike","password":"456"&#125;]; 1、将String转化为JSON 1var jsonObject=jQuery.parseJSON(jsonStr); 2、将JSON转化为String 1var jsonStr=JSON.stringify(jsonObject) 增删改查Demo 1234567891011121314151617181920212223242526272829303132var p =&#123; "name": "kakaxi", "age":45, "sex":"male"&#125;;function JsonOperation()&#123; // 读取 for(var i in p)&#123; console.log(i+'=='+p[i]); // name==kakaxi... &#125; // 查找 console.log(p['age']); // 45 console.log(p.age); // 45 // 增加 p['卡卡西']='copy忍者，木叶上忍'; p['鼬']='天才忍者'; console.log(p['卡卡西']); // copy忍者，木叶上忍 // 修改 p.age=88; console.log(p['age']); // 88 // 删除 delete p['name']; delete p.age; for(var i in p)&#123; console.log(i+'=='+p[i]); // 已删除 name、age项 &#125;&#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript常用函数]]></title>
    <url>%2F2017%2F05%2F08%2FJavaScript%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[常规函数 alert函数：显示一个警告对话框，包括一个OK按钮。 confirm函数：显示一个确认对话框，包括OK、Cancel按钮。 escape函数：将字符转换成Unicode码。 eval函数：计算表达式的结果。 isNaN函数：测试是(true)否(false)不是一个数字。 parseFloat函数：将字符串转换成符点数字形式。 parseInt函数：将符串转换成整数数字形式(可指定几进制)。 prompt函数：显示一个输入对话框，提示等待用户输入。例如： 123alert("输入错误"); prompt("请输入您的姓名","姓名");confirm("确定否！"); unescape函数：解码由escape函数编码的字符。 toFixed 函数:这个函数牛逼 就是转化小数点几位的 checkprice.toFixed(2)； 将checkprice转化为有小数点后两位的值 数组函数javascript数组函数包括以下4个函数：(1) join函数：转换并连接数组中的所有元素为一个字符串。例: 123456function JoinDemo()&#123; var a, b; a = new Array(0,1,2,3,4); b = a.join("-");//分隔符 return(b);//返回的b=="0-1-2-3-4" &#125; (2) length函数：返回数组的长度。例： 123456function LengthDemo()&#123; var a, l; a = new Array(0,1,2,3,4); l = a.length; return(l);//l==5 &#125; (3) reverse函数：将数组元素顺序颠倒。例： 123456function ReverseDemo()&#123; var a, l; a = new Array(0,1,2,3,4); l = a.reverse(); return(l); &#125; (4) sort函数：将数组元素重新排序。例： 123456function SortDemo()&#123; var a, l; a = new Array("X" ,"y" ,"d", "Z", "v","m","r"); l = a.sort(); return(l); &#125; (5) push函数:将新元素添加到一个数组中，并返回数组的新长度值。例: 12345&lt;script type="text/javascript"&gt; var my_array = new Array('1','2','3','4'); my_array.push('5','6','7','8'); alert(my_array.length); //将返回8 数组中添加了4个元素&lt;/script&gt; (6) unshift函数：将指定的元素插入数组开始位置并返回该数组。例： 12345&lt;script type="text/javascript"&gt; var my_array = new Array('1','2','3','4'); my_array.unshift('0'); //在数组前面追加元素 alert(my_array.length); //返回5&lt;/script&gt; (7) pop函数:移除数组中的最后一个元素并返回该元素。例: 12345&lt;script type="text/javascript"&gt; var my_array = new Array('1','2','3','411'); alert(my_array.pop()); //返回411 alert(my_array.length); //返回3&lt;/script&gt; (8) shift函数:移除数组中的第一个元素并返回该元素。例: 12345&lt;script type="text/javascript"&gt; var my_array = new Array('1','2','3','4'); alert(my_array.shift()); //返回1 alert(my_array.length); //返回3&lt;/script&gt; (9) Obj.slice(start,end) 返回一个数组的一段，得到一个新数组。注意不包括 end 对应的元素，如果省略 end 将复制 start 之后的所有元素,例如： 123456789&lt;script type="text/javascript"&gt; var my_array = new Array('1','2','3','4'); var new_array = my_array.slice(0,2); //返回0-2个元素 var new_array = my_array.slice(0,-1); //返回除了最后一个之外的元素 var new_array = my_array.slice(0); //返回第0以后的所有的元素 for(var i =0;i&lt;new_array.length;i++)&#123; alert(new_array[i]); &#125;&lt;/script&gt; (10) Obj.concat(item1,item2,item3,item4,item5……) 返回一个新数组，这个新数组是由两个或更多数组（也可以是一个变量）组合而成的,。例: 12345678910&lt;script type="text/javascript"&gt; var my_array = new Array('1','2','3','4'); var my_array1 = new Array('5','6'); var my_array2 = new Array('7','8'); var my_array3 = new Array('9'); var my_name = 'SmarTop'; //也可以是一个字符串 var my_age = 26; //也可以是一个数字 var new_array = my_array.concat(my_array1,my_array2,my_array3,my_name,my_age); alert(new_array);&lt;/script&gt; 日期函数javascript日期函数包括以下20个函数： (1) getDate函数：返回日期的”日”部分，值为1～31。例： 12345678function DateDemo()&#123; var d, s = "Today's date is: "; d = new Date(); s += (d.getMonth() + 1) + "/"; s += d.getDate() + "/"; s += d.getYear(); return(s);&#125; (2) getDay函数：返回星期几，值为0～6，其中0表示星期日，1表示星期一，…，6表示星期六。例： 123456789function DateDemo()&#123; var d, day, x, s = "Today is: "; var x = new Array("Sunday", "Monday", "Tuesday"); var x = x.concat("Wednesday","Thursday", "Friday"); var x = x.concat("Saturday"); d = new Date(); day = d.getDay(); return(s += x[day]);&#125; (3) getHours函数：返回日期的”小时”部分，值为0～23。例： 12345678910function TimeDemo()&#123; var d, s = "The current local time is: "; var c = ":"; d = new Date(); s += d.getHours() + c; s += d.getMinutes() + c; s += d.getSeconds() + c; s += d.getMilliseconds(); return(s);&#125; (4) getMinutes函数：返回日期的”分钟”部分，值为0～59。见上例。(5) getMonth函数：返回日期的”月”部分，值为0～11。其中0表示1月，2表示3月，…，11表示12月。见前面的例子。(6) getSeconds函数：返回日期的”秒”部分，值为0～59。见前面的例子。(7) getTime函数：返回系统时间。 1234567891011function GetTimeTest()&#123; var d, s, t; var MinMilli = 1000 * 60; var HrMilli = MinMilli * 60; var DyMilli = HrMilli * 24; d = new Date(); t = d.getTime(); s = "It's been " s += Math.round(t / DyMilli) + " days since 1/1/70"; return(s);&#125; (8) getTimezoneOffset函数：返回此地区的时差(当地时间与GMT格林威治标准时间的地区时差)，单位为分钟。 123456789101112function TZDemo()&#123; var d, tz, s = "The current local time is "; d = new Date(); tz = d.getTimezoneOffset(); if (tz &lt; 0) s += tz / 60 + " hours before GMT"; else if (tz == 0) s += "GMT"; else s += tz / 60 + " hours after GMT"; return(s);&#125; (9) getYear函数：返回日期的”年”部分。返回值以1900年为基数，例如1999年为99。前面有例子。(10) parse函数：返回从1970年1月1日零时整算起的毫秒数(当地时间)。 123456789101112function GetTimeTest(testdate)&#123; var d, s, t; var MinMilli = 1000 * 60; var HrMilli = MinMilli * 60; var DyMilli = HrMilli * 24; d = new Date(); t = Date.parse(testdate); s = "There are " s += Math.round(Math.abs(t / DyMilli)) + " days " s += "between " + testdate + " and 1/1/70"; return(s);&#125; (11) setDate函数：设定日期的”日”部分，值为0～31。(12) setHours函数：设定日期的”小时”部分，值为0～23。(13) setMinutes函数：设定日期的”分钟”部分，值为0～59。(14) setMonth函数：设定日期的”月”部分，值为0～11。其中0表示1月，…，11表示12月。(15) setSeconds函数：设定日期的”秒”部分，值为0～59。(16) setTime函数：设定时间。时间数值为1970年1月1日零时整算起的毫秒数。(17) setYear函数：设定日期的”年”部分。(18) toGMTString函数：转换日期成为字符串，为GMT格林威治标准时间。(19) setLocaleString函数：转换日期成为字符串，为当地时间。(20) UTC函数：返回从1970年1月1日零时整算起的毫秒数，以GMT格林威治标准时间计算。 数学函数javascript数学函数其实就是Math对象，它包括属性和函数(或称方法)两部分。其中，属性主要有下列内容。Math.e:e(自然对数)、Math.LN2（2的自然对数)、Math.LN10(10的自然对数)、Math.LOG2E(e的对数，底数为2)、 Math.LOG10E(e的对数，底数为10)、Math.PI(π)、Math.SQRT1_2(1/2的平方根值)、Math.SQRT2(2的平方根值)。函数有以下18个：(1) abs函数：即Math.abs(以下同)，返回一个数字的绝对值。(2) acos函数：返回一个数字的反余弦值，结果为0～π弧度(radians)。(3) asin函数：返回一个数字的反正弦值，结果为-π/2～π/2弧度。(4) atan函数：返回一个数字的反正切值，结果为-π/2～π/2弧度。(5) atan2函数：返回一个坐标的极坐标角度值。(6) ceil函数：返回一个数字的最小整数值(大于或等于)。(7) cos函数：返回一个数字的余弦值，结果为-1～1。(8) exp函数：返回e(自然对数)的乘方值。(9) floor函数：返回一个数字的最大整数值(小于或等于)。(10) log函数：自然对数函数，返回一个数字的自然对数(e)值。(11) max函数：返回两个数的最大值。(12) min函数：返回两个数的最小值。(13) pow函数：返回一个数字的乘方值。(14) random函数：返回一个0～1的随机数值。(15) round函数：返回一个数字的四舍五入值，类型是整数。(16) sin函数：返回一个数字的正弦值，结果为-1～1。(17) sqrt函数：返回一个数字的平方根值。(18) tan函数：返回一个数字的正切值。 字符串函数(1) concat函数:将两个或多个字符的文本组合起来，返回一个新的字符串。 12345var a = "hello";var b = ",world";var c = a.concat(b);alert(c);//c = "hello,world" (2) indexOf函数：返回字符串中一个子串第一处出现的索引（从左到右搜索）。如果没有匹配项，返回 -1 。 1234var index1 = a.indexOf("l");//index1 = 2var index2 = a.indexOf("l",3); //3表示从第三个开始向右搜索//index2 = 3 (3) lastIndexOf:返回字符串中一个子串第一处出现的索引（从右到左搜索）。如果没有匹配项，返回 -1 。 1234var index1 = lastIndexOf('l');//index1 = 3var index2 = lastIndexOf('l',2)//3表示从第三个开始向左搜索//index2 = 2 (4) charAt：返回字符串中指定的某个字符。 12var get_char = a.charAt(0);//get_char = "h" (5) match：检查一个字符串匹配一个正则表达式内容，如果没有匹配返回 null。 12345var re = new RegExp(/^\w+$/); //存储检索模式var is_alpha1 = a.match(re);//is_alpha1 = "hello"var is_alpha2 = b.match(re);//is_alpha2 = null (6) substring:返回位于 String 对象中指定位置的子字符串。 1234var sub_string1 = a.substring(1);//sub_string1 = "ello"var sub_string2 = a.substring(1,4);//sub_string2 = "ell" (6) substr：返回字符串的一个子串，传入参数是起始位置和长度 1234var sub_string1 = a.substr(1);//sub_string1 = "ello"var sub_string2 = a.substr(1,4); //长度//sub_string2 = "ello" (7) replace：用来查找匹配一个正则表达式的字符串，然后使用新字符串代替匹配的字符串。 12345var r, re; // 声明变量。var ss = "The man hit the ball with the bat.\n";ss += "while the fielder caught the ball with the glove.";re = /The/g; // 创建正则表达式模式。r = ss.replace(re, "A"); // 用 "A" 替换 "The"。 var r, re; // 声明变量。var ss = “The rain in Spain falls mainly in the plain.”;re = /(\S+)(\s+)(\S+)/g; // 创建正则表达式模式。r = ss.replace(re, “$3$2$1”); // 交换每一对单词。 (8) search：执行一个正则表达式匹配查找。如果查找成功，返回字符串中匹配的索引值。否则返回 -1 。 1234var index1 = a.search(re);//index1 = 0var index2 = b.search(re);//index2 = -1 (9) slice:提取字符串的一部分，并返回一个新字符串（与 substring 相同）。 1234var sub_string1 = a.slice(1);//sub_string1 = "ello"var sub_string2 = a.slice(1,4);//sub_string2 = "ell" (10) split:通过将字符串划分成子串，将一个字符串做成一个字符串数组。 123var arr1 = a.split(""); //使用分割的字符 //arr1 = [h,e,l,l,o] length (11) length:返回字符串的长度，所谓字符串的长度是指其包含的字符的个数。 12var len = a.length(); //len = 5 (12) toLowerCase:将整个字符串转成小写字母。 12var lower_string = a.toLowerCase();//lower_string = "hello" (13) toUpperCase:将整个字符串转成大写字母。 12var upper_string = a.toUpperCase();//upper_string = "HELLO"]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>常用函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript事件]]></title>
    <url>%2F2017%2F05%2F07%2FJavaScript%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[与浏览器进行交互的时候浏览器就会触发各种事件。比如当我们打开某一个网页的时候，浏览器加载完成了这个网页，就会触发一个 load 事件；当我们点击页面中的某一个“地方”，浏览器就会在那个“地方”触发一个 click 事件。 这样，我们就可以编写 JavaScript，通过监听某一个事件，来实现某些功能扩展。例如监听 load 事件，显示欢迎信息，那么当浏览器加载完一个网页之后，就会显示欢迎信息。 下面就来介绍一下事件。 基础事件操作监听事件浏览器会根据某些操作触发对应事件，如果我们需要针对某种事件进行处理，则需要监听这个事件。监听事件的方法主要有以下几种： HTML 内联属性（避免使用）HTML 元素里面直接填写事件有关属性，属性值为 JavaScript 代码，即可在触发该事件的时候，执行属性值的内容。 例如： 1&lt;button onclick="alert('你点击了这个按钮');"&gt;点击这个按钮&lt;/button&gt; 上面代码就是监听 element 节点的 click 事件。它比较简单易懂，而且有较好的兼容性。但是也有缺陷，因为直接赋值给对应属性，如果你在后面代码中再次为 element 绑定一个回调函数，会覆盖掉之前回调函数的内容。 虽然也可以用一些方法实现多个绑定，但还是推荐下面的标准事件监听函数。 DOM 属性绑定也可以直接设置 DOM 属性来指定某个事件对应的处理函数，这个方法比较简单： 123456element.onclick = function(event)&#123; alert('你点击了这个按钮');&#125;;/* 上面代码就是监听 element 节点的 click 事件。它比较简单易懂，而且有较好的兼容性。但是也有缺陷，因为直接赋值给对应属性，如果你在后面代码中再次为 element 绑定一个回调函数，会覆盖掉之前回调函数的内容。虽然也可以用一些方法实现多个绑定，但还是推荐下面的标准事件监听函数。 */ 使用事件监听函数标准的事件监听函数如下： 1element.addEventListener(&lt;event-name&gt;, &lt;callback&gt;, &lt;use-capture&gt;); 表示在 element 这个对象上面添加一个事件监听器，当监听到有 &lt;event-name&gt; 事件发生的时候，调用 &lt;callback&gt; 这个回调函数。至于 &lt;use-capture&gt; 这个参数，表示该事件监听是在“捕获”阶段中监听（设置为 true）还是在“冒泡”阶段中监听（设置为 false）。关于捕获和冒泡，我们会在下面讲解。 用标准事件监听函数改写上面的例子： 1234567&lt;button id="btn"&gt;点击这里&lt;/button&gt;&lt;script&gt;var btn = document.getElementById('btn');btn.addEventListener('click', function()&#123; alert('你点击了这里');&#125;, false);&lt;/script&gt; 移除事件监听当我们为某个元素绑定了一个事件，每次触发这个事件的时候，都会执行事件绑定的回调函数。如果我们想解除绑定，需要使用 removeEventListener 方法： 1element.removeEventListener(&lt;event-name&gt;, &lt;callback&gt;, &lt;use-capture&gt;); 需要注意的是，绑定事件时的回调函数不能是匿名函数，必须是一个声明的函数，因为解除事件绑定时需要传递这个回调函数的引用，才可以断开绑定。例如： 123456789&lt;button id="btn"&gt;点击这里&lt;/button&gt;&lt;script&gt; var btn = document.getElementById('btn'); var fun = function()&#123; alert('这个按钮只支持一次点击'); btn.removeEventListener('click', fun, false);&#125;;btn.addEventListener('click', fun, false);&lt;/script&gt; 事件触发过程在上面大体了解了事件是什么、如何监听并执行某些操作，但我们对事件触发整个过程还不够了解。 下图就是事件的触发过程，借用了 W3C 的图片 JavaScript中的一些常用事件onclick事件点击事件（onclick并不是js中的方法，onclick只是浏览器提供js的一个dom接口，让js可以操作dom，所以onclick大小写都是没问题的，比如HTML代码就不用区分大小写） 1234567&lt;buttononclick="myFunction()"&gt;点击这里&lt;/button&gt;&lt;script&gt; functionmyFunction()&#123; alert("测试onclick点击事件"); &#125;&lt;/script&gt; onclick通常在下列基本对象中产生： button(按钮对象)、checkbox(复选框)、radio(单选框)、reset buttons(重置按钮)、submit buttons(提交按钮) onload事件可以body执行，,其中onload后面可以写一个方法，如：onload=”test()”,然后在JavaScript中写一个test()方法，则在页面一开始加载的时候会先调用这个方法 12345678&lt;bodyonload="test()"&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; functiontest()&#123; alert("测试onload方法"); &#125;&lt;/script&gt; 注意：此方法只能写在标签之中 onchange事件事件在内容改变的时候触发，和jQuery中的change()方法一样 当内容改变时触发。可用于文本框、列表框等对象，该事件一般用于响应用户修改内容带来的其他改变操作。 说明：当用户向一个文本框中输入文本时，不会触发onchange事件，只有用户输入结束后，单击文本框以外的区域，使文本框失去焦点时才触发该事件，如果是下拉框，则选择结束后即触发。 1234567891011&lt;p&gt; &lt;labelfor="name"&gt;用户名：&lt;/label&gt; &lt;input type="text" id="fname" onchange="upperCase()" value=""/&gt;&lt;/p&gt;&lt;script type="text/javascript"&gt; functionupperCase()&#123; var x = document.getElementById("fname").value; document.getElementById("fname").value = x.toUpperCase(); &#125;&lt;/script&gt; 说明：上例实际效果是，当输入框失去焦点时内容转成大写。出现这种情况是由于input必须是失去焦点才会检测到内容发生改变。而change事件通常是用于下拉菜单select标签。 onblur事件和onfocus事件onblur事件：当前元素失去焦点时触发该事件；onfocus事件：得到焦点事件 123456789101112131415&lt;body&gt;失去焦点：&lt;inputtype="text" name="name" value=" "size="30" onblur="chkvalue(this)"&gt;&lt;br&gt;得到焦点：&lt;inputtype="text" id="name" value="" size="30" onfocus="setStyle(this.id)"&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; function chkvalue(txt) &#123; if(txt.value=="") alert("文本框里必须填写内容!"); &#125; function setStyle(x)&#123; document.getElementById(x).style.background="yellow" &#125;&lt;/script&gt; onscroll事件窗口滚动事件：当页面滚动时调用函数。此事件写在方法的外面，且函数名后面不加括号，例如window.onscroll=move 123456&lt;script type="text/javascript"&gt; functionmove() &#123; alert("页面滚动时调用"); &#125; window.onscroll = move;&lt;/script&gt; onsubmit事件属于表单元素，写在表单标签内。语法：onsubmit=”return 函数名()” 1234567891011&lt;form action="" method="post" name="testForm" onsubmit="returnmove()"&gt; &lt;inputtype="text"name="name"value=""&gt; &lt;br&gt; &lt;input type="submit" name="submit" value="测试onsubmit"/&gt;&lt;/form&gt;&lt;script type="text/javascript"&gt; functionmove() &#123; alert("测试onsubmit........"+testForm.name.value); &#125;&lt;/script&gt; 鼠标相关事件onmousemove和onmouseout和onmouseover事件Onmouseover:鼠标移动到某对象范围的上方时，触发事件调用函数。注意：在同一个区域中，无论怎样移动都只触发一次函数。 Onmouseout:鼠标离开某对象范围时，触发事件调用函数。 Onmousemove:鼠标移动到某对象范围的上方时，触发事件调用函数。注意：在同一个区域中，只要鼠标动一次就触发一次事件。 12345678910111213&lt;img onmousemove="bigImg(this)" onmouseout="normalImg(this)" border="0" src="images/defaultAvatar.gif" alt="Smiley"&gt;&lt;script type="text/javascript"&gt; functionbigImg(x)&#123; x.style.height="180px"; x.style.width="180px"; &#125; functionnormalImg(x)&#123; x.style.height="128px"; x.style.width="128px"; &#125;&lt;/script&gt; onmouseup和onmousedownOnmouseup:当鼠标松开时触发事件 Onmousedown:当鼠标按下键时触发事件 123456789101112&lt;p id="p1" onmousedown="mouseDown()" onmouseup="mouseUp()"&gt;请点击文本！mouseDown()函数当鼠标按钮在段落上被按下时触发。此函数把文本颜色设置为红色。mouseUp() 函数在鼠标按钮被释放时触发。mouseUp() 函数把文本的颜色设置为绿色。&lt;/p&gt;&lt;script type="text/javascript"&gt; functionmouseDown()&#123; document.getElementById("p1").style.color="red"; &#125; functionmouseUp()&#123; document.getElementById("p1").style.color="green"; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript之DOM操作]]></title>
    <url>%2F2017%2F05%2F06%2Fjavascript%E4%B9%8BDOM%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[前言DOM 中的三个字母，D（文档）可以理解为整个 Web 加载的网页文档；O（对象）可以理解为类似 window 对象之类的东西，可以调用属性和方法，这里我们说的是 document对象；M（模型）可以理解为网页文档的树型结构。 一、document.getElementById() 根据Id获取元素节点1234567891011&lt;div id="div1"&gt; &lt;p id="p1"&gt; 我是第一个P&lt;/p&gt; &lt;p id="p2"&gt; 我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var str = document.getElementById("p1").innerHTML; alert(str); //弹出 我是第一个P &#125; 二、document.getElementsByName() 根据name获取元素节点12345678910111213&lt;div id="div1"&gt; &lt;p id="p1"&gt; 我是第一个P&lt;/p&gt; &lt;p id="p2"&gt; 我是第二个P&lt;/p&gt; &lt;input type="text" value="请输入值" name="userName" /&gt; &lt;input type="button" value="确定" onclick="fun1()"&gt;&lt;/div&gt; function fun1() &#123; var username = document.getElementsByName("userName")[0].value; alert(username); //输出userName里输入的值&#125; 三、document.getElementsByTagName() 根据HTML标签名获取元素节点，注意getElements*的选择器返回的是一个NodeList对象，能根据索引号选择其中1个，可以遍历输出。123456789101112131415161718192021222324&lt;div id="div1"&gt; &lt;p id="p1"&gt; 我是第一个P&lt;/p&gt; &lt;p id="p2"&gt; 我是第二个P&lt;/p&gt; &lt;/div&gt; window.onload = function () &#123; var str = document.getElementsByTagName("p")[1].innerHTML; alert(str); //输出 我是第二个P，因为获取的是索引为1的P，索引从0开始 &#125; window.onload = function () &#123; var arr = document.getElementsByTagName("p"); for (var i = 0; i &lt; arr.length; i++) &#123; alert(arr[i].innerHTML); &#125; &#125; window.onload = function () &#123; var node = document.getElementById("div1"); var node1 = document.getElementsByTagName("p")[1]; //从获取到的元素再获取 alert(node1.innerHTML); &#125; 四、document.getElementsByClassName() 根据class获取元素节点1234567891011&lt;div id="div1"&gt; &lt;p id="p1" class="class1"&gt; 我是第一个P&lt;/p&gt; &lt;p id="p2"&gt; 我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var node = document.getElementsByClassName("class1")[0]; alert(node.innerHTML); &#125; 五、javascript中的CSS选择器1234567891011121314151617181920document.querySelector() //根据CSS选择器的规则，返回第一个匹配到的元素document.querySelectorAll() //根据CSS选择器的规则，返回所有匹配到的元素&lt;div id="div1"&gt; &lt;p id="p1" class="class1"&gt; 我是第一个P&lt;/p&gt; &lt;p id="p2" class="class2"&gt; 我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var node = document.querySelector("#div1 &gt; p"); alert(node.innerHTML); //输出 我是第一个P var node1 = document.querySelector(".class2"); alert(node1.innerHTML); //输出 我是第二个P var nodelist = document.querySelectorAll("p"); alert(nodelist[0].innerHTML + " - " + nodelist[1].innerHTML); //输出 我是第一个P - 我是第二个P&#125; 六、文档结构和遍历作为节点数的文档 ​ parentNode 获取该节点的父节点 ​ childNodes 获取该节点的子节点数组 ​ firstChild 获取该节点的第一个子节点 ​ lastChild 获取该节点的最后一个子节点 ​ nextSibling 获取该节点的下一个兄弟元素 ​ previoursSibling 获取该节点的上一个兄弟元素 ​ nodeType 节点的类型，9代表Document节点，1代表Element节点，3代表Text节点，8代表 Comment节点，11代表DocumentFragment节点 ​ nodeVlue Text节点或Comment节点的文本内容 ​ nodeName 元素的标签名(如P,SPAN,#text(文本节点),DIV)，以大写形式表示 注意，以上6个方法连元素节点也算一个节点。 12345678910111213141516171819202122232425262728293031323334353637&lt;div id="div1"&gt; &lt;p id="p1" class="class1"&gt; 我是第一个P&lt;/p&gt; &lt;p id="p2" class="class2"&gt; 我是第二个P&lt;/p&gt;&lt;/div&gt; window.onload = function () &#123; var node1 = document.querySelector(".class2"); alert(node1.parentNode.innerHTML); //输出 &lt;p id="p1" class="class1"&gt;我是第一个P&lt;/p&gt;&lt;p id="p2" class="class2"&gt;我是第二个P&lt;/p&gt; var nodelist = document.getElementById("div1"); var arr = nodelist.childNodes; alert(arr[1].innerHTML + " - " + arr[3].innerHTML); //输出 我是第一个P - 我是第二个P 为什么是1，3呢？因为本方法文本节点也会获取，也就是说0,2,4是文本节点 &#125;&lt;div id="div1"&gt; 文本1 &lt;p id="p1" class="class1"&gt; 我是第一个P&lt;/p&gt; 文本2 &lt;p id="p2" class="class2"&gt; 我是第二个P&lt;/p&gt; 文本3&lt;/div&gt;window.onload = function () &#123; //依次输出，文本1，我是第一个P，文本2，我是第二个P，文本3 var node = document.getElementById("div1"); for (var i = 0; i &lt; node.childNodes.length; i++) &#123; if (node.childNodes[i].nodeType == 1) &#123; alert(node.childNodes[i].innerHTML); &#125; else if (node.childNodes[i].nodeType == 3) &#123; alert(node.childNodes[i].nodeValue); &#125; &#125;&#125; 作为元素树的文档 ​ firstElementChild 第一个子元素节点 ​ lastElementChild 最后一个子元素节点 ​ nextElementSibling 下一个兄弟元素节点 ​ previousElementSibling 前一个兄弟元素节点 ​ childElementCount 子元素节点个数量 注意，此5个方法文本节点不算进去 123456789101112131415161718&lt;div id="div1"&gt; &lt;p id="p1" class="class1"&gt; 我是第一个P&lt;/p&gt; &lt;p id="p2" class="class2"&gt; 我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var node = document.getElementById("div1"); var node1 = node.firstElementChild; var node2 = node.lastElementChild; alert(node.childElementCount); //输出2，div1一共有两个非文档子元素节点 alert(node1.innerHTML); //输出 我是第一个P alert(node2.innerHTML); //输出 我是第二个P alert(node2.previousElementSibling.innerHTML); //输出 我是第一个P(第二个元素节点的上一个非文本元素节点是P1) alert(node1.nextElementSibling.innerHTML); //输出 我是第二个P(第一个元素节点的下一个兄弟非文本节点是P2)&#125; 七、javascript操作HTML属性1、属性的读取，此处要注意的是，某些HTML属性名称在javascript之中是保留字，因此会有些许不同，如class,lable中的for在javascript中变为htmlFor,className。1234567891011121314&lt;div id="div1"&gt; &lt;p id="p1" class="class1"&gt; 我是第一个P&lt;/p&gt; &lt;img src="123.jpg" alt="我是一张图片" id="img1" /&gt; &lt;input type="text" value="我是一个文本框" id="input1" /&gt;&lt;/div&gt;window.onload = function () &#123; var nodeText = document.getElementById("input1"); alert(nodeText.value); //输出 我是一个文本框 var nodeImg = document.getElementById("img1"); alert(nodeImg.alt); //输出 我是一张图片 var nodeP = document.getElementById("p1"); alert(nodeP.className); //输出 class1 注意获取class是className，如果写成nodeP.class则输出undefined&#125; 2、属性的设置，此处同样要注意的是保留字1234567&lt;div id="div1"&gt; &lt;img src="1big.jpg" alt="我是一张图片" id="img1" onclick="fun1()" /&gt;&lt;/div&gt;function fun1() &#123; document.getElementById("img1").src = "1small.jpg"; //改变图片的路径属性。实现的效果为，当点击图片时，大图变小图。&#125; 3、非标准HTML属性getAttribute(); // 注意这两个方法是不必理会javascript保留字的，HTML属性是什么就怎么写。setAttribute(); 12345678&lt;div id="div1"&gt; &lt;img src="1big.jpg" alt="我是一张图片" class="imgClass" id="img1" onclick="fun1()" /&gt;&lt;/div&gt;function fun1() &#123; document.getElementById("img1").setAttribute("src", "1small.jpg"); alert(document.getElementById("img1").getAttribute("class"));&#125; 4、Attr节点的属性attributes属性 非Element对象返回null，Element一半返回Attr对象。Attr对象是一个特殊的Node,通过name与value获取属性名称与值。如:document.getElementById(“img1”)[0]; document.getElementById(“img1”).src; 123456789&lt;div id="div1"&gt; &lt;img src="1big.jpg" alt="我是一张图片" class="imgClass" id="img1" onclick="fun1()" /&gt;&lt;/div&gt;function fun1() &#123; alert(document.getElementById("img1").attributes[0].name); //输出 onclick 注意，通过索引器访问是写在右面在排前面，从0开始 alert(document.getElementById("img1").attributes.src.value); //输出1big.jpg document.getElementById("img1").attributes.src.value = "1small.jpg"; //点击后改变src属性，实现了点击大图变小图效果&#125; 八、元素的内容1、innerText、textContent innerText与textContent的区别，当文本为空时，innerText是””，而textContent是undefined2、innerHTML 123456789101112&lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p id="p2"&gt;我是第&lt;b&gt;二&lt;/b&gt;个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; alert(document.getElementById("p1").innerText); //注意火狐浏览器不支持innerText alert(document.getElementById("p1").textContent); //基本都支持textContent document.getElementById("p1").textContent = "我是p1，javascript改变了我"; //设置文档Text alert(document.getElementById("p2").textContent); alert(document.getElementById("p2").innerHTML); //innerHTML与innerText的区别，就是对HTML代码的输出方式Text不会输出HTML代码&#125; 九、创建，插入，删除节点1、document.createTextNode() 创建一个文本节点12345678910111213141516&lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p id="p2"&gt;我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var textNode = document.createTextNode("&lt;p&gt;我是一个javascript新建的节点&lt;/p&gt;"); document.getElementById("div1").appendChild(textNode);&#125;/* 完成后HTML变为： div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p id="p2"&gt;我是第二个P&lt;/p&gt; &lt;p&gt;我是一个javascript新建的节点&lt;/p&gt; &lt;/div&gt; */ 2、document.createElement() 创建一个元素节点12345678910111213141516&lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p id="p2"&gt;我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var pNode = document.createElement("p"); pNode.textContent = "新建一个P节点"; document.getElementById("div1").appendChild(pNode);&#125;/* &lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p id="p2"&gt;我是第二个P&lt;/p&gt; &lt;p&gt;新建一个P节点&lt;/p&gt; &lt;/div&gt; */ 3、插入节点appendChild() //将一个节点插入到调用节点的最后面insertBefore() //接受两个参数，第一个为待插入的节点，第二个指明在哪个节点前面，如果不传入第二个参数，则跟appendChild一样，放在最后。 12345678910111213141516171819&lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var pNode1 = document.createElement("p"); pNode1.textContent = "insertBefore插入的节点"; var pNode2 = document.createElement("p"); pNode2.textContent = "appendChild插入的节点"; document.getElementById("div1").appendChild(pNode2); document.getElementById("div1").insertBefore(pNode1,document.getElementById("p1"));&#125;/* 执行之后HTML代码为： &lt;div id="div1"&gt; &lt;p&gt;insertBefore插入的节点&lt;/p&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p&gt;appendChild插入的节点&lt;/p&gt; &lt;/div&gt; */ 十、删除和替换节点。1、removeChild(); 由父元素调用，删除一个子节点。注意是直接父元素调用，删除直接子元素才有效，删除孙子元素就没有效果了。1234567891011121314&lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p id="p2"&gt;我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var div1 = document.getElementById("div1"); div1.removeChild(document.getElementById("p2"));&#125;/* 执行之后代码变为： &lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; //注意到第二个P元素已经被移除了 &lt;/div&gt; */ 2、replaceChild() //删除一个子节点，并用一个新节点代替它，第一个参数为新建的节点，第二个节点为被替换的节点1234567891011121314151617&lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p id="p2"&gt;我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var div1 = document.getElementById("div1"); var span1 = document.createElement("span"); span1.textContent = "我是一个新建的span"; div1.replaceChild(span1,document.getElementById("p2"));&#125;/* 执行完成后HTML代码变为： &lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;span&gt;我是一个新建的span&lt;/span&gt; //留意到p2节点已经被替换为span1节点了 &lt;/div&gt; */ 十一、javascript操作元素CSS通过元素的style属性可以随意读取和设置元素的CSS样式，例子： 123456789101112&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; window.onload = function () &#123; alert(document.getElementById("div1").style.backgroundColor); document.getElementById("div1").style.backgroundColor = "yellow"; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="div1" style="width:100px; height:100px; background-color:red"&gt;&lt;/div&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>DOM操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript编码规范]]></title>
    <url>%2F2017%2F05%2F06%2FJavaScript%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[前言好的编码规范可以尽可能的减少一个软件的维护成本，并且几乎没有任何一个软件，在其整个生命周期中，均由最初的开发人员来维护；好的编码规范可以改善软件的可读性，可以让开发人员尽快而彻底地理解新的代码；好的编码规范可以最大限度的提高团队开发的合作效率；长期的规范性编码还可以让开发人员养成好的编码习惯，甚至锻炼出更加严谨的思维。 不规范写法举例句尾没有分号1var isHotel = json.type == "hotel" ? true : false 变量命名各种各样123var is_hotel;var isHotel;var ishotel; if缩写1234if (isHotel) console.log(true)else console.log(false) 使用eval1234567var json = eval(jsonText);/* eval 好不好取决于怎么使用它，一般认为的缺点： 1. 可读性非常差 2. 不好再做优化和编译 3. 会轻微增加性能消耗 4. 不安全，比如 eval input 的值 */ 变量未定义到处都是123456function() &#123; var isHotel = 'true'; ....... var html = isHotel ? '&lt;p&gt;hotel&lt;/p&gt;' : "";&#125; 超长函数12345function() &#123; var isHotel = 'true'; //....... 此处省略500行 return false;&#125; ……….书写不规范的代码让我们难以维护，有时候也让我们头疼。 （禁止）、（必须）等字眼，在这里只是表示强调，未严格要求。 前端规范之JavaScripttab键用（必须）用四个空格代替​ 因为在不同系统的编辑工具对tab解析不一样，windows下的tab键是占四个空格的位置，而在linux下会变成占八个空格的位置（除非你自己设定了tab键所占的位置长度）。 一些童鞋可能会有疑问，tab键换成四个空格，多麻烦啊~ 其实不然，我平时用sublime text比较多，在这个工具中可以对tab键进行设置。 每句代码后（必须）加”;” 这个是要引起注意的，比如： 1234a = b // 赋值(function()&#123; //....&#125;)() // 自执行函数 未加分号，结果被解析成 1a = b(function()&#123;//...&#125;)() //将b()()返回的结果赋值给a 这是截然不同的两个结果，所以对于这个问题必须引起重视！！！ 变量、常量、类的命名按（必须）以下规则执行：变量：必须采用骆驼峰的命名且首字母小写123456789// 正确的命名 var isHotel, isHotelBeijing, isHotelBeijingHandian; // 不推荐的命名 var is_Hotel, ishotelbeijing, IsHotelBeiJing; 常量：必须采用全大写的命名，且单词以_分割**，常量通常用于ajax请求url，和一些不会改变的数据 123// 正确的命名 var HOTEL_GET_URL = 'http://map.baidu.com/detail', PLACE_TYPE = 'hotel'; 类：必须采用骆驼峰的命名且首字母大写，如：1234// 正确的写法 var FooAndToo = function(name) &#123; this.name = name; &#125; 空格的使用1.if中的空格，先上例子 1234567891011 //正确的写法 if (isOk) &#123; console.log("ok"); &#125; //不推荐的写法 if(isOk)&#123; console.log("ok"); &#125;/* ()中的判断条件前后都(必须)加空格 ()里的判断前后(禁止)加空格，如：正确的写法: if (isOk)；不推荐的写法: if ( isOk ) */ 2.switch中的空格, 先上例子 1234567891011121314151617181920212223242526//正确的写法 switch(name) &#123; case "hotel": console.log(name); break; case "moive": console.log(name); break; default: // code &#125; //不推荐的写法 switch (name) &#123; // switch 后不应该有空格, 正确的写法: switch(name) &#123; // code case "hotel": console.log(name); break; // break; 应该和console.log对齐 case "movie": // 每个case之前需要有换行 console.log(name); break; // break; 应该和console.log对齐 default: // code &#125; 3.for中的空格，先上例子 12345678910111213141516171819 // 正确的写法 var names = ["hotel", "movie"], i, len; for (i=0, len=names.length; i &lt; len; i++) &#123; // code &#125; // 不推荐的写法 var names = ["hotel", "movie"], i, len; for(i = 0, len = names.length;i &lt; len;i++) &#123; // for后应该有空格，每个`;`号后需要有空格，变量的赋值不应该有空格 // code &#125;/* for后（必须）加空格 每个;后（必须）加空格 ()中禁止用var声明变量; 且变量的赋值 = 前后（禁止）加空格 */ 4.function 中的空格, 先上例子 12345678910111213141516 // 正确的写法 function call(name) &#123; &#125; var cell = function () &#123; &#125;; // 不推荐的写法 var call = function(name)&#123; // code &#125; /* 参数的反括号后（必须）加空格 function 后（必须）加空格 */ 5.var 中空格及定义，先上例子 12345678910111213 // 一个推荐的var写法组 function(res) &#123; var code = 1 + 1, json = JSON.parse(res), type, html; // code &#125;/* 声明变量 = 前后（必须）添加空格 每个变量的赋值声明以,结束后（必须）换行进行下一个变量赋值声明 （推荐）将所有不需要进行赋值的变量声明放置最后一行，且变量之间不需要换行 （推荐）当一组变量声明完成后，空一行后编写其余代码 */ 6.在同一个函数内部，局部变量的声明必须置于顶端 因为即使放到中间，js解析器也会提升至顶部（hosting） 1234567891011121314151617181920// 正确的书写var clear = function(el) &#123; var id = el.id, name = el.getAttribute("data-name"); ......... return true;&#125;// 不推荐的书写var clear = function(el) &#123; var id = el.id; ...... var name = el.getAttribute("data-name"); ......... return true;&#125; 7.块内函数必须用局部变量声明 123456789101112131415161718192021222324// 错误的写法 var call = function(name) &#123; if (name == "hotel") &#123; function foo() &#123; console.log("hotel foo"); &#125; &#125; foo &amp;&amp; foo(); &#125; // 推荐的写法 var call = function(name) &#123; var foo; if (name == "hotel") &#123; foo = function() &#123; console.log("hotel foo"); &#125; &#125; foo &amp;&amp; foo(); &#125;/* 引起的bug：第一种写法foo的声明被提前了; 调用call时：第一种写法会调用foo函数，第二种写法不会调用foo函数 */ 8.（禁止）使用eval，采取$.parseJSON 三个原因： 有注入风险，尤其是ajax返回数据 不方便debug 效率低，eval是一个执行效率很低的函数 建议： 使用new Function来代替eval的使用，最好就别用。 9.除了三目运算，if,else等（禁止）简写 12345678910111213// 正确的书写if (true) &#123; alert(name);&#125;console.log(name);// 不推荐的书写if (true) alert(name);console.log(name);// 不推荐的书写if (true)alert(name);console.log(name) 10.（推荐）在需要以{}闭合的代码段前增加换行，如：for if 1234567891011121314151617181920212223242526272829303132// 没有换行，小的代码段无法区分 if (wl &amp;&amp; wl.length) &#123; for (i = 0, l = wl.length; i &lt; l; ++i) &#123; p = wl[i]; type = Y.Lang.type(r[p]); if (s.hasOwnProperty(p)) &#123; if (merge &amp;&amp; type == 'object') &#123; Y.mix(r[p], s[p]); &#125; else if (ov || !(p in r)) &#123; r[p] = s[p]; &#125; &#125; &#125; &#125; // 有了换行，逻辑清楚多了 if (wl &amp;&amp; wl.length) &#123; for (i = 0, l = wl.length; i &lt; l; ++i) &#123; p = wl[i]; type = Y.Lang.type(r[p]); if (s.hasOwnProperty(p)) &#123; // 处理merge逻辑 if (merge &amp;&amp; type == 'object') &#123; Y.mix(r[p], s[p]); &#125; else if (ov || !(p in r)) &#123; r[p] = s[p]; &#125; &#125; &#125; &#125;/* 换行可以是空行，也可以是注释 */ 11.（推荐）使用Function进行类的定义，(不推荐)继承，如需继承采用成熟的类库实现继承 12345678910111213141516171819// 类的实现 function Person(name) &#123; this.name = name; &#125; Person.prototype.sayName = function() &#123; alert(this.name); &#125;; var me = new Person("Nicholas"); // 将this放到局部变量self function Persion(name, sex) &#123; var self = this; self.name = name; self.sex = sex; &#125;/* 平时咱们写代码，基本都是小程序，真心用不上什么继承，而且继承并不是JS的擅长的语言特性，尽量少用。如果非要使用的话，注意一点： */ 123456789function A()&#123; //...&#125;function B()&#123; //...&#125;B.prototype = new A();B.prototype.constructor = B; //原则上，记得把这句话加上/* 继承从原则上来讲，别改变他的构造函数，否则这个继承就显得很别扭了~ */ 12.(推荐)使用局部变量缓存反复查找的对象(包括但不限于全局变量、dom查询结果、作用域链较深的对象) 1234567// 缓存对象var getComment = function() &#123; var dom = $("#common-container"), // 缓存dom appendTo = $.appendTo, // 缓存全局变量 data = this.json.data; // 缓存作用域链较深的对象&#125; 13.当需要缓存 this 时必须使用 self 变量进行缓存 12345678910// 缓存this function Row(name) &#123; var self = this; self.name = name; $(".row").click(function() &#123; self.getName(); &#125;); &#125;/* self是一个保留字，不过用它也没关系。在这里，看个人爱好吧，可以用_this, that, me等这些词，都行，但是团队开发的时候统一下比较好。 */ 14.（不推荐）超长函数, 当函数超过100行，就要想想是否能将函数拆为两个或多个函数 15.待挖掘… 小结规范是死的，罗列这些东西，目的是为了让程序猿们对这些东西引起注意，平时写代码的时候注意格式，不仅仅方便了自己，也让其他阅读者看得舒服。可能还有一些地方没有涉及到，如果你有好的建议，欢迎提出来补充！]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>编码规范</tag>
      </tags>
  </entry>
</search>