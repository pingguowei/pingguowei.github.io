<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Node.js基础学习04--Buffer(缓冲区)]]></title>
    <url>%2F2017%2F05%2F26%2FNode-js%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A004-Buffer-%E7%BC%93%E5%86%B2%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[Node.js Buffer(缓冲区)JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。 但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。 在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。 创建 Buffer 类Node Buffer 类可以通过多种方式来创建。 方法 1创建长度为 10 字节的 Buffer 实例： 1var buf=new Buffer(10); 方法 2通过给定的数组创建 Buffer 实例： 1var buf=new Buffer([10,20,30,40,50]); 方法 3通过一个字符串来创建 Buffer 实例： 12var buf=new Buffer('www.itcabin.com','utf-8');// utf-8 是默认的编码方式，此外它同样支持以下编码："ascii", "utf8", "utf16le", "ucs2", "base64" 和 "hex"。 写入缓冲区语法写入 Node 缓冲区的语法如下所示： 1buf.write(string,offset,length,encoding); 参数参数描述如下： string - 写入缓冲区的字符串。 offset - 缓冲区开始写入的索引值，默认为 0 。 length - 写入的字节数，默认为 buffer.length encoding - 使用的编码。默认为 ‘utf8’ 。 返回值返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。 实例1234buf = new Buffer(256);len = buf.write("itcabin.com");console.log("写入字节数 : "+ len); 执行以上代码，输出结果为： 12$node main.js写入字节数 : 11 从缓冲区读取数据语法读取 Node 缓冲区数据的语法如下所示： 1buf.toString([encoding, start, end) 参数描述如下： encoding - 使用的编码。默认为 ‘utf8’ 。 start - 指定开始读取的索引位置，默认为 0。 end - 结束位置，默认为缓冲区的末尾。 返回值解码缓冲区数据并使用指定的编码返回字符串。 实例123456789buf = new Buffer(26);for (var i = 0 ; i &lt; 26 ; i++) &#123; buf[i] = i + 97;&#125;console.log( buf.toString('ascii')); // 输出: abcdefghijklmnopqrstuvwxyzconsole.log( buf.toString('ascii',0,5)); // 输出: abcdeconsole.log( buf.toString('utf8',0,5)); // 输出: abcdeconsole.log( buf.toString(undefined,0,5)); // 使用 'utf8' 编码, 并输出: abcde 执行以上代码，输出结果为： 12345$ node main.jsabcdefghijklmnopqrstuvwxyzabcdeabcdeabcde 将 Buffer 转换为 JSON 对象语法将 Node Buffer 转换为 JSON 对象的函数语法格式如下： 1buf.toJSON() 返回值返回 JSON 对象。 实例1234var buf = new Buffer('itcabin.com');var json = buf.toJSON(buf);console.log(json); 执行以上代码，输出结果为： 12&#123; type: 'Buffer', data: [ 105, 116, 99, 97, 98, 105, 110, 46, 99, 111, 109 ] &#125; 缓冲区合并语法Node 缓冲区合并的语法如下所示： 1Buffer.concat(list, totalLength) 参数描述如下： list - 用于合并的 Buffer 对象数组列表。 totalLength - 指定合并后Buffer对象的总长度。 返回值返回一个多个成员合并的新 Buffer 对象。 实例1234var buffer1 = new Buffer('苹果味 ');var buffer2 = new Buffer('itcabin.com');var buffer3 = Buffer.concat([buffer1,buffer2]);console.log("buffer3 内容: " + buffer3.toString()); 执行以上代码，输出结果为： 1buffer3 内容: 苹果味 itcabin.com 缓冲区比较语法Node Buffer 比较的函数语法如下所示, 该方法在 Node.js v0.12.2 版本引入： 1buf.compare(otherBuffer); 参数描述如下： otherBuffer - 与 buf 对象比较的另外一个 Buffer 对象。 返回值返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同。 实例1234567891011var buffer1 = new Buffer('ABC');var buffer2 = new Buffer('ABCD');var result = buffer1.compare(buffer2);if(result &lt; 0) &#123; console.log(buffer1 + " 在 " + buffer2 + "之前");&#125;else if(result == 0)&#123; console.log(buffer1 + " 与 " + buffer2 + "相同");&#125;else &#123; console.log(buffer1 + " 在 " + buffer2 + "之后");&#125; 执行以上代码，输出结果为： 1ABC在ABCD之前 拷贝缓冲区语法Node 缓冲区拷贝语法如下所示： 1buf.copy(targetBuffer, targetStart, sourceStart, sourceEnd) 参数描述如下： targetBuffer - 要拷贝的 Buffer 对象。 targetStart - 数字, 可选, 默认: 0 sourceStart - 数字, 可选, 默认: 0 sourceEnd - 数字, 可选, 默认: buffer.length 返回值没有返回值。 实例12345var buffer1 = new Buffer('ABC');// 拷贝一个缓冲区var buffer2 = new Buffer(2);buffer1.copy(buffer2);console.log("buffer2 content: " + buffer2.toString()); 执行以上代码，输出结果为： 1buffer2 content: AB 缓冲区裁剪Node 缓冲区裁剪语法如下所示： 1buf.slice([start, end) 参数描述如下： start - 数字, 可选, 默认: 0 end - 数字, 可选, 默认: buffer.length 返回值返回一个新的缓冲区，它和旧缓冲区指向同一块内存，但是从索引 start 到 end 的位置剪切。 实例1234var buffer1 = new Buffer('itcabin');// 剪切缓冲区var buffer2 = buffer1.slice(0,2);console.log("buffer2 content: " + buffer2.toString()); 执行以上代码，输出结果为： 1buffer2 content: it 缓冲区长度语法Node 缓冲区长度计算语法如下所示： 1buf.length; 返回值返回 Buffer 对象所占据的内存长度。 实例123var buffer = new Buffer('www.runoob.com');// 缓冲区长度console.log("buffer length: " + buffer.length); 执行以上代码，输出结果为： 1buffer length: 11 方法参考手册以下列出了 Node.js Buffer 模块常用的方法（注意有些方法在旧版本是没有的）： 1.new Buffer(size)分配一个新的 size 大小单位为8位字节的 buffer。 注意, size 必须小于 kMaxLength，否则，将会抛出异常 RangeError。 2.new Buffer(buffer)拷贝参数 buffer 的数据到 Buffer 实例。 3.new Buffer(str[, encoding])分配一个新的 buffer ，其中包含着传入的 str 字符串。 encoding 编码方式默认为 ‘utf8’。 4.buf.length返回这个 buffer 的 bytes 数。注意这未必是 buffer 里面内容的大小。length 是 buffer 对象所分配的内存数，它不会随着这个 buffer 对象内容的改变而改变。 5.buf.write(string[, offset[, length]][, encoding])根据参数 offset 偏移量和指定的 encoding 编码方式，将参数 string 数据写入buffer。 offset 偏移量默认值是 0, encoding 编码方式默认是 utf8。 length 长度是将要写入的字符串的 bytes 大小。 返回 number 类型，表示写入了多少 8 位字节流。如果 buffer 没有足够的空间来放整个 string，它将只会只写入部分字符串。 length 默认是 buffer.length - offset。 这个方法不会出现写入部分字符。 6.buf.toString([encoding, start, end)根据 encoding 参数（默认是 ‘utf8’）返回一个解码过的 string 类型。还会根据传入的参数 start (默认是 0) 和 end (默认是 buffer.length)作为取值范围。 7.buf.toJSON()将 Buffer 实例转换为 JSON 对象。 8.buf[index]获取或设置指定的字节。返回值代表一个字节，所以返回值的合法范围是十六进制0x00到0xFF 或者十进制0至 255。 9.buf.compare(otherBuffer)比较两个 Buffer 对象，返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同。 10.buf.slice([start[, end]])剪切 Buffer 对象，根据 start(默认是 0 ) 和 end (默认是 buffer.length ) 偏移和裁剪了索引。 负的索引是从 buffer 尾部开始计算的。 11.buf.fill(value[, offset][, end])使用指定的 value 来填充这个 buffer。如果没有指定 offset (默认是 0) 并且 end (默认是 buffer.length) ，将会填充整个buffer。]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js基础学习</tag>
        <tag>Buffer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js基础学习03--EventEmitter]]></title>
    <url>%2F2017%2F05%2F25%2FNode-js%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A003-EventEmitter%2F</url>
    <content type="text"><![CDATA[Node.js EventEmitterNode.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。 Node.js里面的许多对象都会分发事件：一个net.Server对象会在每次有新连接时分发一个事件， 一个fs.readStream对象会在文件被打开的时候发出一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。 EventEmitter 类events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。 你可以通过require(“events”);来访问该模块。 1234// 引入 events 模块var events = require('events');// 创建 eventEmitter 对象var eventEmitter = new events.EventEmitter(); EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。 下面我们用一个简单的例子说明 EventEmitter 的用法： 123456789// event.js 文件var EventEmitter = require('events').EventEmitter; var event = new EventEmitter(); event.on('myEvent', function() &#123; console.log('myEvent 事件触发'); &#125;); setTimeout(function() &#123; event.emit('some_event'); &#125;, 1000); event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在 1000 毫秒以后向 event 对象发送事件 some_event，此时会调用some_event 的监听器。 EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。 当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。 让我们以下面的例子解释这个过程： 123456789var events=require('events');var emitter=new events.EventEmitter();emitter.on('myEvent',function(arg1,arg2)&#123; console.log('listener1',arg1,arg2);&#125;);emitter.on('myEvent',function(arg1,arg2)&#123; console.log('listener2',arg1,arg2);&#125;);emitter.emit('myEvent','arg1参数','arg2参数'); 执行以上代码，运行的结果如下： 以上例子中，emitter 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件。 运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是EventEmitter最简单的用法。 EventEmitter 提供了多个属性，如 on 和 emit。on 函数用于绑定事件函数，emit 属性用于触发一个事件。接下来我们来具体看下 EventEmitter 的属性介绍。 方法1.addListener(event, listener) 为指定事件添加一个监听器到监听器数组的尾部。 2.on(event, listener) 为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。 123server.on('connection', function (stream) &#123; console.log('someone connected!');&#125;); 3.once(event, listener) 为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。 123server.once('connection', function (stream) &#123; console.log('Ah, we have our first user!');&#125;); 4.removeListener(event, listener) 移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。 它接受两个参数，第一个是事件名称，第二个是回调函数名称。 123456var callback = function(stream) &#123; console.log('someone connected!');&#125;;server.on('connection', callback);// ...server.removeListener('connection', callback); 5.removeAllListeners([event]) 移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。 6.setMaxListeners(n) 默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。 7.listeners(event) 返回指定事件的监听器数组。 8.emit(event, [arg1], [arg2], […]) 按参数的顺序执行每个监听器，如果事件有注册监听返回 true，否则返回 false。 类方法1.listenerCount(emitter, event) 返回指定事件的监听器数量。 事件1.newListener event - 字符串，事件名称 listener - 处理事件函数 该事件在添加新监听器时被触发。 2.removeListener event - 字符串，事件名称 listener - 处理事件函数 从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引。 实例以下实例通过 connection（连接）事件演示了 EventEmitter 类的应用。 创建 main.js 文件，代码如下： 123456789101112131415161718192021222324252627282930313233343536var events = require('events');var eventEmitter = new events.EventEmitter();// 监听器 #1var listener1 = function listener1() &#123; console.log('监听器 listener1 执行。');&#125;// 监听器 #2var listener2 = function listener2() &#123; console.log('监听器 listener2 执行。');&#125;// 绑定 connection 事件，处理函数为 listener1 eventEmitter.addListener('connection', listener1);// 绑定 connection 事件，处理函数为 listener2eventEmitter.on('connection', listener2);var eventListeners = require('events').EventEmitter.listenerCount(eventEmitter,'connection');console.log(eventListeners + " 个监听器监听连接事件。");// 处理 connection 事件 eventEmitter.emit('connection');// 移除监绑定的 listener1 函数eventEmitter.removeListener('connection', listener1);console.log("listener1 不再受监听。");// 触发连接事件eventEmitter.emit('connection');eventListeners = require('events').EventEmitter.listenerCount(eventEmitter,'connection');console.log(eventListeners + " 个监听器监听连接事件。");console.log("程序执行完毕。"); 执行以上代码，运行的结果如下： error 事件EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。 当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。 我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。例如： 123var events = require('events'); var emitter = new events.EventEmitter(); emitter.emit('error'); 运行时会显示以下错误： 继承 EventEmitter大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。 为什么要这样做呢？原因有两点： 首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发射应该是一个对象的方法。 其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js基础学习</tag>
        <tag>EventEmitter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js基础学习02--回调函数、事件循环]]></title>
    <url>%2F2017%2F05%2F24%2FNode-js%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A002-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E3%80%81%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[Node.js回调函数Node.js 异步编程的直接体现就是回调。 异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。 回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。 例如，我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I/O 操作。这就大大提高了 Node.js 的性能，可以处理大量的并发请求。 阻塞代码实例创建一个文件 input.txt ，内容如下： 1苹果味博客：itcabin.com 创建 main.js 文件, 代码如下： 123456var fs = require("fs");var data = fs.readFileSync('input.txt');console.log(data.toString());console.log("程序执行结束!"); 以上代码执行结果如下： 1234$ node main.js苹果味博客：itcabin.com程序执行结束! 非阻塞代码实例创建 main.js 文件, 代码如下： 12345678var fs = require("fs");fs.readFile('input.txt', function (err, data) &#123; if (err) return console.error(err); console.log(data.toString());&#125;);console.log("程序执行结束!"); 以上代码执行结果如下： 123$ node main.js程序执行结束!苹果味博客：itcabin.com 以上两个实例我们了解了阻塞与非阻塞调用的不同。第一个实例在文件读取完后才执行完程序。 第二个实例我们不需要等待文件读取完，这样就可以在读取文件时同时执行接下来的代码，大大提高了程序的性能。 因此，阻塞是按顺序执行的，而非阻塞是不需要按顺序的，所以如果需要处理回调函数的参数，我们就需要写在回调函数内。 Node.js 事件循环Node.js 是单进程单线程应用程序，但是通过事件和回调支持并发，所以性能非常高。 Node.js 的每一个 API 都是异步的，并作为一个独立线程运行，使用异步函数调用，并处理并发。 Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。 Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数. 事件驱动程序Node.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。 当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。 在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。 整个事件驱动的流程就是这么实现的，非常简洁。有点类似于观察者模式，事件相当于一个主题(Subject)，而所有注册到这个事件上的处理函数相当于观察者(Observer)。 Node.js 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件，如下实例： 1234// 引入 events 模块var events = require('events');// 创建 eventEmitter 对象var eventEmitter = new events.EventEmitter(); 以下程序绑定事件处理程序： 12// 绑定事件及事件的处理程序eventEmitter.on('eventName', eventHandler); 我们可以通过程序触发事件： 12// 触发事件eventEmitter.emit('eventName'); 实例创建 main.js 文件，代码如下所示： 12345678910111213141516171819202122232425// 引入 events 模块var events = require('events');// 创建 eventEmitter 对象var eventEmitter = new events.EventEmitter();// 创建事件处理程序var connectHandler = function connected() &#123; console.log('连接成功。'); // 触发 data_received 事件 eventEmitter.emit('data_received');&#125;// 绑定 connection 事件处理程序eventEmitter.on('connection', connectHandler); // 使用匿名函数绑定 data_received 事件eventEmitter.on('data_received', function()&#123; console.log('数据接收成功。');&#125;);// 触发 connection 事件 eventEmitter.emit('connection');console.log("程序执行完毕。"); 执行结果： Node 应用程序是如何工作的？在 Node 应用程序中，执行异步操作的函数将回调函数作为最后一个参数， 回调函数接收错误对象作为第一个参数。 接下来让我们来重新看下前面的实例，创建一个 input.txt ,文件内容如下： 1苹果味博客：itcabin.com 创建 main.js 文件，代码如下： 12345678910var fs = require("fs");fs.readFile('input.txt', function (err, data) &#123; if (err)&#123; console.log(err.stack); return; &#125; console.log(data.toString());&#125;);console.log("程序执行完毕"); 以上程序中 fs.readFile() 是异步函数用于读取文件。 如果在读取文件过程中发生错误，错误 err 对象就会输出错误信息。 如果没发生错误，readFile 跳过 err 对象的输出，文件内容就通过回调函数输出。 执行以上代码，执行结果如下： 接下来我们删除 input.txt 文件，执行结果如下所示： 因为文件 input.txt 不存在，所以输出了错误信息。]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js基础学习</tag>
        <tag>回调函数</tag>
        <tag>事件循环</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js基础学习01--创建第一个应用]]></title>
    <url>%2F2017%2F05%2F23%2FNode-js%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A001-%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Node.js简介简单的说 Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。 Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。 Node.js 创建第一个应用在我们创建 Node.js 第一个 “Hello, World!” 应用前，让我们先了解下 Node.js 应用是由哪几部分组成的： 引入 required 模块：我们可以使用 require 指令来载入 Node.js 模块。 创建服务器：服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。 接收请求与响应请求 服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。 创建 Node.js 应用步骤一、引入 required 模块我们使用 require 指令来载入 http 模块，并将实例化的 HTTP 赋值给变量 http，实例如下: 1var http = require("http"); 步骤二、创建服务器接下来我们使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。 函数通过 request, response 参数来接收和响应数据。 实例如下，在你项目的根目录下创建一个叫 server.js 的文件，并写入以下代码： 12345678910111213var http=require('http');http.createServer(function(request,response)&#123; // 发送HTTP头部 // HTTP 状态值：200：ok // 内容类型：text/plain response.writeHead(200,&#123;'Content-Type':'text/plain'&#125;); // 发送响应数据"Hello World\n" response.end('Hello World\n');&#125;).listen(8888);// 终端打印信息如下console.log('Server running at http://127.0.0.1:8888/') 以上代码我们完成了一个可以工作的 HTTP 服务器。 使用 node 命令执行以上的代码： 12node server.jsServer running at http://127.0.0.1:8888/ 接下来，打开浏览器访问 http://127.0.0.1:8888/，你会看到一个写着 “Hello World”的网页。 分析Node.js 的 HTTP 服务器： 第一行请求（require）Node.js 自带的 http 模块，并且把它赋值给 http 变量。 接下来我们调用 http 模块提供的函数： createServer 。这个函数会返回 一个对象，这个对象有一个叫做 listen 的方法，这个方法有一个数值参数， 指定这个 HTTP 服务器监听的端口号。]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js基础学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript整理：this,call,apply,bind总结]]></title>
    <url>%2F2017%2F05%2F21%2FJavaScript%E6%95%B4%E7%90%86%EF%BC%9Athis-call-apply-bind%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、thisJavaScript 中的 this 总是指向一个对象，而具体指向那个对象是在运行时基于函数的执行环境动态绑定的，而非函数声明时的环境实际应用中 this 的指向大致可以分为以下 4 中： 作为对象的方法调用 作为普通函数掉用 构造器调用 Function.prototype.call 或 Function.prototype.apply 调用, 可以动态地改变出入函数的 this 1.作为对象的方法调用时， this 指向该对象12345678var obj = &#123; a: 1, getA: function()&#123; console.log( this == obj ); // true console.log( this.a ); // 1 &#125;&#125;;obj.getA(); 2.作为普通函数掉用，this 总是指向全局对象 window12345678console.log(this); // Windowswindow.name = "globalName";var getName = function() &#123; return this.name;&#125;console.log( getName() ); // globalName 3.构造器调用, 当用 new 运算符调用函数时，该函数总是会返回一个对象，通常情况下，构造函数里的 this 就指向返回的这个对象12345var MyClass = function()&#123; this.name = "class"; &#125;var obj = new MyClass();console.log( obj.name ); // class 如果使用 new 调用构造器时，构造器显式地返回了一个 object 类型的对象，那么此次运算结果最终会返回这个对象，而不是我么之前期待的 this 12345678var MyClass = function()&#123; this.name = "class"; return &#123; name: "other" &#125;&#125;var obj = new MyClass(); // 返回的是 &#123;name:"other"&#125; 这个对象console.log(obj.name); // other 二、 call 和 apply 他们的作用一模一样，区别仅在于传入参数形式的不同。​ apply 接收两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以是数组，也可以是类数组，apply 方法把这个集合中的元素作为参数传入被调用的函数。​ call 传入的参数不固定，跟 apply 相同的是，第一个参数也代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数 1234567var func = function(a, b, c)&#123; console.log([a, b, c]);&#125;//传入的第一个参数为 null ，函数体内的 this 会指向默认的宿主对象，在浏览器中则是 windowfunc.apply(null, [1, 2, 3]); // 输出：[ 1, 2, 3 ]func.call(null, 1, 2, 3); // 输出：[ 1, 2, 3 ] call 和 apply 的用途: 1.改变 this 指向12345678910111213141516var obj1 = &#123; name: "obj1"&#125;;var obj2 = &#123; name: "obj2"&#125;;window.name = "window";var getName = function()&#123; console.log( this.name );&#125;getName(); // windowgetName.call( obj1 ); // obj1getName.call( obj2 ); // obj2 当执行 getName.call( obj1 ) 这句代码时， getName 函数体内的 this 就指向 obj1 对象，所以此处的 123var getName = function()&#123; console.log( this.name );&#125; 实际上相当于 123var getName = function()&#123; console.log( obj1.name );&#125; 2.用来模拟 Function.prototype.bind 指定函数内部的 this 指向3.借用其他对象的方法， 可以模拟实现继承123456789101112var A = function(name)&#123; this.name = name;&#125;var B = function()&#123; A.apply( this, arguments);&#125;B.prototype.getName = function()&#123; return this.name;&#125;var b = new B("2B铅笔");console.log( b.getName() ); // 输出： 2B铅笔 借用 Array.prototype 对象上的方法，对参数列表 arguments 这个类数组对象，进行数组对象方法的调用 1234(function()&#123; Array.prototype.push.call( arguments, 3); console.log( arguments ); // 输出： [1, 2, 3]&#125;)(1, 2); 三、ECMAScript 5 中的 bind() 方法可以将函数绑定到一个对象上1234function f(y) &#123;return this.x + y&#125;;var o = &#123; x: 1&#125;;var g = f.bind(o);g(2); // 3]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>this</tag>
        <tag>call</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL日常记录]]></title>
    <url>%2F2017%2F05%2F21%2FSQL%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[SQL语句增加字段、修改字段、修改类型、修改默认值一、添加字段123ALTER TABLE table_name ADD column_name datatype-- 例如ALTER TABLE Persons ADD Birthday date 二、删除字段123ALTER TABLE table_name DROP COLUMN column_name-- 例如ALTER TABLE Person DROP COLUMN Birthday 三、改变字段数据类型123ALTER TABLE table_name ALTER COLUMN column_name datatype-- 例如ALTER TABLE Persons ALTER COLUMN Birthday int 四、修改字段名1234567891011--不能用SQL修改字段名,试用以下方法alter table table_name add new_field_name intgoupdate table_nameset new_field_name = old_field_namegoalter table table_name drop column old_field_namego-- 添加新的字段，赋值，删除旧的字段]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL日常笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL常用函数]]></title>
    <url>%2F2017%2F05%2F20%2FSQL%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[类型转换函数123456789101112131415161718--select :输出为结果集--虚拟表--print：以文本形式输出 只能输出一个字符串值.print 1+'a'select 1,2select * from Student--类型转换--Convert(目标类型,源数据,[格式]) --日期有格式print '我的成绩是：'+convert(char(3),100)print '今天是个大日子：'+convert(varchar(30),getdate(),120)select getdate()select len(getdate())--cast(源数据 as 目标类型) 它没有格式print '我的成绩是：'+cast(100 as char(3)) 日期函数12345678910--getdate():获取当前服务器日期select GETDATE()--可以在源日期值是追加指定时间间隔的日期数select DATEADD(dd,-90,GETDATE())--dateDiff:找到两个日期之间指定格式的差异值select StudentName,DATEDIFF(yyyy,getdate(),BornDate) as age from Student order by age--DATENAME:可以获取日期的指定格式的字符串表现形式select DATENAME(dw,getdate())--DATEPART:可以获取指定的日期部分select cast(DATEPART(yyyy,getdate()) as CHAR(4))+'-' +cast(DATEPART(mm,getdate()) as CHAR(2))+'-' +cast(DATEPART(dd,getdate()) as CHAR(2)) 数学函数12345678910111213141516--rand:随机数:返回0到1之间的数，理论上说可以返回0但是不能返回1select RAND()--abs:absolute:取绝对值select ABS(-100)--ceiling:获取比当前数大的最小整数select CEILING(1.00)--floor:获取比当前数小的最大整数select floor(1.99999)--power:幂运算 3*3*3*3select POWER(3,4) ---81--round():四舍五入.只关注指定位数后一位select ROUND(1.549,1)--sign:正数==1 负数 ==-1 0=0select SIGN(-100)select ceiling(17*1.0/5) 联合结果集union123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657--联合结果集unionselect * from Student where Sex='男'--unionselect * from Student where Sex='女'--联合的前提是：--1.列的数量需要一致:使用 UNION、INTERSECT 或 EXCEPT 运算符合并的所有查询必须在其目标列表中有相同数目的表达式--2.列的类型需要可以相互转换select StudentName,Sex from Student --在字符串排序的时候，空格是最小的，排列在最前面unionselect cast(ClassId as CHAR(3)),classname from grade--union和union all的区别--union是去除重复记录的--union all不去除重复 ：效率更高，因为不需要判断记录是否重复，也没有必须在结果庥是执行去除重复记录的操作。但是可以需要消耗更多的内存存储空间select * from Student where ClassId=2union allselect * from Student where ClassId=2--查询office这科目的全体学员的成绩，同时在最后显示它的平均分，最高分，最低分select ' '+cast(StudentNo as CHAR(3)),cast(SubjectId as CHAR(2)),StudentResult from Result where SubjectId=1unionselect '1','平均分',AVG(StudentResult) from Result where SubjectId=1unionselect '1','最高分',max(StudentResult) from Result where SubjectId=1unionselect '1','最低分',min(StudentResult) from Result where SubjectId=1--一次性插入多条数据--1.先将数据复制到另外一个新表中，删除源数据表，再将新表的数据插入到源数据表中--1.select */字段 into 新表 from 源表--1.新表是系统自动生成的，不能人为创建，如果新表名称已经存在就报错--2.新表的表结构与查询语句所获取的列一致，但是列的属性消失，只保留非空和标识列。其它全部消失，如主键，唯一键，关系，约束，默认值select * into newGrade from gradetruncate table gradeselect * from newGrade--select * into grade from newGrade--2.insert into 目标表 select 字段列表/* from 数据源表--1、目标表必须先存在，如果没有就报错--2.查询的数据必须符合目标表的数据完整性--3.查询的数据列的数量和类型必须的目标的列的数量和对象完全对应insert into grade select classname from newGradedelete from admin--使用union一次性插入多条记录--insert into 表(字段列表)--select 值。。。。 用户自定义数据--union--select 值 。。。。insert into Adminselect 'a','a'union allselect 'a','a'union allselect 'a','a'union allselect 'a',null CASE函数用法12345678910相当于switch case—c#中的switch…case只能做等值判断这可以对字段值或者表达式进行判断，返回一个用户自定义的值，它会生成一个新列2.要求then后面数据的类型一致1.第一种做等值判断的case..endcase 字段或者表达式when .值..then .自定义值when .值..then .自定义值…..else 如果不满足上面所有的when就满足这个elseend 1234567891011121314151617181920212223242526272829303132333435363738394041--显示具体班级的名称select StudentNo,StudentName,case ClassId --如果case后面接有表达式或者字段，那么这种结构就只能做等值判断，真的相当于switch..case when 1 then '一班' when 2 then '2班' when 3 then '3班' when null then 'aa' --不能判断null值 else '搞不清白'end,sex from Student--2.做范围判断，相当于if..else，它可以做null值判断--case --如果没有表达式或者字段就可实现范围判断-- when 表达式 then 值 --不要求表达式对同一字段进行判断-- when 表达式 then 值 -- .....--else 其它情况 --endselect StudentNo,StudentName,case when BornDate&gt;'2000-1-1' then '小屁孩' when BornDate&gt;'1990-1-1' then '小青年' when BornDate&gt;'1980-1-1' then '青年' --when Sex='女' then '是女的' when BornDate is null then '出生不详' else '中年'end from Student--百分制转换为素质教育 90 -A 80--B 70 --C 60 --D &lt;60 E NULL--没有参加考试select StudentNo,SubjectId,case when StudentResult&gt;=90 then 'A' when StudentResult&gt;=80 then 'B' when StudentResult&gt;=70 then 'C' when StudentResult&gt;=60 then 'D' when StudentResult is null then '没有参加考试' else 'E'end 成绩,ExamDate from Result IF ELSE语法12341,.没有｛｝，使用begin..end.如果后面只有一句，可以不使用begin..end包含2.没有bool值，只能使用关系运算符表达式3.也可以嵌套和多重4.if后面的（）可以省略 123456789101112131415declare @subjectname nvarchar(50)='office' --科目名称declare @subjectId int=(select Subjectid from Subject where SubjectName=@subjectname) --科目IDdeclare @avg int --平均分set @avg=(select AVG(StudentResult) from Result where SubjectId=@subjectId and StudentResult is not null) --获取平均分print @avgif @avg&gt;=60 begin print '成绩不错，输出前三名：' select top 3 * from Result where SubjectId=@subjectId order by StudentResult desc end else begin print '成绩不好，输出后三名：' select top 3 * from Result where SubjectId=@subjectId order by StudentResult end 子查询1234567子查询–一个查询中包含另外一个查询。被包含的查询就称为子查询，。包含它的查询就称父查询1.子查询的使用方式：使用（）包含子查询2.子查询分类：1.独立子查询：子查询可以直接独立运行查询比“王八”年龄小的学员信息select * from Student where BornDate&lt;(select BornDate from Student where StudentName=’王八’)2.相关子查询:子查询使用了父查询中的结果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152--子查询的三种使用方式--1.子查询做为条件,子查询接在关系运算符后面 &gt; &lt; &gt;= &lt;= = &lt;&gt; !=,如果是接这关系运算符后面，必须保证 子查询只返回一个值--查询六期班的学员信息select * from Student where ClassId=(select ClassId from grade where classname='八期班')--子查询返回的值不止一个。当子查询跟随在 =、!=、&lt;、&lt;=、&gt;、&gt;= 之后，或子查询用作表达式时，这种情况是不允许的。select * from Student where ClassId=(select ClassId from grade)--查询八期班以外的学员信息--当子查询返回多个值(多行一列),可以使用in来指定这个范围select * from Student where ClassId in(select ClassId from grade where classname&lt;&gt;'八期班')--当没有用 EXISTS 引入子查询时，在选择列表中只能指定一个表达式。如果是多行多列或者一行多列就需要使用exists--使用 EXISTS 关键字引入子查询后，子查询的作用就相当于进行存在测试。外部查询的 WHERE 子句测试子查询返回的行是否存在select * from Student where EXISTS(select * from grade)select * from Student where ClassId in(select * from grade)--2.子查询做为结果集--select top 5 * from Student --前五条--使用top分页select top 5 * from Student where StudentNo not in(select top 5 studentno from Student)--使用函数分页 ROW_NUMBER() over(order by studentno),可以生成行号,排序的原因是因为不同的排序方式获取的记录顺序不一样select ROW_NUMBER() over(order by studentno),* from Student--查询拥有新生成行号的结果集 注意:1.子查询必须的别名 2.必须为子查询中所有字段命名,也就意味着需要为新生成的行号列命名select * from (select ROW_NUMBER() over(order by studentno) id,* from Student) temp where temp.id&gt;0 and temp.id&lt;=5select * from (select ROW_NUMBER() over(order by studentno) id,* from Student) temp where temp.id&gt;5 and temp.id&lt;=10select * from (select ROW_NUMBER() over(order by studentno) id,* from Student) temp where temp.id&gt;10 and temp.id&lt;=15--3.子查询还可以做为列的值select (select studentname from student where studentno=result.studentno),(select subjectname from subject where subjectid=result.SubjectId), StudentResult from Result--使用Row_number over()实现分页--1.先写出有行号的结果集select ROW_NUMBER() over(order by studentno),* from Student--2.查询有行号的结果集 子查询做为结果集必须添加别名，子查询的列必须都有名称select * from (select ROW_NUMBER() over(order by studentno) id,* from Student) temp where id&gt;0 and id&lt;=5--查询年龄比“廖杨”大的学员，显示这些学员的信息select * from Student where BornDate&lt;(select BornDate from Student where StudentName='廖杨')--查询二期班开设的课程select * from Subject where ClassId=(select ClassId from grade where classname='二期班')--查询参加最近一次“office”考试成绩最高分和最低分--1查询出科目 IDselect subjectid from Subject where SubjectName='office'--2.查询出这一科目的考试日期select MAX(ExamDate) from Result where SubjectId=(select subjectid from Subject where SubjectName='office')--3,写出查询的框架select MAX(StudentResult),MIN(StudentResult) from Result where SubjectId=() and ExamDate=()--4.使用子查询做为条件select MAX(StudentResult),MIN(StudentResult) from Result where SubjectId=( select subjectid from Subject where SubjectName='office' ) and ExamDate=( select MAX(ExamDate) from Result where SubjectId=( select subjectid from Subject where SubjectName='office' ) ) 表连接Join12345--1.inner join :能够找到两个表中建立连接字段值相等的记录--查询学员信息显示班级名称select Student.StudentNo,Student.StudentName,grade.classnamefrom Studentinner join grade on Student.ClassId=grade.ClassId 12345--左连接: 关键字前面的表是左表，后面的表是右表--左连接可以得到左表所有数据，如果建立关联的字段值在右表中不存在，那么右表的数据就以null值替换select PhoneNum.*,PhoneType.*from PhoneNum left join PhoneType on PhoneNum.pTypeId=PhoneType.ptId 12345--右连接: 关键字前面的表是左表，后面的表是右表--右连接可以得到右表所有数据，如果建立关联的字段值在右左表中不存在，那么左表的数据就以null值替换select PhoneNum.*,PhoneType.*from PhoneNum right join PhoneType on PhoneNum.pTypeId=PhoneType.ptId 1234--full join :可以得到左右连接的综合结果--去重复select PhoneNum.*,PhoneType.*from PhoneNum full join PhoneType on PhoneNum.pTypeId=PhoneType.ptId 事务1234567891011121314一种处理机制。以事务处理的操作，要么都能成功执行，要么都不执行事务的四个特点 ACID：A:原子性：事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。它是一个整体，不能再拆分C：一致性：事务在完成时，必须使所有的数据都保持一致状态。。某种程度的一致I:隔离性：事务中隔离，每一个事务是单独的请求将单独的处理，与其它事务没有关系，互不影响D：持久性：如果事务一旦提交，就对数据的修改永久保留使用事务：将你需要操作的sql命令包含在事务中1.在事务的开启和事务的提交之间2.在事务的开启和事务的回滚之间三个关键语句：开启事务：begin transaction提交事务：commit transaction回滚事务：rollback transaction 1234567891011121314151617181920212223declare @num int =0 --记录操作过程中可能出现的错误号begin transaction update bank set cmoney=cmoney-500 where name='aa' set @num=@num+@@ERROR --说明这一句的执行有错误 但是不能在语句执行的过程中进行提交或者回滚 --语句块是一个整体，如果其中一句进行了提交或者回滚，那么后面的语句就不再属于当前事务， --事务不能控制后面的语句的执行 update bank set cmoney=cmoney+500 where name='bb' set @num=@num+@@ERROR select * from bank if(@num&lt;&gt;0 ) --这个@@ERROR只能得到最近一一条sql语句的错误号 begin print '操作过程中有错误，操作将回滚' rollback transaction end else begin print '操作成功' commit transaction end --事务一旦开启，就必须提交或者回滚 --事务如果有提交或者回滚，必须保证它已经开启 视图12345678视图就是一张虚拟表，可以像使用子查询做为结果集一样使用视图select * from vw_getinfo使用代码创建视图语法：create view vw_自定义名称as查询命令go 1234567891011121314151617--查询所有学员信息if exists(select * from sysobjects where name='vw_getAllStuInfo') drop view vw_getAllStuInfogo --上一个批处理结束的标记create view vw_getAllStuInfoas--可以通过聚合函数获取所以记录数 select top (select COUNT(*) from Student) Student.StudentNo,Student.StudentName,grade.ClassId,grade.classname from Studentinner join grade on Student.ClassId=grade.ClassId order by StudentName --视图中不能使用order by--select * from grade --只能创建一个查询语句--delete from grade where ClassId&gt;100 --在视图中不能包含增加删除修改go--使用视图。。就像使用表一样select * from vw_getAllStuInfo --对视图进行增加删除和修改操作--可以对视图进行增加删除和修改操作,只是建议不要这么做:所发可以看到：如果操作针对单个表就可以成功，但是如果 多张的数据就会报错：不可更新，因为修改会影响多个基表。update vw_getAllStuInfo set classname='asdas' ,studentname='aa' where studentno=1 触发器123456触发器:执行一个可以改变表数据的操作（增加删除和修改），会自动触发另外一系列（类似于存储过程中的模块）的操作。语法：create trigger tr_表名_操作名称on 表名 after|instead of 操作名称asgo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576if exists(select * from sysobjects where name='tr_grade_insert') drop trigger tr_grade_insertgocreate trigger tr_grade_inserton grade for insert ---为grade表创建名称为tr_grade_insert的触发器，在执行insert操作之后触发asdeclare @cnt int set @cnt = (select count(*) from student) select * ,@cnt from studentselect * from grade go--触发器不是被调用的，而是被某一个操作触 发的，意味着执行某一个操作就会自动触发 触发器insert into grade values('fasdfdssa')---替换触 发器：本来需要执行某一个操作，结果不做了，使用触 发器中的代码语句块进行替代if exists(select * from sysobjects where name='tr_grade_insert') drop trigger tr_grade_insertgocreate trigger tr_grade_inserton grade instead of insert ---为grade表创建名称为tr_grade_insert的触发器，在执行insert操作之后触发asdeclare @cnt int set @cnt = (select count(*) from student) select * ,@cnt from studentselect * from grade goinsert into grade values('aaaaaaaaaaaa')go---触 发器的两个临时表：--inserted: 操作之后的新表:所有新表与原始的物理表没有关系，只与当前操作的数据有关--deleted:操作之前的旧表：所有新表与原始的物理表没有关系，只与当前操作的数据有关if exists(select * from sysobjects where name='tr_grade_insert') drop trigger tr_grade_insertgocreate trigger tr_grade_inserton grade after insert as print '操作之前的表：操作之前，这一条记录还没有插入，所以没有数据' select * from deleted print '操作之后的表：已经成功插入一条记录，所有新表中有一条记录' select * from inserted go--测试：insert into grade values('aaaaa')if exists(select * from sysobjects where name='tr_grade_update') drop trigger tr_grade_updategocreate trigger tr_grade_updateon grade after update as print '操作之前的表：存储与这个修改操作相关的没有被修改之前的记录' select * from deleted print '操作之后的表：存储这个操作相关的被修改之后 记录' select * from inserted go--测试update grade set classname=classname+'aa' where ClassId&gt;15if exists(select * from sysobjects where name='tr_grade_delete') drop trigger tr_grade_deletegocreate trigger tr_grade_deleteon grade after delete as print '操作之前的表：存储与这个修改操作相关的没有被删除之前的记录' select * from deleted print '操作之后的表：存储这个操作相关的被删除之后 记录--没有记录' select * from inserted go--测试delete from grade where ClassId&gt;15 存储过程1234567891011存储过程就相当于c#中的方法参数，返回值，参数默认值，参数：值的方式调用在调用的时候有三个对应：类型对应，数量对应，顺序对应创建语法：create proc usp_用户自定义名称对应方法的形参 –(int age, out string name)as对应方法体:创建变量,逻辑语句,增加删除修改和查询..return返回值go调用语法：exec 存储过程名称 实参，实参，实参 … 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697--获取所有学员信息if exists(select * from sysobjects where name='usp_getAllStuInfo') drop proc usp_getAllStuInfo go create procedure usp_getAllStuInfoas select * from Studentgo --调用存储过程，获取的有学员信息execute usp_getAllStuInfo--exec sp_executesql 'select * from Student'--查询指定性别的学员信息goif exists(select * from sysobjects where name='usp_getAllStuInfoBySex') drop proc usp_getAllStuInfoBySex go create procedure usp_getAllStuInfoBySex @sex nchar(1) --性别 参数不需要declareas select * from Student where Sex=@sexgo--调用存储过程，获取指定性别的学员信息Exec usp_getAllStuInfoBySex '女'--创建存储过程获取指定班级和性别的学员信息goif exists(select * from sysobjects where name='usp_getAllStuInfoBySexandClassName') drop proc usp_getAllStuInfoBySexandClassName go create procedure usp_getAllStuInfoBySexandClassName @classname nvarchar(50), --班级名称 @sex nchar(1)='男'--性别 有默认的参数建议写在参数列表的最后as declare @classid int ---班级IDset @classid=(select classid from grade where classname=@classname) --通过参数班级名称获取对应的班级ID select * from Student where Sex=@sex and ClassId=@classidgo--执行存储过程获取指定班级和性别的学员信息--exec usp_getAllStuInfoBySexandClassName '八期班'exec usp_getAllStuInfoBySexandClassName default, '八期班' --有默认值的参数可以传递defaultexec usp_getAllStuInfoBySexandClassName @classname='八期班' --也可以通过参数=值的方式调用exec usp_getAllStuInfoBySexandClassName @classname='八期班' ,@sex='女'exec usp_getAllStuInfoBySexandClassName @classname='八期班',@sex='女'--创建存储过程,获取指定性别的学员人数及总人数goif exists(select * from sysobjects where name='usp_getCountBySexandClassName') drop proc usp_getCountBySexandClassName go create procedure usp_getCountBySexandClassName@cnt int=100 output, --output标记说明它是一个输出参数。output意味着你向服务器请求这个参数的值，那么在执行的时候，服务器发现这个参数标记了output，就会将这个参数的值返回输出@totalnum int =200output, --总人数@className nvarchar(50), --输入参数没有默认值，在调用的时候必须传入值@sex nchar(1)='男'--输入参数有默认值，用户可以选择是否传入值as declare @classid int ---班级ID set @classid=(select classid from grade where classname=@classname) --通过参数班级名称获取对应的班级ID select * from Student where Sex=@sex and ClassId=@classidset @cnt= (select COUNT(*) from Student where Sex=@sex and ClassId=@classid) --获取指定班级和性别的总人数set @totalnum=(select COUNT(*) from Student) ----获取总人数go--调用存储过程,获取指定性别的学员人数及总人数declare @num int,@tnum intexec usp_getCountBySexandClassName @cnt=@num output ,@totalnum=@tnum output , @className='八期班'print @numprint @tnumprint '做完了'---获取指定班级的人数if exists(select * from sysobjects where name='usp_getCount') drop proc usp_getCount go create procedure usp_getCount @className nvarchar(50)='八期班'asdeclare @classid int=(select classid from grade where classname=@className) declare @cnt intset @cnt =(select COUNT(*) from Student where ClassId=@classid) --return 只能返回int整数值--return '总人数是'+cast(@cnt as varchar(2))return @cnt go--调用存储过程，接收存储过程的返回值declare @count int--set @count=(exec usp_getCount)exec @count=usp_getCount '八期班'print @countif exists(select * from sysobjects where name='usp_getClassList') drop proc usp_getClassList go create procedure usp_getClassListas select classid,classname from gradego 分页存储过程1234567891011if exists(select * from sysobjects where name='usp_getPageData') drop proc usp_getPageData go create procedure usp_getPageData@totalPage int output,--总页数@pageIndex int =1 ,--当前页码，默认是第一页@pageCount int =5 --每一页显示的记录数asselect * from (select ROW_NUMBER() over(order by studentno) id,* from Student) temp where temp.id&gt;(@pageindex-1)*@pagecount and temp.id&lt;=(@pageindex*@pagecount)set @totalPage=CEILING((select COUNT(*) from Student)*1.0/@pageCount)go 索引1234567891011121314select * from sysindexes--create index IX_Student_studentName--on 表名(字段名)--clustered index:聚集索引 nonclustered index--非聚集索引if exists(select * from sysindexes where name='IX_Student_studentName') drop index student.IX_Student_studentNamego create clustered index IX_Student_studentNameon student(studentname)--如果是先创建主键再创建聚集索引就不可以，因为主键默认就是聚集索引--但是如果先创建聚集索引，那么还可以再创建主键，因为主键不一定需要是聚集的 临时表1234567891011121314151617181920212223242526--创建局部临时表create table #newGrade( classid int , classname nvarchar(50) )---局部临时表只有在当前创建它的会话中使用，离开这个会话临时表就失效.如果关闭创建它的会话，那么临时表就会消失insert into #newGrade select * from grade select * from #newGradeselect * into #newnewnew from gradeselect * into newGrade from #newgrade--创建全局临时表:只要不关闭当前会话，全局临时表都可以使用，但是关闭当前会话，全局临时表也会消失create table ##newGrade( classid int , classname nvarchar(50) )drop table ##newGradeselect * into ##newGrade from gradeselect * from ##newGrade--创建表变量declare @tb table(cid int,cname nvarchar(50))insert into @tb select * from gradeselect * from @tb]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL常用函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL笔记梳理]]></title>
    <url>%2F2017%2F05%2F20%2FSQL%E7%AC%94%E8%AE%B0%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"><![CDATA[什么是SQL语句sql语言：结构化的查询语言。（Structured Query Language），是关系数据库管理系统的标准语言。 它是一种解释语言：写一句执行一句，不需要整体编译执行。语法特点： 没有“ ”，字符串使用‘ ’包含 没有逻辑相等，赋值和逻辑相等都是= 类型不再是最严格的。任何数据都可以包含在‘ ’以内 没有bool值的概念，但是在视图中可以输入true/false 它也有关系运算符：&gt; &lt; &gt;= &lt;= = &lt;&gt; != ,它返回一个bool值 它也有逻辑运算符： ！(not) &amp;&amp;(and) ||(or) 它不区别大小写 使用sql语句创建数据库和表123456789101112131415161718语法：create database 数据库名称on primary –默认在主文件组上( name=’逻辑名称_data’ , –当你发现它不是一句完整的sql语句，而仅仅是一个处理结构中的某一句的时候，就需要添加 , size=初始大小,–数值不包含在‘’以内 filegrowth=文件增长 , maxsize=最大容量, filename=’物理路径’)log on( name=’逻辑名称_log’ , –当你发现它不是一句完整的sql语句，而仅仅是一个处理结构中的某一句的时候，就需要添加 , size=初始大小,–数值不包含在‘’以内 filegrowth=文件增长 , maxsize=最大容量, –一般来说日志文件不限制最大容量 filename=’物理路径’) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647--判断数据库文件是否已经存在 ：数据库的记录都存储在master库中的sysdatabases表中--自动切换当前数据库--使用代码开启外围应该配置器exec sp_configure &apos;show advanced options&apos; ,1RECONFIGUREexec sp_configure &apos;xp_cmdshell&apos;,1RECONFIGURE--自定义目录 xp_cmdshell可以创建出目录 &apos;mkdir f:\project&apos;：指定创建目录exec xp_cmdshell &apos;mkdir f:\project&apos;use master--exists 函数判断（）中的查询语句是否返回结果集，如果返回了结果集则得到true,否则得到falseif exists( select * from sysdatabases where name=&apos;School&apos;) drop database School --删除当前指定名称的数据库create database Schoolon primary( name=&apos;School_data&apos;,--逻辑名称.说明最多能够存储100mb数据，如果没有限制就可以将硬盘存储满 size=3mb,--初始大小 maxsize=100mb,--最大容量 filegrowth=10%,--文件增长一次增长10% filename=&apos;f:\project\School_data.mdf&apos; ),--创建文件组filegroup mygroup( name=&apos;School_data1&apos;,--逻辑名称.说明最多能够存储100mb数据，如果没有限制就可以将硬盘存储满 size=3mb,--初始大小 maxsize=100mb,--最大容量 filegrowth=10%,--文件增长一次增长10% filename=&apos;F:\qiyi\School_data1.ndf&apos; )log on( name=&apos;School_log&apos;,--逻辑名称 size=3mb,--初始大小 --maxsize=100mb,--最大容量 filegrowth=10%,--文件增长一次增长10% filename=&apos;f:\project\School_log.ldf&apos; ),( name=&apos;School_log1&apos;,--逻辑名称 size=3mb,--初始大小 --maxsize=100mb,--最大容量 filegrowth=10%,--文件增长一次增长10% filename=&apos;F:\qiyi\School_log1.ldf&apos; ) 创建数据表1234567语法：create table 表名( 字段名称 字段类型 字段特征(是否为null,默认值 标识列 主键 唯一键 外键 check约束), 字段名称 字段类型 字段特征(是否为null,默认值 标识列 主键 唯一键 外键 check约束))创建老师表Teacher :Id、Name、Gender、Age、Salary、Birthday 1234567891011121314151617181920use Schoolif exists(select * from sysobjects where name=&apos;Classes&apos;) drop table Classescreate table Classes( Classid int identity(1,1) primary key, ClassName nvarchar(50) not null )if exists(select * from sysobjects where name=&apos;teacher&apos;) drop table teachercreate table Teacher( Id int identity(1,1) primary key,--可以同时创建多个特征，用空格 分隔开。 identity是标识列，第一个参数是种子，第二个是增量 Name nvarchar(50) not null,-- not null标记它的值不能为null--不能不填写 ClassId int not null, Gender bit not null, Age int , Salary money, --如果不标记为 not null.那么就相当于标记了null Birthday datetime ) 数据完整性约束实体完整性：实体就是指一条记录。这种完整性就是为了保证每一条记录不是重复记录。是有意义的 主键：非空和唯一.一个表只有一个主键，但是一个主键可以是由多个字段组成的 组合键 标识列：系统自动生成，永远不重复 唯一键：唯一，但是可以为null,只能null一次 域完整性：域就是指字段，它是为了保证字段的值是准和有效，合理值 类型 是否null，默认值，check约束，关系 自定义完整性： check约束 ， 存储过程 触发器 引用完整性：一个表的某个字段的值是引用自另外一个表的某个字段的值。引用的表就是外键表，被引用的表就是主键表 建立引用的字段类型必须一致 建立引用的字段的意义一样 建立主外键关系的时候选择 外键表 去建立主外键关系 建立主外键关系的字段在主表中必须是主键或者唯一键 对于操作的影响 ： 在添加数据时，先添加主键表再添加外键表数据在删除的时候先外键表数据再删除主键表数据 1234主键约束（PK Primary key） 唯一键约束(UQ unique) 外键约束(FK foreign key) 默认值约束(DF default) check约束(CK check)语法：alter table 表名add constraint 前缀_约束名称 约束类型 约束说明（字段 关系表达式 值) 1234567891011121314151617181920212223242526use Schoolif exists(select * from sysobjects where name='PK_Classes_Classid')alter table classes drop constraint PK_Classes_Classidalter table classes add constraint PK_Classes_Classid primary key(classid)--为id添加主键alter table teacher add constraint PK_teacher_id primary key(id)--为name添加唯一键alter table teacheradd constraint UQ_Teacher_Name unique(Name)--同时创建salary的默认约束和age的check约束alter table teacheradd constraint DF_Teacher_Salary default(5000) for salary,constraint CK_Teacher_Age check(age&gt;0 and age&lt;=100)--为teacher表的classid字段创建主外键if exists(select * from sysobjects where name='FK_Teacher_Classes_Classid') alter table teacher drop constraint FK_Teacher_Classes_Classidalter table teacherwith nocheck --不检查现有数据add constraint FK_Teacher_Classes_Classid foreign key(classid) references classes(classid)--on delete set default 级联操作--不执行任何操作：该报错就报错，该删除就删除 --no action --默认选择--级联：删除主表记录，从表引用该值的记录也被删除 --cascade--设置null:删除主表记录，从表对应的字段值设置为null,前提是可以为null --set null--设置为default:删除主表记录，从表对应的字段值设置为default,前提是可以为default --set default 四中基本字符类型说明123456789101112131415161718--len(参数) --获取指定参数内容的字符个数select LEN('abcd') 【4】运行结果select LEN('中华人民共和国') 【7】--DataLength(参数)：获取指定内占据的字节数--空间大小select DataLength('abcd') 【4】select DataLength('中华人民共和国') 【14】--char类型：当空间分配后，不会因为存储的内容比分配的空间小就回收分配的空间。但是如果存储的内容超出了指定的空间大小，就会报错，当你存储的内容的长度变化区间不大的时候可以考虑使用charselect LEN(char) from CharTest 【2】select DataLength(char) from CharTest 【10】--varchar var--变化的：当你存储的内容小于分配的空间的时候，多余的空间会自动收缩。但是如果存储的内容超出了指定的空间大小，就会报错 当存储的内容波动区间比较大时候使用varcharselect LEN(varchar) from CharTest 【2】select DataLength(varchar) from CharTest 【2】--nchar-- n代表它是一个unicode字符。规定不管什么样的字符都占据两个字节。 char:空间是固定的select LEN(nchar) from CharTest 【10】select DataLength(nchar) from CharTest 【20】--nvarchar n var char select LEN(nvarchar) from CharTest 【2】select DataLength(nvarchar) from CharTest 【4】 SQL基本语句123456数据插入调用方法 一 一对应原则：类型对应，数量对应，顺序对应语法： 形参 实参insert into 表名([字段列表]) values(值列表) –数据必须要符合数据完整性插入操作是单个表的操作插入操作insert一次只能插入一条记录 123456789101112131415161718192021222324252627use School--插入teacher所有字段的数据.如果在表后没有指定需要插入的字段名称，那么就默认为所有字段添加值--但是一定需要注意的是：标识列永远不能自定义值--不能人为插入值--仅当使用了列列表并且 IDENTITY_INSERT 为 ON 时，才能为表'Teacher'中的标识列指定显式值。insert into Teacher values('张三',5,1,30,4000,'1984-9-11')insert into Teacher(Name,ClassId,Gender,Age,Salary,Birthday) values('张三',5,1,30,4000,'1984-9-11')--不为可以为null的字段插入值 :可以null的字段可以不赋值 --列名或所提供值的数目与表定义不匹配insert into Teacher(Name,ClassId,Gender,Age,Salary) values('李四',5,1,30,4000)--非空字段一定需要赋值 ：不能将值 NULL 插入列 'Gender'，表 'School.dbo.Teacher'；列不允许有 Null 值。INSERT 失败insert into Teacher(Name,ClassId,Age,Salary) values('李四',5,30,4000)--为有默认值的字段插入值：--1.不写这一列让系统自动赋值insert into Teacher(Name,ClassId,Gender,Age) values('王五',5,1,30)--指定 null或者defaultinsert into Teacher(Name,ClassId,Gender,Age,Salary,Birthday) values('赵六',5,1,30,default,null)--数据必须完全符合表的完整性约束insert into Teacher(Name,ClassId,Gender,Age,Salary,Birthday) values('赵六1',5,1,300,default,null)--任意类型的数据都可以包含在''以内, 不包括关键字insert into Teacher(Name,ClassId,Gender,Age,Salary,Birthday) values('马鹏飞','5','0','15',default,null)--但是字符串值如果没有包含在''以内.会报错 列名 '兰鹏' 无效。insert into Teacher(Name,ClassId,Gender,Age,Salary,Birthday) values('兰鹏','5','0','15',default,null)--但是数值组成的字符串可以不使用''包含insert into Teacher(Name,ClassId,Gender,Age,Salary,Birthday) values(123,'5','0','15',default,null)--日期值必须包含在’‘以内，否则就是默认值insert into Teacher(Name,ClassId,Gender,Age,Salary,Birthday) values('邹元标2','5','0','15',default,'1991-9-11') 123数据删除语法:delete [from] 表名 where 条件 12345678910111213delete from Teacher where Age&lt;20--特点:--1.删除是一条一条进行删除的--2.每一条记录的删除都需要将操作写入到日志文件中--3.标识列不会从种子值重新计算,以从上次最后一条标识列值往下计算--4.这种删除可以触发delete触发器--truncate table 表名 --没有条件，它是一次性删除所有数据--特点：--1.一次性删除所有数据，没有条件，那么日志文件只以最小化的数据写入--2.它可以使用标识列从种子值重新计算--3.它不能触发delete触发器truncate table teacher 123数据更新(数据修改)：一定需要考虑是否有条件语法:update 表名 set 字段=值，字段=值 。。where 条件 1234567update Teacher set Gender='true'--修改时添加条件update Teacher set Gender=0 where Id=20--多字段修改update Teacher set ClassId=4,Age+=5,Salary=5000 where Id=22--修改班级id=4，同时年龄》20岁的人员工资+500update Teacher set Salary=Salary+500 where ClassId=4 and Age&gt;20 123数据检索–查询语法： *代表所有字段select */字段名称列表 from 表列表 12345select StudentNo,StudentName,Sex,[Address] from Student--可以为标题设置 别名，别名可以是中文别名select StudentNo as 学号,StudentName 姓名,性别=Sex,[Address] from Student--添加常量列select StudentNo as 学号,StudentName 姓名,性别=Sex,[Address] ,国籍='中华人民共和国' from Student select的作用12345678910111213141516171819202122--select的作用--1.查询--2.输出select 1+1--+是运算符,系统会自动为你做类型转换select 1+'1'select '1'+1--如果+两边都是字符串,那么它就是一字符串连接符select '1'+'1'select 'a'+1--可以输出多列值select 1,2,34,3,545,67,567,6,7--Top、Distinctselect * from Student--top可以获取指定的记录数,值可以大于总记录数.但是不能是负值select top 100 * from Student--百分比是取ceiling()select top 10 percent * from Student--重复记录与原始的数据表数据无关,只与你查询的结果集有关系 distinct可以去除结果集中的重复记录--结果集中每一列的值都一样select distinct LoginPwd,Sex,Email from Studentselect distinct Sex from Student 聚合函数12345678910111213141516171819202122232425262728293031323334353637--聚合函数：--1.对null过滤--2.都需要有一个参数--3.都是返回一个数值--sum()：求和:只能对数值而言,对字符串和日期无效--avg()：求平均值--count()：计数：得到满足条件的记录数--max()：求最大值:可以对任意类型的数据进行聚合，如果是字符串就比较拼音字母进行排序--min()：求最小值--获取学员总人数select COUNT(*) from Student--查询最大年龄值select MIN(BornDate) from Studentselect max(BornDate) from Student--查询总分select SUM(StudentResult) from Result where StudentNo=2--平均分select avg(StudentResult) from Result where SubjectId=1--注意细节：select SUM(StudentName) from Studentselect SUM(BornDate) from Studentselect min(StudentName) from Studentselect max(StudentName) from Student--查询学号，姓名，性别，年龄，电话，地址 ---查询女生select StudentNo,StudentName,Sex,BornDate,Address from Student where Sex='女' and BornDate &gt;'1990-1-1' and Address='广州'--指定区间范围select StudentNo,StudentName,Sex,BornDate,Address from Student where BornDate &gt;='1990-1-1' and BornDate&lt;='1993-1-1'--between...and &gt;= &lt;=select StudentNo,StudentName,Sex,BornDate,Address from Student where BornDate between '1990-1-1' and '1993-1-1'--查询班级id 1 3 5 7的学员信息select * from Student where ClassId=1 or ClassId=3 or ClassId=5 or ClassId=7--指定具体的取值范围--可以是任意类型的范围.值的类型需要一致--可以相互转换select * from Student where ClassId in(1,3,'5',7)select * from Student where ClassId not in(1,3,'5',7) 模糊查询12345678910111213141516171819202122232425--带条件的查询-模糊查询-- 只针对字符串而言--查询 姓 林 的女生信息--=是一种精确查询，需要完全匹配select * from Student where Sex='女' and StudentName='林'--通配符--元字符--%：任意个任意字段 window:* 正则表达式 ：.*--_:任意的单个字符--[]:代表一个指定的范围，范围可以是连续也可以是间断的。与正则表达式完全一样[0-9a-zA-Z].可以从这个范围中取一个字符--[^]:取反值select * from Student where Sex='女' and StudentName='林%'--通配符必须在模糊查询关键的中才可以做为通配符使用，否则就是普通字符--like 像 。。。。一样select * from Student where Sex='女' and StudentName like '林%'select * from Student where Sex='女' and StudentName like '林_'--[]的使用 学号在11~15之间的学员信息select * from Student where StudentNo like '[13579]'---处理null值--null:不是地址没有分配,而是不知道你需要存储什么值 所以null是指 不知道。但是=只能匹配具体的值，而null根本就不是一个值select COUNT(email) from Student where Email !=null (错误)select COUNT(email) from Student where Email is nullselect count(email) from Student where Email is not null--将null值替换为指定的字符串值select StudentName,ISNULL(Email,'没有填写电子邮箱') from Student where ClassId=2 分组统计123456789101112131415--当你看到 每一个，，各自，不同，，分别 需要考虑分组--查询每一个班级的男生人数--与聚合函数一起出现在查询中的列，要么也被聚合，要么被分组select classid,Sex,COUNT(*) from Student where Sex='男' group by ClassId,sex--查询每一个班级的总人数,显示人数&gt;=2的信息--1.聚合不应出现在 WHERE 子句中--语法错误select ClassId ,COUNT(*) as num from Student where Email is not null GROUP by ClassId having COUNT(*)&gt;=2 order by num desc--完整的sql查询家庭 --select 字段列表 from 表列表 where 数据源做筛选 group by 分组字段列表 having 分组结果集做筛选 Order by 对结果集做记录重排select ClassId ,COUNT(*) as num from Student where Email is not null GROUP by ClassId order by ClassId desc--关于top的执行顺序 排序之后再取top值select top 1 ClassId ,COUNT(*) as num from Student GROUP by ClassId order by num desc]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery常用函数总结]]></title>
    <url>%2F2017%2F05%2F13%2FjQuery%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[jQuery常用函数总结这篇文章主要介绍了jQuery自带的一些常用方法总结,包括$.trim 、$.contains、$.each、$.map、$.inArray、$.extend等,需要的朋友可以参考下 常用工具方法（1）$.trim $.trim方法用于移除字符串头部和尾部多余的空格。复制代码 代码如下: 1$.trim(' Hello ') // Hello （2）$.contains $.contains方法返回一个布尔值，表示某个DOM元素（第二个参数）是否为另一个DOM元素（第一个参数）的下级元素。复制代码 代码如下: 1234$.contains(document.documentElement, document.body); // true$.contains(document.body, document.documentElement); // false （3）$.each， $.map $.each方法用于遍历数组和对象，然后返回原始对象。它接受两个参数，分别是数据集合和回调函数。复制代码 代码如下: 1234567891011121314$.each([ 52, 97 ], function( index, value ) &#123; console.log( index + ": " + value );&#125;);// 0: 52 // 1: 97 var obj = &#123; p1: "hello", p2: "world"&#125;;$.each( obj, function( key, value ) &#123; console.log( key + ": " + value );&#125;);// p1: hello// p2: world 需要注意的，jQuery对象实例也有一个each方法（$.fn.each），两者的作用差不多。$.map方法也是用来遍历数组和对象，但是会返回一个新对象。复制代码 代码如下: 123456var a = ["a", "b", "c", "d", "e"];a = $.map(a, function (n, i)&#123; return (n.toUpperCase() + i);&#125;);console.log(a);// ["A0", "B1", "C2", "D3", "E4"] （4）$.inArray $.inArray方法返回一个值在数组中的位置（从0开始）。如果该值不在数组中，则返回-1。复制代码 代码如下: 12var a = [1,2,3,4];$.inArray(4,a) // 3 （5）$.extend $.extend方法用于将多个对象合并进第一个对象。复制代码 代码如下: 1234var o1 = &#123;p1:'a',p2:'b'&#125;;var o2 = &#123;p1:'c'&#125;;$.extend(o1,o2);o1.p1 // "c" $.extend的另一种用法是生成一个新对象，用来继承原有对象。这时，它的第一个参数应该是一个空对象。复制代码 代码如下: 12345var o1 = &#123;p1:'a',p2:'b'&#125;;var o2 = &#123;p1:'c'&#125;;var o = $.extend(&#123;&#125;,o1,o2);o// Object &#123;p1: "c", p2: "b"&#125; 默认情况下，extend方法生成的对象是“浅拷贝”，也就是说，如果某个属性是对象或数组，那么只会生成指向这个对象或数组的指针，而不会复制值。如果想要“深拷贝”，可以在extend方法的第一个参数传入布尔值true。复制代码 代码如下: 123456var o1 = &#123;p1:['a','b']&#125;;var o2 = $.extend(&#123;&#125;,o1);var o3 = $.extend(true,&#123;&#125;,o1); // 深拷贝 复制值o1.p1[0]='c'; // 赋值o2.p1 // ["c", "b"] 浅拷贝 指针 没有复制值o3.p1 // ["a", "b"] 深拷贝 复制的值 上面代码中，o2是浅拷贝，o3是深拷贝。结果，改变原始数组的属性，o2会跟着一起变，而o3不会。 （6）$.proxy $.proxy方法类似于ECMAScript 5的bind方法，可以绑定函数的上下文（也就是this对象）和参数，返回一个新函数。jQuery.proxy()的主要用处是为回调函数绑定上下文对象。复制代码 代码如下: 123456789var o = &#123; type: "object", test: function(event) &#123; console.log(this.type); &#125;&#125;;$("#button") .on("click", o.test) // 无输出 .on("click", $.proxy(o.test, o)) // object 上面的代码中，第一个回调函数没有绑定上下文，所以结果为空，没有任何输出；第二个回调函数将上下文绑定为对象o，结果就为object。这个例子的另一种等价的写法是：复制代码 代码如下: 1$("#button").on( "click", $.proxy(o, test)) 上面代码的$.proxy(o, test)的意思是，将o的方法test与o绑定。这个例子表明，proxy方法的写法主要有两种。复制代码 代码如下: 123jQuery.proxy(function, context)// orjQuery.proxy(context, name) 第一种写法是为函数（function）指定上下文对象（context），第二种写法是指定上下文对象（context）和它的某个方法名（name）。再看一个例子。正常情况下，下面代码中的this对象指向发生click事件的DOM对象。复制代码 代码如下: 123$('#myElement').click(function() &#123; $(this).addClass('aNewClass');&#125;); 如果我们想让回调函数延迟运行，使用setTimeout方法，代码就会出错，因为setTimeout使得回调函数在全局环境运行，this将指向全局对象。复制代码 代码如下: 12345$('#myElement').click(function() &#123; setTimeout(function() &#123; $(this).addClass('aNewClass'); &#125;, 1000);&#125;); 上面代码中的this，将指向全局对象window，导致出错。这时，就可以用proxy方法，将this对象绑定到myElement对象。复制代码 代码如下: 12345$('#myElement').click(function() &#123; setTimeout($.proxy(function() &#123; $(this).addClass('aNewClass'); &#125;, this), 1000);&#125;); （7）$.data，$.removeData$.data方法可以用来在DOM节点上储存数据。复制代码 代码如下: 123456// 存入数据$.data(document.body, "foo", 52 );// 读取数据$.data(document.body, "foo");// 读取所有数据$.data(document.body); 上面代码在网页元素body上储存了一个键值对，键名为“foo”，键值为52。 $.removeData方法用于移除.data方法所储存的数据。复制代码 代码如下: 12$.data(div, "test1", "VALUE-1");$.removeData(div, "test1"); （8）$.parseHTML，$.parseJSON，.parseXML $.parseHTML方法用于将字符串解析为DOM对象。$.parseJSON方法用于将JSON字符串解析为JavaScript对象，作用与原生的JSON.parse()类似。但是，jQuery没有提供类似JSON.stringify()的方法，即不提供将JavaScript对象转为JSON对象的方法。$.parseXML方法用于将字符串解析为XML对象。复制代码 代码如下: 1234var html = $.parseHTML("hello, &lt;b&gt;my name is&lt;/b&gt; jQuery.");var obj = $.parseJSON('&#123;"name": "John"&#125;');var xml = "&lt;rss version='2.0'&gt;&lt;channel&gt;&lt;title&gt;RSS Title&lt;/title&gt;&lt;/channel&gt;&lt;/rss&gt;";var xmlDoc = $.parseXML(xml); （9）$.makeArray$.makeArray方法将一个类似数组的对象，转化为真正的数组。复制代码 代码如下: 1var a = $.makeArray(document.getElementsByTagName("div")); （10）$.merge $.merge方法用于将一个数组（第二个参数）合并到另一个数组（第一个参数）之中。复制代码 代码如下: 12345var a1 = [0,1,2];var a2 = [2,3,4];$.merge(a1, a2);a1// [0, 1, 2, 2, 3, 4] （11）$.now $.now方法返回当前时间距离1970年1月1日00:00:00 UTC对应的毫秒数，等同于(new Date).getTime()。复制代码 代码如下: 12$.now()// 1388212221489 （12）判断数据类型的方法jQuery提供一系列工具方法，用来判断数据类型，以弥补JavaScript原生的typeof运算符的不足。以下方法对参数进行判断，返回一个布尔值。jQuery.isArray()：是否为数组。jQuery.isEmptyObject()：是否为空对象（不含可枚举的属性）。jQuery.isFunction()：是否为函数。jQuery.isNumeric()：是否为数组。jQuery.isPlainObject()：是否为使用“{}”或“new Object”生成的对象，而不是浏览器原生提供的对象。jQuery.isWindow()：是否为window对象。jQuery.isXMLDoc()：判断一个DOM节点是否处于XML文档之中。下面是一些例子。复制代码 代码如下: 1234$.isEmptyObject(&#123;&#125;) // true$.isPlainObject(document.location) // false$.isWindow(window) // true$.isXMLDoc(document.body) // false 除了上面这些方法以外，还有一个$.type方法，可以返回一个变量的数据类型。它的实质是用Object.prototype.toString方法读取对象内部的[[Class]]属性（参见《标准库》的Object对象一节）。复制代码 代码如下: 1$.type(/test/) // "regexp" （13）Ajax操作 $.ajaxjQuery对象上面还定义了Ajax方法（$.ajax()），用来处理Ajax操作。调用该方法后，浏览器就会向服务器发出一个HTTP请求。$.ajax()的用法有多种，最常见的是提供一个对象参数。复制代码 代码如下: 1234567891011121314151617181920$.ajax(&#123; async: true, url: '/url/to/json', type: 'GET', data : &#123; id : 123 &#125;, dataType: 'json', timeout: 30000, success: successCallback, error: errorCallback, complete: completeCallback&#125;)function successCallback(json) &#123; $('&lt;h1/&gt;').text(json.title).appendTo('body');&#125;function errorCallback(xhr, status)&#123; console.log('出问题了！');&#125;function completeCallback(xhr, status)&#123; console.log('Ajax请求已结束。');&#125; 上面代码的对象参数有多个属性，含义如下：async：该项默认为true，如果设为false，则表示发出的是同步请求。cache: 该项默认为true，如果设为false，则浏览器不缓存返回服务器返回的数据。注意，浏览器本身就不会缓存POST请求返回的数据，所以即使设为false，也只对HEAD和GET请求有效。url：服务器端网址。这是唯一必需的一个属性，其他属性都可以省略。type：向服务器发送信息所使用的HTTP动词，默认为GET，其他动词有POST、PUT、DELETE。dataType：向服务器请求的数据类型，可以设为text、html、script、json、jsonp和xml。data：向服务器发送的数据，如果使用GET方法，此项将转为查询字符串，附在网址的最后。success：请求成功时的回调函数，函数参数为服务器传回的数据、状态信息、发出请求的原始对象。timeout: 等待的最长毫秒数。如果过了这个时间，请求还没有返回，则自动将请求状态改为失败。error：请求失败时的回调函数，函数参数为发出请求的原始对象以及返回的状态信息。complete：不管请求成功或失败，都会执行的回调函数，函数参数为发出请求的原始对象以及返回的状态信息。这些参数之中，url可以独立出来，作为ajax方法的第一个参数。也就是说，上面代码还可以写成下面这样。复制代码 代码如下: 123456$.ajax('/url/to/json',&#123; type: 'GET', dataType: 'json', success: successCallback, error: errorCallback&#125;) 简便写法ajax方法还有一些简便写法。$.get()：发出GET请求。$.getScript()：读取一个JavaScript脚本文件并执行。$.getJSON()：发出GET请求，读取一个JSON文件。$.post()：发出POST请求。$.fn.load()：读取一个html文件，并将其放入当前元素之中。一般来说，这些简便方法依次接受三个参数：url、数据、成功时的回调函数。 （1）$.get()，$.post() 这两个方法分别对应HTTP的GET方法和POST方法。复制代码 代码如下: 123456$.get('/data/people.html', function(html)&#123; $('#target').html(html);&#125;);$.post('/data/save', &#123;name: 'Rebecca'&#125;, function (resp)&#123; console.log(JSON.parse(resp));&#125;); get方法接受两个参数，分别为服务器端网址和请求成功后的回调函数。post方法在这两个参数中间，还有一个参数，表示发给服务器的数据。上面的post方法对应的ajax写法如下。复制代码 代码如下: 123456789$.ajax(&#123; type: 'POST', url: '/data/save', data: &#123;name: 'Rebecca'&#125;, dataType: 'json', success: function (resp)&#123; console.log(JSON.parse(resp)); &#125;&#125;); （2）$.getJSON() ajax方法的另一个简便写法是getJSON方法。当服务器端返回JSON格式的数据，可以用这个方法代替$.ajax方法。复制代码 代码如下: 123$.getJSON('url/to/json', &#123;'a': 1&#125;, function(data)&#123; console.log(data);&#125;); 上面的代码等同于下面的写法。复制代码 代码如下: 12345678$.ajax(&#123; dataType: "json", url: '/url/to/data', data: &#123;'a': 1&#125;, success: function(data)&#123; console.log(data); &#125;&#125;); （3）$.getScript()$.getScript方法用于从服务器端加载一个脚本文件。复制代码 代码如下: 123$.getScript('/static/js/myScript.js', function() &#123; functionFromMyScript();&#125;); 上面代码先从服务器加载myScript.js脚本，然后在回调函数中执行该脚本提供的函数。getScript的回调函数接受三个参数，分别是脚本文件的内容，HTTP响应的状态信息和ajax对象实例。复制代码 代码如下: 12345$.getScript( "ajax/test.js", function (data, textStatus, jqxhr)&#123; console.log( data ); // test.js的内容 console.log( textStatus ); // Success console.log( jqxhr.status ); // 200&#125;); getScript是ajax方法的简便写法，因此返回的是一个deferred对象，可以使用deferred接口。复制代码 代码如下: 1234567jQuery.getScript("/path/to/myscript.js") .done(function() &#123; // ... &#125;) .fail(function() &#123; // ...&#125;); （4）$.fn.load() $.fn.load不是jQuery的工具方法，而是定义在jQuery对象实例上的方法，用于获取服务器端的HTML文件，将其放入当前元素。由于该方法也属于ajax操作，所以放在这里一起讲。复制代码 代码如下: 1$('#newContent').load('/foo.html'); $.fn.load方法还可以指定一个选择器，将远程文件中匹配选择器的部分，放入当前元素，并指定操作完成时的回调函数。复制代码 代码如下: 1234$('#newContent').load('/foo.html #myDiv h1:first', function(html) &#123; console.log('内容更新！');&#125;); 上面代码只加载foo.html中匹配“#myDiv h1:first”的部分，加载完成后会运行指定的回调函数。Ajax事件jQuery提供以下一些方法，用于指定特定的AJAX事件的回调函数。.ajaxComplete()：ajax请求完成。.ajaxError()：ajax请求出错。.ajaxSend()：ajax请求发出之前。.ajaxStart()：第一个ajax请求开始发出，即没有还未完成ajax请求。.ajaxStop()：所有ajax请求完成之后。.ajaxSuccess()：ajax请求成功之后。下面是示例。复制代码 代码如下: 123$('#loading_indicator').ajaxStart(function ()&#123;$(this).show();&#125;).ajaxStop(function ()&#123;$(this).hide();&#125;); 返回值ajax方法返回的是一个deferred对象，可以用then方法为该对象指定回调函数（详细解释参见《deferred对象》一节）。复制代码 代码如下: 123456$.ajax(&#123; url: '/data/people.json', dataType: 'json'&#125;).then(function (resp)&#123; console.log(resp.people);&#125;) JSONP由于浏览器存在“同域限制”，ajax方法只能向当前网页所在的域名发出HTTP请求。但是，通过在当前网页中插入script元素（\），可以向不同的域名发出GET请求，这种变通方法叫做JSONP（JSON with Padding）。ajax方法可以发出JSONP请求，方法是在对象参数中指定dataType为JSONP。复制代码 代码如下: 12345678$.ajax(&#123; url: '/data/search.jsonp', data: &#123;q: 'a'&#125;, dataType: 'jsonp', success: function(resp) &#123; $('#target').html('Results: ' + resp.results.length); &#125;&#125;); JSONP的通常做法是，在所要请求的URL后面加在回调函数的名称。ajax方法规定，如果所请求的网址以类似“callback=?”的形式结尾，则自动采用JSONP形式。所以，上面的代码还可以写成下面这样。复制代码 代码如下: 12345$.getJSON('/data/search.jsonp?q=a&amp;callback=?', function(resp) &#123; $('#target').html('Results: ' + resp.results.length); &#125;);]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>函数</tag>
        <tag>选择器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery常用语法]]></title>
    <url>%2F2017%2F05%2F13%2FjQuery%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[基础语法：$(selector).action() 美元符号定义 jQuery $ 选择符（selector）“查询”和“查找” HTML 元素 jQuery 的 action() 执行对元素的操作 示例： 1234$(this).hide() - 隐藏当前元素$("p").hide() - 隐藏所有段落$("p.test").hide() - 隐藏所有 class="test" 的段落$("#test").hide() - 隐藏所有 id="test" 的元素 选择器-by prop： jQuery 使用 XPath 表达式来选择带有给定属性的元素。 示例： 1234$("[href]") 选取所有带有 href 属性的元素。 $("[href='#']") 选取所有带有 href 值等于 "#" 的元素。$("[href!='#']") 选取所有带有 href 值不等于 "#" 的元素。$("[href$='.jpg']") 选取所有 href 值以 ".jpg" 结尾的元素。 选择器-css： jQuery CSS 选择器可用于改变 HTML 元素的 CSS 属性。 示例： 1$("p").css("background-color","red"); 事件： 基于事件，我们可以做许多事情。 示例： 123$(document).ready(function)$(selector).click(function)$(selector).focus(function) jQuery与html： jQuery 提供一系列与 DOM 相关的方法，这使访问和操作元素和属性变得很容易。 三个简单实用的用于 DOM 操作的 jQuery 方法，get – set： 12345$(selector).text() -- text("")$(selector).html() -- html("")$(selector).val() -- html("") $(selector).attr("") -- attr("", "")/* 等同于，获name来找，$("input[name='whichName']").val()，对它重新赋值$("input[name='whichName']").val(oldTopic); */ jQuery-GET： $.get(“yourUrl”, function(data, status){}); 其中，data是controller里这样写回的response.write(“”) /modelMap带回 示例： 12345$("button").click(function()&#123; $.get("demo_test.asp",function(data,status)&#123; alert("Data: " + data + "\nStatus: " + status); &#125;);&#125;); jQuery-POST： $.post(URL,data,callback); 其中，data是controller里这样写回的response.write(“”) /modelMap带回 示例： 12345678910$("button").click(function()&#123; $.post("demo_test_post.asp", &#123; name:"Donald Duck", city:"Duckburg" &#125;, function(data,status)&#123; alert("Data: " + data + "\nStatus: " + status); &#125;);&#125;); jQuery-遍历：1$(selector).each(function(index,element)) 示例： 12345$("table").find("tr").each(function()&#123; $(this).find("td").each(function()&#123; alert($(this).text()); &#125;);&#125;); 常用方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;script&gt; /** elementName标识的页面元素的值，是否为空. */ function isNULL(elementname)&#123; if($("input[name=" + elementname + "]").val() == "")&#123; return true; &#125; return false; &#125; /** elementName标识的页面元素的值，是否超时limitedLength. */ function exceedLimitedLength(elementname, limitedLength)&#123; if($("input[name=" + elementname + "]").val().length &gt; limitedLength)&#123; return true; &#125; return false; &#125; /** elementName标识的页面元素的值，是否为数字. */ function isNum(elementname)&#123; return isNaN($("input[name=" + elementname + "]").val()); &#125; /** 光标显示在elementname标识的元素内. */ function focus(elementname)&#123; $("input[name=" + elementname + "]").focus(); &#125; /** elementname标识的页面元素是否为数字，如果不是，那么光标标在那里，并且提示用户. */ function isNumber(elementname)&#123; if(isNum(elementname))&#123; focus(elementname); alert(elementname + "必须为数字"); return false; &#125; return true; &#125; /** elementname标识的页面元素的值，是否包含了中文. */ function containsChinese(elementname)&#123; var str = $("input[name=" + elementname + "]").val(); if(escape(str).indexOf("%u")&gt;=0)&#123; return true; &#125; return false; &#125; /** elementname标识的页面元素的值，是否只包括字母、数字、中划线和下划线. */ function containsOnlyLettersNumberAndTwoDash(elementname)&#123; var str = $("input[name=" + elementname + "]").val(); var patten = new RegExp(/^[a-zA-Z0-9\_\-]+$/); return patten.test(str); &#125; /** elementname标识的页面元素的值，是否满足这些约束：不为空、 长度&lt;limitedLength、不包含中文、只包含字母数字中划下划. */ function satisfyAllConstraints(elementname, limitedLength)&#123; if(isNULL(elementname))&#123; focus(elementname); alert(elementname + "不可为空"); return false; &#125; if(exceedLimitedLength(elementname, limitedLength))&#123; focus(elementname); alert(elementname + "超过长度限制" + limitedLength); return false; &#125; if(containsChinese(elementname))&#123; focus(elementname); alert(elementname + "不支持中文"); return false; &#125; // 注意！ if(!containsOnlyLettersNumberAndTwoDash(elementname))&#123; focus(elementname); alert(elementname + "仅支持字母、数字、中划线-、下滑线_"); return false; &#125; return true; &#125;&lt;/script&gt; 判断字符串开头、结尾，正则表达式：12345678var str = "xxx.xml.bak";if (str.match("^xxx")) &#123; alert("xxx starts");&#125;if (str.match("xml$")) &#123; alert("xml ends");&#125;]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>事件</tag>
        <tag>jQuery</tag>
        <tag>jQuery常用语法</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[苹果味喜欢的音乐]]></title>
    <url>%2F2017%2F05%2F13%2F%E8%8B%B9%E6%9E%9C%E5%91%B3%E5%96%9C%E6%AC%A2%E7%9A%84%E9%9F%B3%E4%B9%90%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript数组及JSON操作]]></title>
    <url>%2F2017%2F05%2F13%2FJavaScript%E6%95%B0%E7%BB%84%E5%8F%8AJSON%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[JavaScript数组及JSON操作javascript删除数组的3种方法1.用shift()方法shift：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined 123var myArray=[2,34,56,32,12,9];var a=myArray.shift(); // 得到2console.log(myArray); // [34,56,,32,12,9] 2.用pop()方法pop：删除原数组最后一项，并返回删除元素的值；如果数组为空则返回undefined 123var myArray=[2,34,56,32,12,9];var a=myArray.pop(); // 得到9console.log(myArray); // [2,34,56,,32,12] 前面的方法只能操作数组开头和结尾，无法操作中间项，如果要操作中间的项，使用splice方法 3.用splice方法这个方法很强大，可以对数组任意项进行增加，删除，替换操作 删除操作123var myArray=[2,34,56,32,12,9];var a=myArray.splice(2,1); // 得到56console.log(myArray); // [2,34,32,12,9] 上面例子中，把myArray中的索引为2开始的1项替换成空的，因为后面没有内容，结果可以看到，把56这项删除了 修改操作：123var myArray=[2,34,56,32,12,9];var a=myArray.splice(2,1,8,9); // 得到56console.log(myArray); // [2,34,8,9,32,12,9] 第一个参数是准备操作的数组索引，第二个参数是操作位置后面的数组项数，第三个以后的就是，被替换后的内容 添加操作123var myArray=[2,34,56,32,12,9];var a=myArray.splice(2,0,8,9); // 得到空[]console.log(myArray); // [2,34,8,9,56,32,12,9] 从数组索引为2后的0项换成8,9，也就等于添加了两项 javascript对JSON增删改查概要JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式,同时，JSON是 JavaScript 原生格式，这意味着在 JavaScript 中处理 JSON数据不须要任何特殊的 API 或工具包。 在JSON中，有两种结构：对象和数组 1、对象以“{”开始，“}”结束，“key/value”之间运用 “,”分隔。1packJson=&#123;"name":"Liza","password":"123"&#125; 2、数组以“[”开始，“]”结束。值之间运用 “,”分隔。1packJson=[&#123;"name":"Liza","password":"123"&#125;,&#123;"name":"Mike","password":"456"&#125;]; JSON对象和JSON字符串的转换在数据传输过程中，JSON是以字符串的形式传递的，而JS操作的是JSON对象，所以，JSON对象和JSON字符串之间的相互转换是关键。如下： JSON字符串： 1var jsonStr='&#123;"name":"Liza","password":"123"&#125;'; JSON对象： 1var packJson=[&#123;"name":"Liza","password":"123"&#125;,&#123;"name":"Mike","password":"456"&#125;]; 1、将String转化为JSON 1var jsonObject=jQuery.parseJSON(jsonStr); 2、将JSON转化为String 1var jsonStr=JSON.stringify(jsonObject) 增删改查Demo 1234567891011121314151617181920212223242526272829303132var p =&#123; "name": "kakaxi", "age":45, "sex":"male"&#125;;function JsonOperation()&#123; // 读取 for(var i in p)&#123; console.log(i+'=='+p[i]); // name==kakaxi... &#125; // 查找 console.log(p['age']); // 45 console.log(p.age); // 45 // 增加 p['卡卡西']='copy忍者，木叶上忍'; p['鼬']='天才忍者'; console.log(p['卡卡西']); // copy忍者，木叶上忍 // 修改 p.age=88; console.log(p['age']); // 88 // 删除 delete p['name']; delete p.age; for(var i in p)&#123; console.log(i+'=='+p[i]); // 已删除 name、age项 &#125;&#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript常用函数]]></title>
    <url>%2F2017%2F05%2F08%2FJavaScript%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[常规函数 alert函数：显示一个警告对话框，包括一个OK按钮。 confirm函数：显示一个确认对话框，包括OK、Cancel按钮。 escape函数：将字符转换成Unicode码。 eval函数：计算表达式的结果。 isNaN函数：测试是(true)否(false)不是一个数字。 parseFloat函数：将字符串转换成符点数字形式。 parseInt函数：将符串转换成整数数字形式(可指定几进制)。 prompt函数：显示一个输入对话框，提示等待用户输入。例如： 123alert("输入错误"); prompt("请输入您的姓名","姓名");confirm("确定否！"); unescape函数：解码由escape函数编码的字符。 toFixed 函数:这个函数牛逼 就是转化小数点几位的 checkprice.toFixed(2)； 将checkprice转化为有小数点后两位的值 数组函数javascript数组函数包括以下4个函数：(1) join函数：转换并连接数组中的所有元素为一个字符串。例: 123456function JoinDemo()&#123; var a, b; a = new Array(0,1,2,3,4); b = a.join("-");//分隔符 return(b);//返回的b=="0-1-2-3-4" &#125; (2) length函数：返回数组的长度。例： 123456function LengthDemo()&#123; var a, l; a = new Array(0,1,2,3,4); l = a.length; return(l);//l==5 &#125; (3) reverse函数：将数组元素顺序颠倒。例： 123456function ReverseDemo()&#123; var a, l; a = new Array(0,1,2,3,4); l = a.reverse(); return(l); &#125; (4) sort函数：将数组元素重新排序。例： 123456function SortDemo()&#123; var a, l; a = new Array("X" ,"y" ,"d", "Z", "v","m","r"); l = a.sort(); return(l); &#125; (5) push函数:将新元素添加到一个数组中，并返回数组的新长度值。例: 12345&lt;script type="text/javascript"&gt; var my_array = new Array('1','2','3','4'); my_array.push('5','6','7','8'); alert(my_array.length); //将返回8 数组中添加了4个元素&lt;/script&gt; (6) unshift函数：将指定的元素插入数组开始位置并返回该数组。例： 12345&lt;script type="text/javascript"&gt; var my_array = new Array('1','2','3','4'); my_array.unshift('0'); //在数组前面追加元素 alert(my_array.length); //返回5&lt;/script&gt; (7) pop函数:移除数组中的最后一个元素并返回该元素。例: 12345&lt;script type="text/javascript"&gt; var my_array = new Array('1','2','3','411'); alert(my_array.pop()); //返回411 alert(my_array.length); //返回3&lt;/script&gt; (8) shift函数:移除数组中的第一个元素并返回该元素。例: 12345&lt;script type="text/javascript"&gt; var my_array = new Array('1','2','3','4'); alert(my_array.shift()); //返回1 alert(my_array.length); //返回3&lt;/script&gt; (9) Obj.slice(start,end) 返回一个数组的一段，得到一个新数组。注意不包括 end 对应的元素，如果省略 end 将复制 start 之后的所有元素,例如： 123456789&lt;script type="text/javascript"&gt; var my_array = new Array('1','2','3','4'); var new_array = my_array.slice(0,2); //返回0-2个元素 var new_array = my_array.slice(0,-1); //返回除了最后一个之外的元素 var new_array = my_array.slice(0); //返回第0以后的所有的元素 for(var i =0;i&lt;new_array.length;i++)&#123; alert(new_array[i]); &#125;&lt;/script&gt; (10) Obj.concat(item1,item2,item3,item4,item5……) 返回一个新数组，这个新数组是由两个或更多数组（也可以是一个变量）组合而成的,。例: 12345678910&lt;script type="text/javascript"&gt; var my_array = new Array('1','2','3','4'); var my_array1 = new Array('5','6'); var my_array2 = new Array('7','8'); var my_array3 = new Array('9'); var my_name = 'SmarTop'; //也可以是一个字符串 var my_age = 26; //也可以是一个数字 var new_array = my_array.concat(my_array1,my_array2,my_array3,my_name,my_age); alert(new_array);&lt;/script&gt; 日期函数javascript日期函数包括以下20个函数： (1) getDate函数：返回日期的”日”部分，值为1～31。例： 12345678function DateDemo()&#123; var d, s = "Today's date is: "; d = new Date(); s += (d.getMonth() + 1) + "/"; s += d.getDate() + "/"; s += d.getYear(); return(s);&#125; (2) getDay函数：返回星期几，值为0～6，其中0表示星期日，1表示星期一，…，6表示星期六。例： 123456789function DateDemo()&#123; var d, day, x, s = "Today is: "; var x = new Array("Sunday", "Monday", "Tuesday"); var x = x.concat("Wednesday","Thursday", "Friday"); var x = x.concat("Saturday"); d = new Date(); day = d.getDay(); return(s += x[day]);&#125; (3) getHours函数：返回日期的”小时”部分，值为0～23。例： 12345678910function TimeDemo()&#123; var d, s = "The current local time is: "; var c = ":"; d = new Date(); s += d.getHours() + c; s += d.getMinutes() + c; s += d.getSeconds() + c; s += d.getMilliseconds(); return(s);&#125; (4) getMinutes函数：返回日期的”分钟”部分，值为0～59。见上例。(5) getMonth函数：返回日期的”月”部分，值为0～11。其中0表示1月，2表示3月，…，11表示12月。见前面的例子。(6) getSeconds函数：返回日期的”秒”部分，值为0～59。见前面的例子。(7) getTime函数：返回系统时间。 1234567891011function GetTimeTest()&#123; var d, s, t; var MinMilli = 1000 * 60; var HrMilli = MinMilli * 60; var DyMilli = HrMilli * 24; d = new Date(); t = d.getTime(); s = "It's been " s += Math.round(t / DyMilli) + " days since 1/1/70"; return(s);&#125; (8) getTimezoneOffset函数：返回此地区的时差(当地时间与GMT格林威治标准时间的地区时差)，单位为分钟。 123456789101112function TZDemo()&#123; var d, tz, s = "The current local time is "; d = new Date(); tz = d.getTimezoneOffset(); if (tz &lt; 0) s += tz / 60 + " hours before GMT"; else if (tz == 0) s += "GMT"; else s += tz / 60 + " hours after GMT"; return(s);&#125; (9) getYear函数：返回日期的”年”部分。返回值以1900年为基数，例如1999年为99。前面有例子。(10) parse函数：返回从1970年1月1日零时整算起的毫秒数(当地时间)。 123456789101112function GetTimeTest(testdate)&#123; var d, s, t; var MinMilli = 1000 * 60; var HrMilli = MinMilli * 60; var DyMilli = HrMilli * 24; d = new Date(); t = Date.parse(testdate); s = "There are " s += Math.round(Math.abs(t / DyMilli)) + " days " s += "between " + testdate + " and 1/1/70"; return(s);&#125; (11) setDate函数：设定日期的”日”部分，值为0～31。(12) setHours函数：设定日期的”小时”部分，值为0～23。(13) setMinutes函数：设定日期的”分钟”部分，值为0～59。(14) setMonth函数：设定日期的”月”部分，值为0～11。其中0表示1月，…，11表示12月。(15) setSeconds函数：设定日期的”秒”部分，值为0～59。(16) setTime函数：设定时间。时间数值为1970年1月1日零时整算起的毫秒数。(17) setYear函数：设定日期的”年”部分。(18) toGMTString函数：转换日期成为字符串，为GMT格林威治标准时间。(19) setLocaleString函数：转换日期成为字符串，为当地时间。(20) UTC函数：返回从1970年1月1日零时整算起的毫秒数，以GMT格林威治标准时间计算。 数学函数javascript数学函数其实就是Math对象，它包括属性和函数(或称方法)两部分。其中，属性主要有下列内容。Math.e:e(自然对数)、Math.LN2（2的自然对数)、Math.LN10(10的自然对数)、Math.LOG2E(e的对数，底数为2)、 Math.LOG10E(e的对数，底数为10)、Math.PI(π)、Math.SQRT1_2(1/2的平方根值)、Math.SQRT2(2的平方根值)。函数有以下18个：(1) abs函数：即Math.abs(以下同)，返回一个数字的绝对值。(2) acos函数：返回一个数字的反余弦值，结果为0～π弧度(radians)。(3) asin函数：返回一个数字的反正弦值，结果为-π/2～π/2弧度。(4) atan函数：返回一个数字的反正切值，结果为-π/2～π/2弧度。(5) atan2函数：返回一个坐标的极坐标角度值。(6) ceil函数：返回一个数字的最小整数值(大于或等于)。(7) cos函数：返回一个数字的余弦值，结果为-1～1。(8) exp函数：返回e(自然对数)的乘方值。(9) floor函数：返回一个数字的最大整数值(小于或等于)。(10) log函数：自然对数函数，返回一个数字的自然对数(e)值。(11) max函数：返回两个数的最大值。(12) min函数：返回两个数的最小值。(13) pow函数：返回一个数字的乘方值。(14) random函数：返回一个0～1的随机数值。(15) round函数：返回一个数字的四舍五入值，类型是整数。(16) sin函数：返回一个数字的正弦值，结果为-1～1。(17) sqrt函数：返回一个数字的平方根值。(18) tan函数：返回一个数字的正切值。 字符串函数(1) concat函数:将两个或多个字符的文本组合起来，返回一个新的字符串。 12345var a = "hello";var b = ",world";var c = a.concat(b);alert(c);//c = "hello,world" (2) indexOf函数：返回字符串中一个子串第一处出现的索引（从左到右搜索）。如果没有匹配项，返回 -1 。 1234var index1 = a.indexOf("l");//index1 = 2var index2 = a.indexOf("l",3); //3表示从第三个开始向右搜索//index2 = 3 (3) lastIndexOf:返回字符串中一个子串第一处出现的索引（从右到左搜索）。如果没有匹配项，返回 -1 。 1234var index1 = lastIndexOf('l');//index1 = 3var index2 = lastIndexOf('l',2)//3表示从第三个开始向左搜索//index2 = 2 (4) charAt：返回字符串中指定的某个字符。 12var get_char = a.charAt(0);//get_char = "h" (5) match：检查一个字符串匹配一个正则表达式内容，如果没有匹配返回 null。 12345var re = new RegExp(/^\w+$/); //存储检索模式var is_alpha1 = a.match(re);//is_alpha1 = "hello"var is_alpha2 = b.match(re);//is_alpha2 = null (6) substring:返回位于 String 对象中指定位置的子字符串。 1234var sub_string1 = a.substring(1);//sub_string1 = "ello"var sub_string2 = a.substring(1,4);//sub_string2 = "ell" (6) substr：返回字符串的一个子串，传入参数是起始位置和长度 1234var sub_string1 = a.substr(1);//sub_string1 = "ello"var sub_string2 = a.substr(1,4); //长度//sub_string2 = "ello" (7) replace：用来查找匹配一个正则表达式的字符串，然后使用新字符串代替匹配的字符串。 12345var r, re; // 声明变量。var ss = "The man hit the ball with the bat.\n";ss += "while the fielder caught the ball with the glove.";re = /The/g; // 创建正则表达式模式。r = ss.replace(re, "A"); // 用 "A" 替换 "The"。 var r, re; // 声明变量。var ss = “The rain in Spain falls mainly in the plain.”;re = /(\S+)(\s+)(\S+)/g; // 创建正则表达式模式。r = ss.replace(re, “$3$2$1”); // 交换每一对单词。 (8) search：执行一个正则表达式匹配查找。如果查找成功，返回字符串中匹配的索引值。否则返回 -1 。 1234var index1 = a.search(re);//index1 = 0var index2 = b.search(re);//index2 = -1 (9) slice:提取字符串的一部分，并返回一个新字符串（与 substring 相同）。 1234var sub_string1 = a.slice(1);//sub_string1 = "ello"var sub_string2 = a.slice(1,4);//sub_string2 = "ell" (10) split:通过将字符串划分成子串，将一个字符串做成一个字符串数组。 123var arr1 = a.split(""); //使用分割的字符 //arr1 = [h,e,l,l,o] length (11) length:返回字符串的长度，所谓字符串的长度是指其包含的字符的个数。 12var len = a.length(); //len = 5 (12) toLowerCase:将整个字符串转成小写字母。 12var lower_string = a.toLowerCase();//lower_string = "hello" (13) toUpperCase:将整个字符串转成大写字母。 12var upper_string = a.toUpperCase();//upper_string = "HELLO"]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>常用函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript事件]]></title>
    <url>%2F2017%2F05%2F07%2FJavaScript%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[与浏览器进行交互的时候浏览器就会触发各种事件。比如当我们打开某一个网页的时候，浏览器加载完成了这个网页，就会触发一个 load 事件；当我们点击页面中的某一个“地方”，浏览器就会在那个“地方”触发一个 click 事件。 这样，我们就可以编写 JavaScript，通过监听某一个事件，来实现某些功能扩展。例如监听 load 事件，显示欢迎信息，那么当浏览器加载完一个网页之后，就会显示欢迎信息。 下面就来介绍一下事件。 基础事件操作监听事件浏览器会根据某些操作触发对应事件，如果我们需要针对某种事件进行处理，则需要监听这个事件。监听事件的方法主要有以下几种： HTML 内联属性（避免使用）HTML 元素里面直接填写事件有关属性，属性值为 JavaScript 代码，即可在触发该事件的时候，执行属性值的内容。 例如： 1&lt;button onclick="alert('你点击了这个按钮');"&gt;点击这个按钮&lt;/button&gt; 上面代码就是监听 element 节点的 click 事件。它比较简单易懂，而且有较好的兼容性。但是也有缺陷，因为直接赋值给对应属性，如果你在后面代码中再次为 element 绑定一个回调函数，会覆盖掉之前回调函数的内容。 虽然也可以用一些方法实现多个绑定，但还是推荐下面的标准事件监听函数。 DOM 属性绑定也可以直接设置 DOM 属性来指定某个事件对应的处理函数，这个方法比较简单： 123456element.onclick = function(event)&#123; alert('你点击了这个按钮');&#125;;/* 上面代码就是监听 element 节点的 click 事件。它比较简单易懂，而且有较好的兼容性。但是也有缺陷，因为直接赋值给对应属性，如果你在后面代码中再次为 element 绑定一个回调函数，会覆盖掉之前回调函数的内容。虽然也可以用一些方法实现多个绑定，但还是推荐下面的标准事件监听函数。 */ 使用事件监听函数标准的事件监听函数如下： 1element.addEventListener(&lt;event-name&gt;, &lt;callback&gt;, &lt;use-capture&gt;); 表示在 element 这个对象上面添加一个事件监听器，当监听到有 &lt;event-name&gt; 事件发生的时候，调用 &lt;callback&gt; 这个回调函数。至于 &lt;use-capture&gt; 这个参数，表示该事件监听是在“捕获”阶段中监听（设置为 true）还是在“冒泡”阶段中监听（设置为 false）。关于捕获和冒泡，我们会在下面讲解。 用标准事件监听函数改写上面的例子： 1234567&lt;button id="btn"&gt;点击这里&lt;/button&gt;&lt;script&gt;var btn = document.getElementById('btn');btn.addEventListener('click', function()&#123; alert('你点击了这里');&#125;, false);&lt;/script&gt; 移除事件监听当我们为某个元素绑定了一个事件，每次触发这个事件的时候，都会执行事件绑定的回调函数。如果我们想解除绑定，需要使用 removeEventListener 方法： 1element.removeEventListener(&lt;event-name&gt;, &lt;callback&gt;, &lt;use-capture&gt;); 需要注意的是，绑定事件时的回调函数不能是匿名函数，必须是一个声明的函数，因为解除事件绑定时需要传递这个回调函数的引用，才可以断开绑定。例如： 123456789&lt;button id="btn"&gt;点击这里&lt;/button&gt;&lt;script&gt; var btn = document.getElementById('btn'); var fun = function()&#123; alert('这个按钮只支持一次点击'); btn.removeEventListener('click', fun, false);&#125;;btn.addEventListener('click', fun, false);&lt;/script&gt; 事件触发过程在上面大体了解了事件是什么、如何监听并执行某些操作，但我们对事件触发整个过程还不够了解。 下图就是事件的触发过程，借用了 W3C 的图片 JavaScript中的一些常用事件onclick事件点击事件（onclick并不是js中的方法，onclick只是浏览器提供js的一个dom接口，让js可以操作dom，所以onclick大小写都是没问题的，比如HTML代码就不用区分大小写） 1234567&lt;buttononclick="myFunction()"&gt;点击这里&lt;/button&gt;&lt;script&gt; functionmyFunction()&#123; alert("测试onclick点击事件"); &#125;&lt;/script&gt; onclick通常在下列基本对象中产生： button(按钮对象)、checkbox(复选框)、radio(单选框)、reset buttons(重置按钮)、submit buttons(提交按钮) onload事件可以body执行，,其中onload后面可以写一个方法，如：onload=”test()”,然后在JavaScript中写一个test()方法，则在页面一开始加载的时候会先调用这个方法 12345678&lt;bodyonload="test()"&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; functiontest()&#123; alert("测试onload方法"); &#125;&lt;/script&gt; 注意：此方法只能写在标签之中 onchange事件事件在内容改变的时候触发，和jQuery中的change()方法一样 当内容改变时触发。可用于文本框、列表框等对象，该事件一般用于响应用户修改内容带来的其他改变操作。 说明：当用户向一个文本框中输入文本时，不会触发onchange事件，只有用户输入结束后，单击文本框以外的区域，使文本框失去焦点时才触发该事件，如果是下拉框，则选择结束后即触发。 1234567891011&lt;p&gt; &lt;labelfor="name"&gt;用户名：&lt;/label&gt; &lt;input type="text" id="fname" onchange="upperCase()" value=""/&gt;&lt;/p&gt;&lt;script type="text/javascript"&gt; functionupperCase()&#123; var x = document.getElementById("fname").value; document.getElementById("fname").value = x.toUpperCase(); &#125;&lt;/script&gt; 说明：上例实际效果是，当输入框失去焦点时内容转成大写。出现这种情况是由于input必须是失去焦点才会检测到内容发生改变。而change事件通常是用于下拉菜单select标签。 onblur事件和onfocus事件onblur事件：当前元素失去焦点时触发该事件；onfocus事件：得到焦点事件 123456789101112131415&lt;body&gt;失去焦点：&lt;inputtype="text" name="name" value=" "size="30" onblur="chkvalue(this)"&gt;&lt;br&gt;得到焦点：&lt;inputtype="text" id="name" value="" size="30" onfocus="setStyle(this.id)"&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; function chkvalue(txt) &#123; if(txt.value=="") alert("文本框里必须填写内容!"); &#125; function setStyle(x)&#123; document.getElementById(x).style.background="yellow" &#125;&lt;/script&gt; onscroll事件窗口滚动事件：当页面滚动时调用函数。此事件写在方法的外面，且函数名后面不加括号，例如window.onscroll=move 123456&lt;script type="text/javascript"&gt; functionmove() &#123; alert("页面滚动时调用"); &#125; window.onscroll = move;&lt;/script&gt; onsubmit事件属于表单元素，写在表单标签内。语法：onsubmit=”return 函数名()” 1234567891011&lt;form action="" method="post" name="testForm" onsubmit="returnmove()"&gt; &lt;inputtype="text"name="name"value=""&gt; &lt;br&gt; &lt;input type="submit" name="submit" value="测试onsubmit"/&gt;&lt;/form&gt;&lt;script type="text/javascript"&gt; functionmove() &#123; alert("测试onsubmit........"+testForm.name.value); &#125;&lt;/script&gt; 鼠标相关事件onmousemove和onmouseout和onmouseover事件Onmouseover:鼠标移动到某对象范围的上方时，触发事件调用函数。注意：在同一个区域中，无论怎样移动都只触发一次函数。 Onmouseout:鼠标离开某对象范围时，触发事件调用函数。 Onmousemove:鼠标移动到某对象范围的上方时，触发事件调用函数。注意：在同一个区域中，只要鼠标动一次就触发一次事件。 12345678910111213&lt;img onmousemove="bigImg(this)" onmouseout="normalImg(this)" border="0" src="images/defaultAvatar.gif" alt="Smiley"&gt;&lt;script type="text/javascript"&gt; functionbigImg(x)&#123; x.style.height="180px"; x.style.width="180px"; &#125; functionnormalImg(x)&#123; x.style.height="128px"; x.style.width="128px"; &#125;&lt;/script&gt; onmouseup和onmousedownOnmouseup:当鼠标松开时触发事件 Onmousedown:当鼠标按下键时触发事件 123456789101112&lt;p id="p1" onmousedown="mouseDown()" onmouseup="mouseUp()"&gt;请点击文本！mouseDown()函数当鼠标按钮在段落上被按下时触发。此函数把文本颜色设置为红色。mouseUp() 函数在鼠标按钮被释放时触发。mouseUp() 函数把文本的颜色设置为绿色。&lt;/p&gt;&lt;script type="text/javascript"&gt; functionmouseDown()&#123; document.getElementById("p1").style.color="red"; &#125; functionmouseUp()&#123; document.getElementById("p1").style.color="green"; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript之DOM操作]]></title>
    <url>%2F2017%2F05%2F06%2Fjavascript%E4%B9%8BDOM%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[前言DOM 中的三个字母，D（文档）可以理解为整个 Web 加载的网页文档；O（对象）可以理解为类似 window 对象之类的东西，可以调用属性和方法，这里我们说的是 document对象；M（模型）可以理解为网页文档的树型结构。 一、document.getElementById() 根据Id获取元素节点1234567891011&lt;div id="div1"&gt; &lt;p id="p1"&gt; 我是第一个P&lt;/p&gt; &lt;p id="p2"&gt; 我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var str = document.getElementById("p1").innerHTML; alert(str); //弹出 我是第一个P &#125; 二、document.getElementsByName() 根据name获取元素节点12345678910111213&lt;div id="div1"&gt; &lt;p id="p1"&gt; 我是第一个P&lt;/p&gt; &lt;p id="p2"&gt; 我是第二个P&lt;/p&gt; &lt;input type="text" value="请输入值" name="userName" /&gt; &lt;input type="button" value="确定" onclick="fun1()"&gt;&lt;/div&gt; function fun1() &#123; var username = document.getElementsByName("userName")[0].value; alert(username); //输出userName里输入的值&#125; 三、document.getElementsByTagName() 根据HTML标签名获取元素节点，注意getElements*的选择器返回的是一个NodeList对象，能根据索引号选择其中1个，可以遍历输出。123456789101112131415161718192021222324&lt;div id="div1"&gt; &lt;p id="p1"&gt; 我是第一个P&lt;/p&gt; &lt;p id="p2"&gt; 我是第二个P&lt;/p&gt; &lt;/div&gt; window.onload = function () &#123; var str = document.getElementsByTagName("p")[1].innerHTML; alert(str); //输出 我是第二个P，因为获取的是索引为1的P，索引从0开始 &#125; window.onload = function () &#123; var arr = document.getElementsByTagName("p"); for (var i = 0; i &lt; arr.length; i++) &#123; alert(arr[i].innerHTML); &#125; &#125; window.onload = function () &#123; var node = document.getElementById("div1"); var node1 = document.getElementsByTagName("p")[1]; //从获取到的元素再获取 alert(node1.innerHTML); &#125; 四、document.getElementsByClassName() 根据class获取元素节点1234567891011&lt;div id="div1"&gt; &lt;p id="p1" class="class1"&gt; 我是第一个P&lt;/p&gt; &lt;p id="p2"&gt; 我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var node = document.getElementsByClassName("class1")[0]; alert(node.innerHTML); &#125; 五、javascript中的CSS选择器1234567891011121314151617181920document.querySelector() //根据CSS选择器的规则，返回第一个匹配到的元素document.querySelectorAll() //根据CSS选择器的规则，返回所有匹配到的元素&lt;div id="div1"&gt; &lt;p id="p1" class="class1"&gt; 我是第一个P&lt;/p&gt; &lt;p id="p2" class="class2"&gt; 我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var node = document.querySelector("#div1 &gt; p"); alert(node.innerHTML); //输出 我是第一个P var node1 = document.querySelector(".class2"); alert(node1.innerHTML); //输出 我是第二个P var nodelist = document.querySelectorAll("p"); alert(nodelist[0].innerHTML + " - " + nodelist[1].innerHTML); //输出 我是第一个P - 我是第二个P&#125; 六、文档结构和遍历作为节点数的文档 ​ parentNode 获取该节点的父节点 ​ childNodes 获取该节点的子节点数组 ​ firstChild 获取该节点的第一个子节点 ​ lastChild 获取该节点的最后一个子节点 ​ nextSibling 获取该节点的下一个兄弟元素 ​ previoursSibling 获取该节点的上一个兄弟元素 ​ nodeType 节点的类型，9代表Document节点，1代表Element节点，3代表Text节点，8代表 Comment节点，11代表DocumentFragment节点 ​ nodeVlue Text节点或Comment节点的文本内容 ​ nodeName 元素的标签名(如P,SPAN,#text(文本节点),DIV)，以大写形式表示 注意，以上6个方法连元素节点也算一个节点。 12345678910111213141516171819202122232425262728293031323334353637&lt;div id="div1"&gt; &lt;p id="p1" class="class1"&gt; 我是第一个P&lt;/p&gt; &lt;p id="p2" class="class2"&gt; 我是第二个P&lt;/p&gt;&lt;/div&gt; window.onload = function () &#123; var node1 = document.querySelector(".class2"); alert(node1.parentNode.innerHTML); //输出 &lt;p id="p1" class="class1"&gt;我是第一个P&lt;/p&gt;&lt;p id="p2" class="class2"&gt;我是第二个P&lt;/p&gt; var nodelist = document.getElementById("div1"); var arr = nodelist.childNodes; alert(arr[1].innerHTML + " - " + arr[3].innerHTML); //输出 我是第一个P - 我是第二个P 为什么是1，3呢？因为本方法文本节点也会获取，也就是说0,2,4是文本节点 &#125;&lt;div id="div1"&gt; 文本1 &lt;p id="p1" class="class1"&gt; 我是第一个P&lt;/p&gt; 文本2 &lt;p id="p2" class="class2"&gt; 我是第二个P&lt;/p&gt; 文本3&lt;/div&gt;window.onload = function () &#123; //依次输出，文本1，我是第一个P，文本2，我是第二个P，文本3 var node = document.getElementById("div1"); for (var i = 0; i &lt; node.childNodes.length; i++) &#123; if (node.childNodes[i].nodeType == 1) &#123; alert(node.childNodes[i].innerHTML); &#125; else if (node.childNodes[i].nodeType == 3) &#123; alert(node.childNodes[i].nodeValue); &#125; &#125;&#125; 作为元素树的文档 ​ firstElementChild 第一个子元素节点 ​ lastElementChild 最后一个子元素节点 ​ nextElementSibling 下一个兄弟元素节点 ​ previousElementSibling 前一个兄弟元素节点 ​ childElementCount 子元素节点个数量 注意，此5个方法文本节点不算进去 123456789101112131415161718&lt;div id="div1"&gt; &lt;p id="p1" class="class1"&gt; 我是第一个P&lt;/p&gt; &lt;p id="p2" class="class2"&gt; 我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var node = document.getElementById("div1"); var node1 = node.firstElementChild; var node2 = node.lastElementChild; alert(node.childElementCount); //输出2，div1一共有两个非文档子元素节点 alert(node1.innerHTML); //输出 我是第一个P alert(node2.innerHTML); //输出 我是第二个P alert(node2.previousElementSibling.innerHTML); //输出 我是第一个P(第二个元素节点的上一个非文本元素节点是P1) alert(node1.nextElementSibling.innerHTML); //输出 我是第二个P(第一个元素节点的下一个兄弟非文本节点是P2)&#125; 七、javascript操作HTML属性1、属性的读取，此处要注意的是，某些HTML属性名称在javascript之中是保留字，因此会有些许不同，如class,lable中的for在javascript中变为htmlFor,className。1234567891011121314&lt;div id="div1"&gt; &lt;p id="p1" class="class1"&gt; 我是第一个P&lt;/p&gt; &lt;img src="123.jpg" alt="我是一张图片" id="img1" /&gt; &lt;input type="text" value="我是一个文本框" id="input1" /&gt;&lt;/div&gt;window.onload = function () &#123; var nodeText = document.getElementById("input1"); alert(nodeText.value); //输出 我是一个文本框 var nodeImg = document.getElementById("img1"); alert(nodeImg.alt); //输出 我是一张图片 var nodeP = document.getElementById("p1"); alert(nodeP.className); //输出 class1 注意获取class是className，如果写成nodeP.class则输出undefined&#125; 2、属性的设置，此处同样要注意的是保留字1234567&lt;div id="div1"&gt; &lt;img src="1big.jpg" alt="我是一张图片" id="img1" onclick="fun1()" /&gt;&lt;/div&gt;function fun1() &#123; document.getElementById("img1").src = "1small.jpg"; //改变图片的路径属性。实现的效果为，当点击图片时，大图变小图。&#125; 3、非标准HTML属性getAttribute(); // 注意这两个方法是不必理会javascript保留字的，HTML属性是什么就怎么写。setAttribute(); 12345678&lt;div id="div1"&gt; &lt;img src="1big.jpg" alt="我是一张图片" class="imgClass" id="img1" onclick="fun1()" /&gt;&lt;/div&gt;function fun1() &#123; document.getElementById("img1").setAttribute("src", "1small.jpg"); alert(document.getElementById("img1").getAttribute("class"));&#125; 4、Attr节点的属性attributes属性 非Element对象返回null，Element一半返回Attr对象。Attr对象是一个特殊的Node,通过name与value获取属性名称与值。如:document.getElementById(“img1”)[0]; document.getElementById(“img1”).src; 123456789&lt;div id="div1"&gt; &lt;img src="1big.jpg" alt="我是一张图片" class="imgClass" id="img1" onclick="fun1()" /&gt;&lt;/div&gt;function fun1() &#123; alert(document.getElementById("img1").attributes[0].name); //输出 onclick 注意，通过索引器访问是写在右面在排前面，从0开始 alert(document.getElementById("img1").attributes.src.value); //输出1big.jpg document.getElementById("img1").attributes.src.value = "1small.jpg"; //点击后改变src属性，实现了点击大图变小图效果&#125; 八、元素的内容1、innerText、textContent innerText与textContent的区别，当文本为空时，innerText是””，而textContent是undefined2、innerHTML 123456789101112&lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p id="p2"&gt;我是第&lt;b&gt;二&lt;/b&gt;个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; alert(document.getElementById("p1").innerText); //注意火狐浏览器不支持innerText alert(document.getElementById("p1").textContent); //基本都支持textContent document.getElementById("p1").textContent = "我是p1，javascript改变了我"; //设置文档Text alert(document.getElementById("p2").textContent); alert(document.getElementById("p2").innerHTML); //innerHTML与innerText的区别，就是对HTML代码的输出方式Text不会输出HTML代码&#125; 九、创建，插入，删除节点1、document.createTextNode() 创建一个文本节点12345678910111213141516&lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p id="p2"&gt;我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var textNode = document.createTextNode("&lt;p&gt;我是一个javascript新建的节点&lt;/p&gt;"); document.getElementById("div1").appendChild(textNode);&#125;/* 完成后HTML变为： div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p id="p2"&gt;我是第二个P&lt;/p&gt; &lt;p&gt;我是一个javascript新建的节点&lt;/p&gt; &lt;/div&gt; */ 2、document.createElement() 创建一个元素节点12345678910111213141516&lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p id="p2"&gt;我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var pNode = document.createElement("p"); pNode.textContent = "新建一个P节点"; document.getElementById("div1").appendChild(pNode);&#125;/* &lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p id="p2"&gt;我是第二个P&lt;/p&gt; &lt;p&gt;新建一个P节点&lt;/p&gt; &lt;/div&gt; */ 3、插入节点appendChild() //将一个节点插入到调用节点的最后面insertBefore() //接受两个参数，第一个为待插入的节点，第二个指明在哪个节点前面，如果不传入第二个参数，则跟appendChild一样，放在最后。 12345678910111213141516171819&lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var pNode1 = document.createElement("p"); pNode1.textContent = "insertBefore插入的节点"; var pNode2 = document.createElement("p"); pNode2.textContent = "appendChild插入的节点"; document.getElementById("div1").appendChild(pNode2); document.getElementById("div1").insertBefore(pNode1,document.getElementById("p1"));&#125;/* 执行之后HTML代码为： &lt;div id="div1"&gt; &lt;p&gt;insertBefore插入的节点&lt;/p&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p&gt;appendChild插入的节点&lt;/p&gt; &lt;/div&gt; */ 十、删除和替换节点。1、removeChild(); 由父元素调用，删除一个子节点。注意是直接父元素调用，删除直接子元素才有效，删除孙子元素就没有效果了。1234567891011121314&lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p id="p2"&gt;我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var div1 = document.getElementById("div1"); div1.removeChild(document.getElementById("p2"));&#125;/* 执行之后代码变为： &lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; //注意到第二个P元素已经被移除了 &lt;/div&gt; */ 2、replaceChild() //删除一个子节点，并用一个新节点代替它，第一个参数为新建的节点，第二个节点为被替换的节点1234567891011121314151617&lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p id="p2"&gt;我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var div1 = document.getElementById("div1"); var span1 = document.createElement("span"); span1.textContent = "我是一个新建的span"; div1.replaceChild(span1,document.getElementById("p2"));&#125;/* 执行完成后HTML代码变为： &lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;span&gt;我是一个新建的span&lt;/span&gt; //留意到p2节点已经被替换为span1节点了 &lt;/div&gt; */ 十一、javascript操作元素CSS通过元素的style属性可以随意读取和设置元素的CSS样式，例子： 123456789101112&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; window.onload = function () &#123; alert(document.getElementById("div1").style.backgroundColor); document.getElementById("div1").style.backgroundColor = "yellow"; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="div1" style="width:100px; height:100px; background-color:red"&gt;&lt;/div&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>DOM操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript编码规范]]></title>
    <url>%2F2017%2F05%2F06%2FJavaScript%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[前言好的编码规范可以尽可能的减少一个软件的维护成本，并且几乎没有任何一个软件，在其整个生命周期中，均由最初的开发人员来维护；好的编码规范可以改善软件的可读性，可以让开发人员尽快而彻底地理解新的代码；好的编码规范可以最大限度的提高团队开发的合作效率；长期的规范性编码还可以让开发人员养成好的编码习惯，甚至锻炼出更加严谨的思维。 不规范写法举例句尾没有分号1var isHotel = json.type == "hotel" ? true : false 变量命名各种各样123var is_hotel;var isHotel;var ishotel; if缩写1234if (isHotel) console.log(true)else console.log(false) 使用eval1234567var json = eval(jsonText);/* eval 好不好取决于怎么使用它，一般认为的缺点： 1. 可读性非常差 2. 不好再做优化和编译 3. 会轻微增加性能消耗 4. 不安全，比如 eval input 的值 */ 变量未定义到处都是123456function() &#123; var isHotel = 'true'; ....... var html = isHotel ? '&lt;p&gt;hotel&lt;/p&gt;' : "";&#125; 超长函数12345function() &#123; var isHotel = 'true'; //....... 此处省略500行 return false;&#125; ……….书写不规范的代码让我们难以维护，有时候也让我们头疼。 （禁止）、（必须）等字眼，在这里只是表示强调，未严格要求。 前端规范之JavaScripttab键用（必须）用四个空格代替​ 因为在不同系统的编辑工具对tab解析不一样，windows下的tab键是占四个空格的位置，而在linux下会变成占八个空格的位置（除非你自己设定了tab键所占的位置长度）。 一些童鞋可能会有疑问，tab键换成四个空格，多麻烦啊~ 其实不然，我平时用sublime text比较多，在这个工具中可以对tab键进行设置。 每句代码后（必须）加”;” 这个是要引起注意的，比如： 1234a = b // 赋值(function()&#123; //....&#125;)() // 自执行函数 未加分号，结果被解析成 1a = b(function()&#123;//...&#125;)() //将b()()返回的结果赋值给a 这是截然不同的两个结果，所以对于这个问题必须引起重视！！！ 变量、常量、类的命名按（必须）以下规则执行：变量：必须采用骆驼峰的命名且首字母小写123456789// 正确的命名 var isHotel, isHotelBeijing, isHotelBeijingHandian; // 不推荐的命名 var is_Hotel, ishotelbeijing, IsHotelBeiJing; 常量：必须采用全大写的命名，且单词以_分割**，常量通常用于ajax请求url，和一些不会改变的数据 123// 正确的命名 var HOTEL_GET_URL = 'http://map.baidu.com/detail', PLACE_TYPE = 'hotel'; 类：必须采用骆驼峰的命名且首字母大写，如：1234// 正确的写法 var FooAndToo = function(name) &#123; this.name = name; &#125; 空格的使用1.if中的空格，先上例子 1234567891011 //正确的写法 if (isOk) &#123; console.log("ok"); &#125; //不推荐的写法 if(isOk)&#123; console.log("ok"); &#125;/* ()中的判断条件前后都(必须)加空格 ()里的判断前后(禁止)加空格，如：正确的写法: if (isOk)；不推荐的写法: if ( isOk ) */ 2.switch中的空格, 先上例子 1234567891011121314151617181920212223242526//正确的写法 switch(name) &#123; case "hotel": console.log(name); break; case "moive": console.log(name); break; default: // code &#125; //不推荐的写法 switch (name) &#123; // switch 后不应该有空格, 正确的写法: switch(name) &#123; // code case "hotel": console.log(name); break; // break; 应该和console.log对齐 case "movie": // 每个case之前需要有换行 console.log(name); break; // break; 应该和console.log对齐 default: // code &#125; 3.for中的空格，先上例子 12345678910111213141516171819 // 正确的写法 var names = ["hotel", "movie"], i, len; for (i=0, len=names.length; i &lt; len; i++) &#123; // code &#125; // 不推荐的写法 var names = ["hotel", "movie"], i, len; for(i = 0, len = names.length;i &lt; len;i++) &#123; // for后应该有空格，每个`;`号后需要有空格，变量的赋值不应该有空格 // code &#125;/* for后（必须）加空格 每个;后（必须）加空格 ()中禁止用var声明变量; 且变量的赋值 = 前后（禁止）加空格 */ 4.function 中的空格, 先上例子 12345678910111213141516 // 正确的写法 function call(name) &#123; &#125; var cell = function () &#123; &#125;; // 不推荐的写法 var call = function(name)&#123; // code &#125; /* 参数的反括号后（必须）加空格 function 后（必须）加空格 */ 5.var 中空格及定义，先上例子 12345678910111213 // 一个推荐的var写法组 function(res) &#123; var code = 1 + 1, json = JSON.parse(res), type, html; // code &#125;/* 声明变量 = 前后（必须）添加空格 每个变量的赋值声明以,结束后（必须）换行进行下一个变量赋值声明 （推荐）将所有不需要进行赋值的变量声明放置最后一行，且变量之间不需要换行 （推荐）当一组变量声明完成后，空一行后编写其余代码 */ 6.在同一个函数内部，局部变量的声明必须置于顶端 因为即使放到中间，js解析器也会提升至顶部（hosting） 1234567891011121314151617181920// 正确的书写var clear = function(el) &#123; var id = el.id, name = el.getAttribute("data-name"); ......... return true;&#125;// 不推荐的书写var clear = function(el) &#123; var id = el.id; ...... var name = el.getAttribute("data-name"); ......... return true;&#125; 7.块内函数必须用局部变量声明 123456789101112131415161718192021222324// 错误的写法 var call = function(name) &#123; if (name == "hotel") &#123; function foo() &#123; console.log("hotel foo"); &#125; &#125; foo &amp;&amp; foo(); &#125; // 推荐的写法 var call = function(name) &#123; var foo; if (name == "hotel") &#123; foo = function() &#123; console.log("hotel foo"); &#125; &#125; foo &amp;&amp; foo(); &#125;/* 引起的bug：第一种写法foo的声明被提前了; 调用call时：第一种写法会调用foo函数，第二种写法不会调用foo函数 */ 8.（禁止）使用eval，采取$.parseJSON 三个原因： 有注入风险，尤其是ajax返回数据 不方便debug 效率低，eval是一个执行效率很低的函数 建议： 使用new Function来代替eval的使用，最好就别用。 9.除了三目运算，if,else等（禁止）简写 12345678910111213// 正确的书写if (true) &#123; alert(name);&#125;console.log(name);// 不推荐的书写if (true) alert(name);console.log(name);// 不推荐的书写if (true)alert(name);console.log(name) 10.（推荐）在需要以{}闭合的代码段前增加换行，如：for if 1234567891011121314151617181920212223242526272829303132// 没有换行，小的代码段无法区分 if (wl &amp;&amp; wl.length) &#123; for (i = 0, l = wl.length; i &lt; l; ++i) &#123; p = wl[i]; type = Y.Lang.type(r[p]); if (s.hasOwnProperty(p)) &#123; if (merge &amp;&amp; type == 'object') &#123; Y.mix(r[p], s[p]); &#125; else if (ov || !(p in r)) &#123; r[p] = s[p]; &#125; &#125; &#125; &#125; // 有了换行，逻辑清楚多了 if (wl &amp;&amp; wl.length) &#123; for (i = 0, l = wl.length; i &lt; l; ++i) &#123; p = wl[i]; type = Y.Lang.type(r[p]); if (s.hasOwnProperty(p)) &#123; // 处理merge逻辑 if (merge &amp;&amp; type == 'object') &#123; Y.mix(r[p], s[p]); &#125; else if (ov || !(p in r)) &#123; r[p] = s[p]; &#125; &#125; &#125; &#125;/* 换行可以是空行，也可以是注释 */ 11.（推荐）使用Function进行类的定义，(不推荐)继承，如需继承采用成熟的类库实现继承 12345678910111213141516171819// 类的实现 function Person(name) &#123; this.name = name; &#125; Person.prototype.sayName = function() &#123; alert(this.name); &#125;; var me = new Person("Nicholas"); // 将this放到局部变量self function Persion(name, sex) &#123; var self = this; self.name = name; self.sex = sex; &#125;/* 平时咱们写代码，基本都是小程序，真心用不上什么继承，而且继承并不是JS的擅长的语言特性，尽量少用。如果非要使用的话，注意一点： */ 123456789function A()&#123; //...&#125;function B()&#123; //...&#125;B.prototype = new A();B.prototype.constructor = B; //原则上，记得把这句话加上/* 继承从原则上来讲，别改变他的构造函数，否则这个继承就显得很别扭了~ */ 12.(推荐)使用局部变量缓存反复查找的对象(包括但不限于全局变量、dom查询结果、作用域链较深的对象) 1234567// 缓存对象var getComment = function() &#123; var dom = $("#common-container"), // 缓存dom appendTo = $.appendTo, // 缓存全局变量 data = this.json.data; // 缓存作用域链较深的对象&#125; 13.当需要缓存 this 时必须使用 self 变量进行缓存 12345678910// 缓存this function Row(name) &#123; var self = this; self.name = name; $(".row").click(function() &#123; self.getName(); &#125;); &#125;/* self是一个保留字，不过用它也没关系。在这里，看个人爱好吧，可以用_this, that, me等这些词，都行，但是团队开发的时候统一下比较好。 */ 14.（不推荐）超长函数, 当函数超过100行，就要想想是否能将函数拆为两个或多个函数 15.待挖掘… 小结规范是死的，罗列这些东西，目的是为了让程序猿们对这些东西引起注意，平时写代码的时候注意格式，不仅仅方便了自己，也让其他阅读者看得舒服。可能还有一些地方没有涉及到，如果你有好的建议，欢迎提出来补充！]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>编码规范</tag>
      </tags>
  </entry>
</search>