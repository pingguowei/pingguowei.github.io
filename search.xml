<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2017%2F05%2F07%2F123%2F</url>
    <content type="text"><![CDATA[与浏览器进行交互的时候浏览器就会触发各种事件。比如当我们打开某一个网页的时候，浏览器加载完成了这个网页，就会触发一个 load 事件；当我们点击页面中的某一个“地方”，浏览器就会在那个“地方”触发一个 click 事件。 这样，我们就可以编写 JavaScript，通过监听某一个事件，来实现某些功能扩展。例如监听 load 事件，显示欢迎信息，那么当浏览器加载完一个网页之后，就会显示欢迎信息。 下面就来介绍一下事件。 基础事件操作监听事件浏览器会根据某些操作触发对应事件，如果我们需要针对某种事件进行处理，则需要监听这个事件。监听事件的方法主要有以下几种： HTML 内联属性（避免使用）HTML 元素里面直接填写事件有关属性，属性值为 JavaScript 代码，即可在触发该事件的时候，执行属性值的内容。 例如： 1&lt;button onclick="alert('你点击了这个按钮');"&gt;点击这个按钮&lt;/button&gt; 上面代码就是监听 element 节点的 click 事件。它比较简单易懂，而且有较好的兼容性。但是也有缺陷，因为直接赋值给对应属性，如果你在后面代码中再次为 element 绑定一个回调函数，会覆盖掉之前回调函数的内容。 虽然也可以用一些方法实现多个绑定，但还是推荐下面的标准事件监听函数。 DOM 属性绑定也可以直接设置 DOM 属性来指定某个事件对应的处理函数，这个方法比较简单： 123456element.onclick = function(event)&#123; alert('你点击了这个按钮');&#125;;/* 上面代码就是监听 element 节点的 click 事件。它比较简单易懂，而且有较好的兼容性。但是也有缺陷，因为直接赋值给对应属性，如果你在后面代码中再次为 element 绑定一个回调函数，会覆盖掉之前回调函数的内容。虽然也可以用一些方法实现多个绑定，但还是推荐下面的标准事件监听函数。 */ 使用事件监听函数标准的事件监听函数如下： 1element.addEventListener(&lt;event-name&gt;, &lt;callback&gt;, &lt;use-capture&gt;); 表示在 element 这个对象上面添加一个事件监听器，当监听到有 &lt;event-name&gt; 事件发生的时候，调用 &lt;callback&gt; 这个回调函数。至于 &lt;use-capture&gt; 这个参数，表示该事件监听是在“捕获”阶段中监听（设置为 true）还是在“冒泡”阶段中监听（设置为 false）。关于捕获和冒泡，我们会在下面讲解。 用标准事件监听函数改写上面的例子： 1234567&lt;button id="btn"&gt;点击这里&lt;/button&gt;&lt;script&gt;var btn = document.getElementById('btn');btn.addEventListener('click', function()&#123; alert('你点击了这里');&#125;, false);&lt;/script&gt; 移除事件监听当我们为某个元素绑定了一个事件，每次触发这个事件的时候，都会执行事件绑定的回调函数。如果我们想解除绑定，需要使用 removeEventListener 方法： 1element.removeEventListener(&lt;event-name&gt;, &lt;callback&gt;, &lt;use-capture&gt;); 需要注意的是，绑定事件时的回调函数不能是匿名函数，必须是一个声明的函数，因为解除事件绑定时需要传递这个回调函数的引用，才可以断开绑定。例如： 123456789&lt;button id="btn"&gt;点击这里&lt;/button&gt;&lt;script&gt; var btn = document.getElementById('btn'); var fun = function()&#123; alert('这个按钮只支持一次点击'); btn.removeEventListener('click', fun, false);&#125;;btn.addEventListener('click', fun, false);&lt;/script&gt; 事件触发过程]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 事件]]></title>
    <url>%2F2017%2F05%2F07%2FJavaScript%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[与浏览器进行交互的时候浏览器就会触发各种事件。比如当我们打开某一个网页的时候，浏览器加载完成了这个网页，就会触发一个 load 事件；当我们点击页面中的某一个“地方”，浏览器就会在那个“地方”触发一个 click 事件。 这样，我们就可以编写 JavaScript，通过监听某一个事件，来实现某些功能扩展。例如监听 load 事件，显示欢迎信息，那么当浏览器加载完一个网页之后，就会显示欢迎信息。 下面就来介绍一下事件。 基础事件操作监听事件浏览器会根据某些操作触发对应事件，如果我们需要针对某种事件进行处理，则需要监听这个事件。监听事件的方法主要有以下几种： HTML 内联属性（避免使用）HTML 元素里面直接填写事件有关属性，属性值为 JavaScript 代码，即可在触发该事件的时候，执行属性值的内容。 例如： 1&lt;button onclick="alert('你点击了这个按钮');"&gt;点击这个按钮&lt;/button&gt; 上面代码就是监听 element 节点的 click 事件。它比较简单易懂，而且有较好的兼容性。但是也有缺陷，因为直接赋值给对应属性，如果你在后面代码中再次为 element 绑定一个回调函数，会覆盖掉之前回调函数的内容。 虽然也可以用一些方法实现多个绑定，但还是推荐下面的标准事件监听函数。 DOM 属性绑定也可以直接设置 DOM 属性来指定某个事件对应的处理函数，这个方法比较简单： 123456element.onclick = function(event)&#123; alert('你点击了这个按钮');&#125;;/* 上面代码就是监听 element 节点的 click 事件。它比较简单易懂，而且有较好的兼容性。但是也有缺陷，因为直接赋值给对应属性，如果你在后面代码中再次为 element 绑定一个回调函数，会覆盖掉之前回调函数的内容。虽然也可以用一些方法实现多个绑定，但还是推荐下面的标准事件监听函数。 */ 使用事件监听函数标准的事件监听函数如下： 1element.addEventListener(&lt;event-name&gt;, &lt;callback&gt;, &lt;use-capture&gt;); 表示在 element 这个对象上面添加一个事件监听器，当监听到有 &lt;event-name&gt; 事件发生的时候，调用 &lt;callback&gt; 这个回调函数。至于 &lt;use-capture&gt; 这个参数，表示该事件监听是在“捕获”阶段中监听（设置为 true）还是在“冒泡”阶段中监听（设置为 false）。关于捕获和冒泡，我们会在下面讲解。 用标准事件监听函数改写上面的例子： 1234567&lt;button id="btn"&gt;点击这里&lt;/button&gt;&lt;script&gt;var btn = document.getElementById('btn');btn.addEventListener('click', function()&#123; alert('你点击了这里');&#125;, false);&lt;/script&gt; 移除事件监听当我们为某个元素绑定了一个事件，每次触发这个事件的时候，都会执行事件绑定的回调函数。如果我们想解除绑定，需要使用 removeEventListener 方法： 1element.removeEventListener(&lt;event-name&gt;, &lt;callback&gt;, &lt;use-capture&gt;); 需要注意的是，绑定事件时的回调函数不能是匿名函数，必须是一个声明的函数，因为解除事件绑定时需要传递这个回调函数的引用，才可以断开绑定。例如： 123456789&lt;button id="btn"&gt;点击这里&lt;/button&gt;&lt;script&gt; var btn = document.getElementById('btn'); var fun = function()&#123; alert('这个按钮只支持一次点击'); btn.removeEventListener('click', fun, false);&#125;;btn.addEventListener('click', fun, false);&lt;/script&gt; 事件触发过程在上面大体了解了事件是什么、如何监听并执行某些操作，但我们对事件触发整个过程还不够了解。 下图就是事件的触发过程，借用了 W3C 的图片 JavaScript中的一些常用事件onclick事件点击事件（onclick并不是js中的方法，onclick只是浏览器提供js的一个dom接口，让js可以操作dom，所以onclick大小写都是没问题的，比如HTML代码就不用区分大小写） 1234567&lt;buttononclick="myFunction()"&gt;点击这里&lt;/button&gt;&lt;script&gt; functionmyFunction()&#123; alert("测试onclick点击事件"); &#125;&lt;/script&gt; onclick通常在下列基本对象中产生： button(按钮对象)、checkbox(复选框)、radio(单选框)、reset buttons(重置按钮)、submit buttons(提交按钮) onload事件可以body执行，,其中onload后面可以写一个方法，如：onload=”test()”,然后在JavaScript中写一个test()方法，则在页面一开始加载的时候会先调用这个方法 12345678&lt;bodyonload="test()"&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; functiontest()&#123; alert("测试onload方法"); &#125;&lt;/script&gt; 注意：此方法只能写在标签之中 onchange事件事件在内容改变的时候触发，和jQuery中的change()方法一样 当内容改变时触发。可用于文本框、列表框等对象，该事件一般用于响应用户修改内容带来的其他改变操作。 说明：当用户向一个文本框中输入文本时，不会触发onchange事件，只有用户输入结束后，单击文本框以外的区域，使文本框失去焦点时才触发该事件，如果是下拉框，则选择结束后即触发。 1234567891011&lt;p&gt; &lt;labelfor="name"&gt;用户名：&lt;/label&gt; &lt;input type="text" id="fname" onchange="upperCase()" value=""/&gt;&lt;/p&gt;&lt;script type="text/javascript"&gt; functionupperCase()&#123; var x = document.getElementById("fname").value; document.getElementById("fname").value = x.toUpperCase(); &#125;&lt;/script&gt; 说明：上例实际效果是，当输入框失去焦点时内容转成大写。出现这种情况是由于input必须是失去焦点才会检测到内容发生改变。而change事件通常是用于下拉菜单select标签。 onblur事件和onfocus事件onblur事件：当前元素失去焦点时触发该事件；onfocus事件：得到焦点事件 123456789101112131415&lt;body&gt;失去焦点：&lt;inputtype="text" name="name" value=" "size="30" onblur="chkvalue(this)"&gt;&lt;br&gt;得到焦点：&lt;inputtype="text" id="name" value="" size="30" onfocus="setStyle(this.id)"&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; function chkvalue(txt) &#123; if(txt.value=="") alert("文本框里必须填写内容!"); &#125; function setStyle(x)&#123; document.getElementById(x).style.background="yellow" &#125;&lt;/script&gt; onscroll事件窗口滚动事件：当页面滚动时调用函数。此事件写在方法的外面，且函数名后面不加括号，例如window.onscroll=move 123456&lt;script type="text/javascript"&gt; functionmove() &#123; alert("页面滚动时调用"); &#125; window.onscroll = move;&lt;/script&gt; onsubmit事件属于表单元素，写在表单标签内。语法：onsubmit=”return 函数名()” 1234567891011&lt;form action="" method="post" name="testForm" onsubmit="returnmove()"&gt; &lt;inputtype="text"name="name"value=""&gt; &lt;br&gt; &lt;input type="submit" name="submit" value="测试onsubmit"/&gt;&lt;/form&gt;&lt;script type="text/javascript"&gt; functionmove() &#123; alert("测试onsubmit........"+testForm.name.value); &#125;&lt;/script&gt; 鼠标相关事件onmousemove和onmouseout和onmouseover事件Onmouseover:鼠标移动到某对象范围的上方时，触发事件调用函数。注意：在同一个区域中，无论怎样移动都只触发一次函数。 Onmouseout:鼠标离开某对象范围时，触发事件调用函数。 Onmousemove:鼠标移动到某对象范围的上方时，触发事件调用函数。注意：在同一个区域中，只要鼠标动一次就触发一次事件。 12345678910111213&lt;img onmousemove="bigImg(this)" onmouseout="normalImg(this)" border="0" src="images/defaultAvatar.gif" alt="Smiley"&gt;&lt;script type="text/javascript"&gt; functionbigImg(x)&#123; x.style.height="180px"; x.style.width="180px"; &#125; functionnormalImg(x)&#123; x.style.height="128px"; x.style.width="128px"; &#125;&lt;/script&gt; onmouseup和onmousedownOnmouseup:当鼠标松开时触发事件 Onmousedown:当鼠标按下键时触发事件 123456789101112&lt;p id="p1" onmousedown="mouseDown()" onmouseup="mouseUp()"&gt;请点击文本！mouseDown()函数当鼠标按钮在段落上被按下时触发。此函数把文本颜色设置为红色。mouseUp() 函数在鼠标按钮被释放时触发。mouseUp() 函数把文本的颜色设置为绿色。&lt;/p&gt;&lt;script type="text/javascript"&gt; functionmouseDown()&#123; document.getElementById("p1").style.color="red"; &#125; functionmouseUp()&#123; document.getElementById("p1").style.color="green"; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript之DOM操作]]></title>
    <url>%2F2017%2F05%2F06%2Fjavascript%E4%B9%8BDOM%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[前言DOM 中的三个字母，D（文档）可以理解为整个 Web 加载的网页文档；O（对象）可以理解为类似 window 对象之类的东西，可以调用属性和方法，这里我们说的是 document对象；M（模型）可以理解为网页文档的树型结构。 一、document.getElementById() 根据Id获取元素节点1234567891011&lt;div id="div1"&gt; &lt;p id="p1"&gt; 我是第一个P&lt;/p&gt; &lt;p id="p2"&gt; 我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var str = document.getElementById("p1").innerHTML; alert(str); //弹出 我是第一个P &#125; 二、document.getElementsByName() 根据name获取元素节点12345678910111213&lt;div id="div1"&gt; &lt;p id="p1"&gt; 我是第一个P&lt;/p&gt; &lt;p id="p2"&gt; 我是第二个P&lt;/p&gt; &lt;input type="text" value="请输入值" name="userName" /&gt; &lt;input type="button" value="确定" onclick="fun1()"&gt;&lt;/div&gt; function fun1() &#123; var username = document.getElementsByName("userName")[0].value; alert(username); //输出userName里输入的值&#125; 三、document.getElementsByTagName() 根据HTML标签名获取元素节点，注意getElements*的选择器返回的是一个NodeList对象，能根据索引号选择其中1个，可以遍历输出。123456789101112131415161718192021222324&lt;div id="div1"&gt; &lt;p id="p1"&gt; 我是第一个P&lt;/p&gt; &lt;p id="p2"&gt; 我是第二个P&lt;/p&gt; &lt;/div&gt; window.onload = function () &#123; var str = document.getElementsByTagName("p")[1].innerHTML; alert(str); //输出 我是第二个P，因为获取的是索引为1的P，索引从0开始 &#125; window.onload = function () &#123; var arr = document.getElementsByTagName("p"); for (var i = 0; i &lt; arr.length; i++) &#123; alert(arr[i].innerHTML); &#125; &#125; window.onload = function () &#123; var node = document.getElementById("div1"); var node1 = document.getElementsByTagName("p")[1]; //从获取到的元素再获取 alert(node1.innerHTML); &#125; 四、document.getElementsByClassName() 根据class获取元素节点1234567891011&lt;div id="div1"&gt; &lt;p id="p1" class="class1"&gt; 我是第一个P&lt;/p&gt; &lt;p id="p2"&gt; 我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var node = document.getElementsByClassName("class1")[0]; alert(node.innerHTML); &#125; 五、javascript中的CSS选择器1234567891011121314151617181920document.querySelector() //根据CSS选择器的规则，返回第一个匹配到的元素document.querySelectorAll() //根据CSS选择器的规则，返回所有匹配到的元素&lt;div id="div1"&gt; &lt;p id="p1" class="class1"&gt; 我是第一个P&lt;/p&gt; &lt;p id="p2" class="class2"&gt; 我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var node = document.querySelector("#div1 &gt; p"); alert(node.innerHTML); //输出 我是第一个P var node1 = document.querySelector(".class2"); alert(node1.innerHTML); //输出 我是第二个P var nodelist = document.querySelectorAll("p"); alert(nodelist[0].innerHTML + " - " + nodelist[1].innerHTML); //输出 我是第一个P - 我是第二个P&#125; 六、文档结构和遍历作为节点数的文档 ​ parentNode 获取该节点的父节点 ​ childNodes 获取该节点的子节点数组 ​ firstChild 获取该节点的第一个子节点 ​ lastChild 获取该节点的最后一个子节点 ​ nextSibling 获取该节点的下一个兄弟元素 ​ previoursSibling 获取该节点的上一个兄弟元素 ​ nodeType 节点的类型，9代表Document节点，1代表Element节点，3代表Text节点，8代表 Comment节点，11代表DocumentFragment节点 ​ nodeVlue Text节点或Comment节点的文本内容 ​ nodeName 元素的标签名(如P,SPAN,#text(文本节点),DIV)，以大写形式表示 注意，以上6个方法连元素节点也算一个节点。 12345678910111213141516171819202122232425262728293031323334353637&lt;div id="div1"&gt; &lt;p id="p1" class="class1"&gt; 我是第一个P&lt;/p&gt; &lt;p id="p2" class="class2"&gt; 我是第二个P&lt;/p&gt;&lt;/div&gt; window.onload = function () &#123; var node1 = document.querySelector(".class2"); alert(node1.parentNode.innerHTML); //输出 &lt;p id="p1" class="class1"&gt;我是第一个P&lt;/p&gt;&lt;p id="p2" class="class2"&gt;我是第二个P&lt;/p&gt; var nodelist = document.getElementById("div1"); var arr = nodelist.childNodes; alert(arr[1].innerHTML + " - " + arr[3].innerHTML); //输出 我是第一个P - 我是第二个P 为什么是1，3呢？因为本方法文本节点也会获取，也就是说0,2,4是文本节点 &#125;&lt;div id="div1"&gt; 文本1 &lt;p id="p1" class="class1"&gt; 我是第一个P&lt;/p&gt; 文本2 &lt;p id="p2" class="class2"&gt; 我是第二个P&lt;/p&gt; 文本3&lt;/div&gt;window.onload = function () &#123; //依次输出，文本1，我是第一个P，文本2，我是第二个P，文本3 var node = document.getElementById("div1"); for (var i = 0; i &lt; node.childNodes.length; i++) &#123; if (node.childNodes[i].nodeType == 1) &#123; alert(node.childNodes[i].innerHTML); &#125; else if (node.childNodes[i].nodeType == 3) &#123; alert(node.childNodes[i].nodeValue); &#125; &#125;&#125; 作为元素树的文档 ​ firstElementChild 第一个子元素节点 ​ lastElementChild 最后一个子元素节点 ​ nextElementSibling 下一个兄弟元素节点 ​ previousElementSibling 前一个兄弟元素节点 ​ childElementCount 子元素节点个数量 注意，此5个方法文本节点不算进去 123456789101112131415161718&lt;div id="div1"&gt; &lt;p id="p1" class="class1"&gt; 我是第一个P&lt;/p&gt; &lt;p id="p2" class="class2"&gt; 我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var node = document.getElementById("div1"); var node1 = node.firstElementChild; var node2 = node.lastElementChild; alert(node.childElementCount); //输出2，div1一共有两个非文档子元素节点 alert(node1.innerHTML); //输出 我是第一个P alert(node2.innerHTML); //输出 我是第二个P alert(node2.previousElementSibling.innerHTML); //输出 我是第一个P(第二个元素节点的上一个非文本元素节点是P1) alert(node1.nextElementSibling.innerHTML); //输出 我是第二个P(第一个元素节点的下一个兄弟非文本节点是P2)&#125; 七、javascript操作HTML属性1、属性的读取，此处要注意的是，某些HTML属性名称在javascript之中是保留字，因此会有些许不同，如class,lable中的for在javascript中变为htmlFor,className。1234567891011121314&lt;div id="div1"&gt; &lt;p id="p1" class="class1"&gt; 我是第一个P&lt;/p&gt; &lt;img src="123.jpg" alt="我是一张图片" id="img1" /&gt; &lt;input type="text" value="我是一个文本框" id="input1" /&gt;&lt;/div&gt;window.onload = function () &#123; var nodeText = document.getElementById("input1"); alert(nodeText.value); //输出 我是一个文本框 var nodeImg = document.getElementById("img1"); alert(nodeImg.alt); //输出 我是一张图片 var nodeP = document.getElementById("p1"); alert(nodeP.className); //输出 class1 注意获取class是className，如果写成nodeP.class则输出undefined&#125; 2、属性的设置，此处同样要注意的是保留字1234567&lt;div id="div1"&gt; &lt;img src="1big.jpg" alt="我是一张图片" id="img1" onclick="fun1()" /&gt;&lt;/div&gt;function fun1() &#123; document.getElementById("img1").src = "1small.jpg"; //改变图片的路径属性。实现的效果为，当点击图片时，大图变小图。&#125; 3、非标准HTML属性getAttribute(); // 注意这两个方法是不必理会javascript保留字的，HTML属性是什么就怎么写。setAttribute(); 12345678&lt;div id="div1"&gt; &lt;img src="1big.jpg" alt="我是一张图片" class="imgClass" id="img1" onclick="fun1()" /&gt;&lt;/div&gt;function fun1() &#123; document.getElementById("img1").setAttribute("src", "1small.jpg"); alert(document.getElementById("img1").getAttribute("class"));&#125; 4、Attr节点的属性attributes属性 非Element对象返回null，Element一半返回Attr对象。Attr对象是一个特殊的Node,通过name与value获取属性名称与值。如:document.getElementById(“img1”)[0]; document.getElementById(“img1”).src; 123456789&lt;div id="div1"&gt; &lt;img src="1big.jpg" alt="我是一张图片" class="imgClass" id="img1" onclick="fun1()" /&gt;&lt;/div&gt;function fun1() &#123; alert(document.getElementById("img1").attributes[0].name); //输出 onclick 注意，通过索引器访问是写在右面在排前面，从0开始 alert(document.getElementById("img1").attributes.src.value); //输出1big.jpg document.getElementById("img1").attributes.src.value = "1small.jpg"; //点击后改变src属性，实现了点击大图变小图效果&#125; 八、元素的内容1、innerText、textContent innerText与textContent的区别，当文本为空时，innerText是””，而textContent是undefined2、innerHTML 123456789101112&lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p id="p2"&gt;我是第&lt;b&gt;二&lt;/b&gt;个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; alert(document.getElementById("p1").innerText); //注意火狐浏览器不支持innerText alert(document.getElementById("p1").textContent); //基本都支持textContent document.getElementById("p1").textContent = "我是p1，javascript改变了我"; //设置文档Text alert(document.getElementById("p2").textContent); alert(document.getElementById("p2").innerHTML); //innerHTML与innerText的区别，就是对HTML代码的输出方式Text不会输出HTML代码&#125; 九、创建，插入，删除节点1、document.createTextNode() 创建一个文本节点12345678910111213141516&lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p id="p2"&gt;我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var textNode = document.createTextNode("&lt;p&gt;我是一个javascript新建的节点&lt;/p&gt;"); document.getElementById("div1").appendChild(textNode);&#125;/* 完成后HTML变为： div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p id="p2"&gt;我是第二个P&lt;/p&gt; &lt;p&gt;我是一个javascript新建的节点&lt;/p&gt; &lt;/div&gt; */ 2、document.createElement() 创建一个元素节点12345678910111213141516&lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p id="p2"&gt;我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var pNode = document.createElement("p"); pNode.textContent = "新建一个P节点"; document.getElementById("div1").appendChild(pNode);&#125;/* &lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p id="p2"&gt;我是第二个P&lt;/p&gt; &lt;p&gt;新建一个P节点&lt;/p&gt; &lt;/div&gt; */ 3、插入节点appendChild() //将一个节点插入到调用节点的最后面insertBefore() //接受两个参数，第一个为待插入的节点，第二个指明在哪个节点前面，如果不传入第二个参数，则跟appendChild一样，放在最后。 12345678910111213141516171819&lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var pNode1 = document.createElement("p"); pNode1.textContent = "insertBefore插入的节点"; var pNode2 = document.createElement("p"); pNode2.textContent = "appendChild插入的节点"; document.getElementById("div1").appendChild(pNode2); document.getElementById("div1").insertBefore(pNode1,document.getElementById("p1"));&#125;/* 执行之后HTML代码为： &lt;div id="div1"&gt; &lt;p&gt;insertBefore插入的节点&lt;/p&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p&gt;appendChild插入的节点&lt;/p&gt; &lt;/div&gt; */ 十、删除和替换节点。1、removeChild(); 由父元素调用，删除一个子节点。注意是直接父元素调用，删除直接子元素才有效，删除孙子元素就没有效果了。1234567891011121314&lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p id="p2"&gt;我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var div1 = document.getElementById("div1"); div1.removeChild(document.getElementById("p2"));&#125;/* 执行之后代码变为： &lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; //注意到第二个P元素已经被移除了 &lt;/div&gt; */ 2、replaceChild() //删除一个子节点，并用一个新节点代替它，第一个参数为新建的节点，第二个节点为被替换的节点1234567891011121314151617&lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;p id="p2"&gt;我是第二个P&lt;/p&gt;&lt;/div&gt;window.onload = function () &#123; var div1 = document.getElementById("div1"); var span1 = document.createElement("span"); span1.textContent = "我是一个新建的span"; div1.replaceChild(span1,document.getElementById("p2"));&#125;/* 执行完成后HTML代码变为： &lt;div id="div1"&gt; &lt;p id="p1"&gt;我是第一个P&lt;/p&gt; &lt;span&gt;我是一个新建的span&lt;/span&gt; //留意到p2节点已经被替换为span1节点了 &lt;/div&gt; */ 十一、javascript操作元素CSS通过元素的style属性可以随意读取和设置元素的CSS样式，例子： 123456789101112&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; window.onload = function () &#123; alert(document.getElementById("div1").style.backgroundColor); document.getElementById("div1").style.backgroundColor = "yellow"; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="div1" style="width:100px; height:100px; background-color:red"&gt;&lt;/div&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>DOM操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript编码规范]]></title>
    <url>%2F2017%2F05%2F06%2FJavaScript%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[前言好的编码规范可以尽可能的减少一个软件的维护成本，并且几乎没有任何一个软件，在其整个生命周期中，均由最初的开发人员来维护；好的编码规范可以改善软件的可读性，可以让开发人员尽快而彻底地理解新的代码；好的编码规范可以最大限度的提高团队开发的合作效率；长期的规范性编码还可以让开发人员养成好的编码习惯，甚至锻炼出更加严谨的思维。 不规范写法举例句尾没有分号1var isHotel = json.type == "hotel" ? true : false 变量命名各种各样123var is_hotel;var isHotel;var ishotel; if缩写1234if (isHotel) console.log(true)else console.log(false) 使用eval1234567var json = eval(jsonText);/* eval 好不好取决于怎么使用它，一般认为的缺点： 1. 可读性非常差 2. 不好再做优化和编译 3. 会轻微增加性能消耗 4. 不安全，比如 eval input 的值 */ 变量未定义到处都是123456function() &#123; var isHotel = 'true'; ....... var html = isHotel ? '&lt;p&gt;hotel&lt;/p&gt;' : "";&#125; 超长函数12345function() &#123; var isHotel = 'true'; //....... 此处省略500行 return false;&#125; ……….书写不规范的代码让我们难以维护，有时候也让我们头疼。 （禁止）、（必须）等字眼，在这里只是表示强调，未严格要求。 前端规范之JavaScripttab键用（必须）用四个空格代替​ 因为在不同系统的编辑工具对tab解析不一样，windows下的tab键是占四个空格的位置，而在linux下会变成占八个空格的位置（除非你自己设定了tab键所占的位置长度）。 一些童鞋可能会有疑问，tab键换成四个空格，多麻烦啊~ 其实不然，我平时用sublime text比较多，在这个工具中可以对tab键进行设置。 每句代码后（必须）加”;” 这个是要引起注意的，比如： 1234a = b // 赋值(function()&#123; //....&#125;)() // 自执行函数 未加分号，结果被解析成 1a = b(function()&#123;//...&#125;)() //将b()()返回的结果赋值给a 这是截然不同的两个结果，所以对于这个问题必须引起重视！！！ 变量、常量、类的命名按（必须）以下规则执行：变量：必须采用骆驼峰的命名且首字母小写123456789// 正确的命名 var isHotel, isHotelBeijing, isHotelBeijingHandian; // 不推荐的命名 var is_Hotel, ishotelbeijing, IsHotelBeiJing; 常量：必须采用全大写的命名，且单词以_分割**，常量通常用于ajax请求url，和一些不会改变的数据 123// 正确的命名 var HOTEL_GET_URL = 'http://map.baidu.com/detail', PLACE_TYPE = 'hotel'; 类：必须采用骆驼峰的命名且首字母大写，如：1234// 正确的写法 var FooAndToo = function(name) &#123; this.name = name; &#125; 空格的使用1.if中的空格，先上例子 1234567891011 //正确的写法 if (isOk) &#123; console.log("ok"); &#125; //不推荐的写法 if(isOk)&#123; console.log("ok"); &#125;/* ()中的判断条件前后都(必须)加空格 ()里的判断前后(禁止)加空格，如：正确的写法: if (isOk)；不推荐的写法: if ( isOk ) */ 2.switch中的空格, 先上例子 1234567891011121314151617181920212223242526//正确的写法 switch(name) &#123; case "hotel": console.log(name); break; case "moive": console.log(name); break; default: // code &#125; //不推荐的写法 switch (name) &#123; // switch 后不应该有空格, 正确的写法: switch(name) &#123; // code case "hotel": console.log(name); break; // break; 应该和console.log对齐 case "movie": // 每个case之前需要有换行 console.log(name); break; // break; 应该和console.log对齐 default: // code &#125; 3.for中的空格，先上例子 12345678910111213141516171819 // 正确的写法 var names = ["hotel", "movie"], i, len; for (i=0, len=names.length; i &lt; len; i++) &#123; // code &#125; // 不推荐的写法 var names = ["hotel", "movie"], i, len; for(i = 0, len = names.length;i &lt; len;i++) &#123; // for后应该有空格，每个`;`号后需要有空格，变量的赋值不应该有空格 // code &#125;/* for后（必须）加空格 每个;后（必须）加空格 ()中禁止用var声明变量; 且变量的赋值 = 前后（禁止）加空格 */ 4.function 中的空格, 先上例子 12345678910111213141516 // 正确的写法 function call(name) &#123; &#125; var cell = function () &#123; &#125;; // 不推荐的写法 var call = function(name)&#123; // code &#125; /* 参数的反括号后（必须）加空格 function 后（必须）加空格 */ 5.var 中空格及定义，先上例子 12345678910111213 // 一个推荐的var写法组 function(res) &#123; var code = 1 + 1, json = JSON.parse(res), type, html; // code &#125;/* 声明变量 = 前后（必须）添加空格 每个变量的赋值声明以,结束后（必须）换行进行下一个变量赋值声明 （推荐）将所有不需要进行赋值的变量声明放置最后一行，且变量之间不需要换行 （推荐）当一组变量声明完成后，空一行后编写其余代码 */ 6.在同一个函数内部，局部变量的声明必须置于顶端 因为即使放到中间，js解析器也会提升至顶部（hosting） 1234567891011121314151617181920// 正确的书写var clear = function(el) &#123; var id = el.id, name = el.getAttribute("data-name"); ......... return true;&#125;// 不推荐的书写var clear = function(el) &#123; var id = el.id; ...... var name = el.getAttribute("data-name"); ......... return true;&#125; 7.块内函数必须用局部变量声明 123456789101112131415161718192021222324// 错误的写法 var call = function(name) &#123; if (name == "hotel") &#123; function foo() &#123; console.log("hotel foo"); &#125; &#125; foo &amp;&amp; foo(); &#125; // 推荐的写法 var call = function(name) &#123; var foo; if (name == "hotel") &#123; foo = function() &#123; console.log("hotel foo"); &#125; &#125; foo &amp;&amp; foo(); &#125;/* 引起的bug：第一种写法foo的声明被提前了; 调用call时：第一种写法会调用foo函数，第二种写法不会调用foo函数 */ 8.（禁止）使用eval，采取$.parseJSON 三个原因： 有注入风险，尤其是ajax返回数据 不方便debug 效率低，eval是一个执行效率很低的函数 建议： 使用new Function来代替eval的使用，最好就别用。 9.除了三目运算，if,else等（禁止）简写 12345678910111213// 正确的书写if (true) &#123; alert(name);&#125;console.log(name);// 不推荐的书写if (true) alert(name);console.log(name);// 不推荐的书写if (true)alert(name);console.log(name) 10.（推荐）在需要以{}闭合的代码段前增加换行，如：for if 1234567891011121314151617181920212223242526272829303132// 没有换行，小的代码段无法区分 if (wl &amp;&amp; wl.length) &#123; for (i = 0, l = wl.length; i &lt; l; ++i) &#123; p = wl[i]; type = Y.Lang.type(r[p]); if (s.hasOwnProperty(p)) &#123; if (merge &amp;&amp; type == 'object') &#123; Y.mix(r[p], s[p]); &#125; else if (ov || !(p in r)) &#123; r[p] = s[p]; &#125; &#125; &#125; &#125; // 有了换行，逻辑清楚多了 if (wl &amp;&amp; wl.length) &#123; for (i = 0, l = wl.length; i &lt; l; ++i) &#123; p = wl[i]; type = Y.Lang.type(r[p]); if (s.hasOwnProperty(p)) &#123; // 处理merge逻辑 if (merge &amp;&amp; type == 'object') &#123; Y.mix(r[p], s[p]); &#125; else if (ov || !(p in r)) &#123; r[p] = s[p]; &#125; &#125; &#125; &#125;/* 换行可以是空行，也可以是注释 */ 11.（推荐）使用Function进行类的定义，(不推荐)继承，如需继承采用成熟的类库实现继承 12345678910111213141516171819// 类的实现 function Person(name) &#123; this.name = name; &#125; Person.prototype.sayName = function() &#123; alert(this.name); &#125;; var me = new Person("Nicholas"); // 将this放到局部变量self function Persion(name, sex) &#123; var self = this; self.name = name; self.sex = sex; &#125;/* 平时咱们写代码，基本都是小程序，真心用不上什么继承，而且继承并不是JS的擅长的语言特性，尽量少用。如果非要使用的话，注意一点： */ 123456789function A()&#123; //...&#125;function B()&#123; //...&#125;B.prototype = new A();B.prototype.constructor = B; //原则上，记得把这句话加上/* 继承从原则上来讲，别改变他的构造函数，否则这个继承就显得很别扭了~ */ 12.(推荐)使用局部变量缓存反复查找的对象(包括但不限于全局变量、dom查询结果、作用域链较深的对象) 1234567// 缓存对象var getComment = function() &#123; var dom = $("#common-container"), // 缓存dom appendTo = $.appendTo, // 缓存全局变量 data = this.json.data; // 缓存作用域链较深的对象&#125; 13.当需要缓存 this 时必须使用 self 变量进行缓存 12345678910// 缓存this function Row(name) &#123; var self = this; self.name = name; $(".row").click(function() &#123; self.getName(); &#125;); &#125;/* self是一个保留字，不过用它也没关系。在这里，看个人爱好吧，可以用_this, that, me等这些词，都行，但是团队开发的时候统一下比较好。 */ 14.（不推荐）超长函数, 当函数超过100行，就要想想是否能将函数拆为两个或多个函数 15.待挖掘… 小结规范是死的，罗列这些东西，目的是为了让程序猿们对这些东西引起注意，平时写代码的时候注意格式，不仅仅方便了自己，也让其他阅读者看得舒服。可能还有一些地方没有涉及到，如果你有好的建议，欢迎提出来补充！]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>编码规范</tag>
      </tags>
  </entry>
</search>